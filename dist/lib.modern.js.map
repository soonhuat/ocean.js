{"version":3,"file":"lib.modern.js","sources":["../src/config/Config.ts","../src/utils/Constants.ts","../src/utils/ContractUtils.ts","../src/utils/Logger.ts","../src/utils/DatatokenName.ts","../src/utils/DdoHelpers.ts","../src/utils/FetchHelper.ts","../src/utils/General.ts","../src/utils/minAbi.ts","../src/utils/SignatureUtils.ts","../src/utils/TokenUtils.ts","../src/utils/ProviderErrors.ts","../src/config/ConfigHelper.ts","../src/contracts/SmartContract.ts","../src/contracts/SmartContractWithAddress.ts","../src/contracts/Dispenser.ts","../src/contracts/FixedRateExchange.ts","../src/contracts/Router.ts","../src/contracts/NFT.ts","../src/contracts/Datatoken.ts","../src/contracts/NFTFactory.ts","../src/contracts/ve/VeOcean.ts","../src/contracts/ve/VeFeeDistributor.ts","../src/contracts/ve/VeFeeEstimate.ts","../src/contracts/ve/VeAllocate.ts","../src/contracts/df/DfRewards.ts","../src/contracts/df/DfStrategyV1.ts","../src/services/Aquarius.ts","../src/services/Provider.ts"],"sourcesContent":["import { AbiItem } from '../@types'\nimport { LogLevel } from '../utils'\n\nexport class Config {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public nftFactoryAddress?: string\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, goerli, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  gasFeeMultiplier: number\n\n  veAllocate?: string\n  veOCEAN?: string\n  veDelegation?: string\n  veFeeDistributor?: string\n  veDelegationProxy?: string\n  DFRewards?: string\n  DFStrategyV1?: string\n  veFeeEstimate?: string\n}\n","export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\nexport const MAX_UINT_256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\nexport const FEE_HISTORY_NOT_SUPPORTED =\n  'Returned error: Method eth_feeHistory not supported.'\n","import { ethers, Signer, providers, Contract, ContractFunction, BigNumber } from 'ethers'\n\nimport { Config } from '../config'\nimport { minAbi, GASLIMIT_DEFAULT, LoggerInstance, FEE_HISTORY_NOT_SUPPORTED } from '.'\n\nconst MIN_GAS_FEE_POLYGON = 30000000000 // minimum recommended 30 gwei polygon main and mumbai fees\nconst POLYGON_NETWORK_ID = 137\nconst MUMBAI_NETWORK_ID = 80001\n\nexport function setContractDefaults(contract: Contract, config: Config): Contract {\n  // TO DO - since ethers does not provide this\n  /* if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  */\n  return contract\n}\n\n/**\n * Asynchronous function that returns a fair gas price based on the current gas price and a multiplier.\n * @param {Signer} signer - The signer object to use for fetching the current gas price.\n * @param {number} gasFeeMultiplier - The multiplier to apply to the current gas price. If not provided, the current gas price is returned as a string.\n * @returns A Promise that resolves to a string representation of the fair gas price.\n */\nexport async function getFairGasPrice(\n  signer: Signer,\n  gasFeeMultiplier: number\n): Promise<string> {\n  const price = await (await signer.provider.getFeeData()).gasPrice\n  const x = ethers.BigNumber.from(price.toString())\n  if (gasFeeMultiplier) return x.mul(gasFeeMultiplier).toBigInt().toString(10)\n  else return x.toString()\n}\n\n/**\n * Asynchronous function that returns the number of decimal places for a given token.\n * @param {Signer} signer - The signer object to use for fetching the token decimals.\n * @param {string} token - The address of the token contract.\n * @returns A Promise that resolves to the number of decimal places for the token.\n */\nexport async function getTokenDecimals(signer: Signer, token: string) {\n  const tokenContract = new ethers.Contract(token, minAbi, signer)\n  return tokenContract.decimals()\n}\n\n/**\n * Converts an amount of units to tokens\n * @param {Signer} signer -  The signer object to use.\n * @param {string} token - The token to convert\n * @param {string} amount - The amount of units to convert\n * @param {number} [tokenDecimals] - The number of decimals in the token\n * @returns {Promise<string>} - The converted amount in tokens\n */\nexport async function unitsToAmount(\n  signer: Signer,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  let decimals = tokenDecimals || (await getTokenDecimals(signer, token))\n  if (decimals === '0') {\n    decimals = 18\n  }\n\n  const amountFormatted = ethers.utils.formatUnits(amount, decimals)\n  return amountFormatted.toString()\n}\n\n/**\n * Converts an amount of tokens to units\n * @param {Signer} signer -  The signer object to use.\n * @param {string} token - The token to convert\n * @param {string} amount - The amount of tokens to convert\n * @param {number} [tokenDecimals] - The number of decimals of the token\n * @returns {Promise<string>} - The converted amount in units\n */\nexport async function amountToUnits(\n  signer: Signer,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  let decimals = tokenDecimals || (await getTokenDecimals(signer, token))\n  if (decimals === '0') {\n    decimals = 18\n  }\n  const amountFormatted = ethers.utils.parseUnits(amount, decimals)\n  return amountFormatted.toString()\n}\n\nexport function getEventFromTx(txReceipt, eventName) {\n  return txReceipt?.events?.filter((log) => {\n    return log.event === eventName\n  })[0]\n}\n\n/**\n * Send the transation on chain\n * @param {BigNumber} estGas estimated gas for the transaction\n * @param {Signer} signer signer object\n * @param {number} gasFeeMultiplier number represinting the multiplier we apply to gas fees\n * @param {Function} functionToSend function that we need to send\n * @param {...any[]} args arguments of the function\n * @return {Promise<any>} transaction receipt\n */\nexport async function sendTx(\n  estGas: BigNumber,\n  signer: Signer,\n  gasFeeMultiplier: number,\n  functionToSend: ContractFunction,\n  ...args: any[]\n): Promise<providers.TransactionResponse> {\n  const { chainId } = await signer.provider.getNetwork()\n  const feeHistory = await signer.provider.getFeeData()\n  let overrides\n  if (feeHistory.maxPriorityFeePerGas) {\n    let aggressiveFeePriorityFeePerGas = feeHistory.maxPriorityFeePerGas.toString()\n    let aggressiveFeePerGas = feeHistory.maxFeePerGas.toString()\n    if (gasFeeMultiplier > 1) {\n      aggressiveFeePriorityFeePerGas = Math.round(\n        feeHistory.maxPriorityFeePerGas.toNumber() * gasFeeMultiplier\n      ).toString()\n      aggressiveFeePerGas = Math.round(\n        feeHistory.maxFeePerGas.toNumber() * gasFeeMultiplier\n      ).toString()\n    }\n    overrides = {\n      maxPriorityFeePerGas:\n        (chainId === MUMBAI_NETWORK_ID || chainId === POLYGON_NETWORK_ID) &&\n        Number(aggressiveFeePriorityFeePerGas) < MIN_GAS_FEE_POLYGON\n          ? MIN_GAS_FEE_POLYGON\n          : Number(aggressiveFeePriorityFeePerGas),\n      maxFeePerGas:\n        (chainId === MUMBAI_NETWORK_ID || chainId === POLYGON_NETWORK_ID) &&\n        Number(aggressiveFeePerGas) < MIN_GAS_FEE_POLYGON\n          ? MIN_GAS_FEE_POLYGON\n          : Number(aggressiveFeePerGas)\n    }\n  } else {\n    overrides = {\n      gasPrice: feeHistory.gasPrice\n    }\n  }\n  overrides.gasLimit = estGas.add(20000)\n  try {\n    const trxReceipt = await functionToSend(...args, overrides)\n    return trxReceipt\n  } catch (e) {\n    return null\n  }\n}\n","/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\n","import wordListDefault from './data/words.json'\n\n/**\n * This function generates a datatoken name and symbol from a given word list.\n * @param {Object} [wordList] - An object containing an array of nouns and adjectives.\n * @param {string[]} [wordList.nouns] - An array of nouns.\n * @param {string[]} [wordList.adjectives] - An array of adjectives.\n * @returns {Object} Returns an object containing the generated name and symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import sha256 from 'crypto-js/sha256'\nimport { ethers } from 'ethers'\n\n/**\n * Generates a valid DID\n * @param {string} nftAddress - The NFT address\n * @param {number} chainId - The chain ID\n * @returns {string} - The DID\n */\nexport function generateDid(nftAddress: string, chainId: number): string {\n  nftAddress = ethers.utils.getAddress(nftAddress)\n  const checksum = sha256(nftAddress + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\n/**\n * Returns the SHA256 hash of the input data\n * @param {any} data - The input data\n * @returns {string} - The SHA256 hash of the input data\n */\nexport function getHash(data: any): string {\n  return sha256(data).toString()\n}\n","import fetch from 'cross-fetch'\nimport { DownloadResponse } from '../@types'\n\n/**\n * Triggers  a file download from the specified URL when called from a browser context.\n * @param {string} url - The URL of the file to download\n * @returns {Promise<void>} - A Promise that resolves when the file has been downloaded\n */\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const headResponse = await fetch(url, { method: 'HEAD' })\n  const contentHeader = headResponse.headers.get('content-disposition')\n  const fileName = contentHeader?.split('=')[1] ? contentHeader?.split('=')[1] : 'file'\n  const xhr = new XMLHttpRequest()\n  xhr.responseType = 'blob'\n  xhr.open('GET', url)\n  xhr.onload = () => {\n    const blobURL = window.URL.createObjectURL(xhr.response)\n    const a = document.createElement('a')\n    a.href = blobURL\n    a.setAttribute('download', fileName)\n    document.body.appendChild(a)\n    a.click()\n    a.remove()\n    window.URL.revokeObjectURL(blobURL)\n  }\n  xhr.send(null)\n}\n\n/**\n * Triggers  a file download from the specified URL when called from a browser context.\n * @param {string} url - The URL of the file to download\n * @param {number} [index] - The file index\n * @returns {Promise<void>} - A Promise that resolves when the file has been downloaded\n */\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n","/**\n * Simple blocking sleep function\n * @param {number} ms - Number of miliseconds to wait\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","export const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n]\n","import { ethers, Signer, providers } from 'ethers'\n\n/**\n * Signs the hash of a message using the provided signer.\n * @param {Signer} signer - The signer to use for signing the hash.\n * @param {string} message - The message to sign.\n * @returns {Promise<string>} - A Promise that resolves to the signature of the hash of the message.\n */\nexport async function signHash(signer: Signer, message: string) {\n  // Since ganache has no support yet for personal_sign, we must use the legacy implementation\n  // const signedMessage = await user2.signMessage(message)\n\n  const messageHashBytes = ethers.utils.arrayify(message)\n  let signedMessage = await (signer as providers.JsonRpcSigner)._legacySignMessage(\n    messageHashBytes\n  )\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n\n  return { v, r, s }\n}\n","import Decimal from 'decimal.js'\nimport { ethers, Signer, BigNumber } from 'ethers'\nimport { amountToUnits, unitsToAmount, minAbi, sendTx, LoggerInstance } from '.'\nimport { Config } from '../config'\nimport { ReceiptOrEstimate, ReceiptOrDecimal } from '../@types'\n\n/**\n * Approve spender to spent amount tokens\n * @param {Signer} signer - The signer object\n * @param {Config} config - The config object\n * @param {string} account - The address of the caller\n * @param {string} tokenAddress - The address of the token\n * @param {string} spender - The address of the spender\n * @param {String} amount amount of ERC20 Datatokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {number} [tokenDecimals] optional number of decimals of the token\n * @param {boolean} [estimateGas]  if true, returns the estimate gas cost for calling the method\n */\nexport async function approve<G extends boolean = false>(\n  signer: Signer,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  tokenDecimals?: number,\n  estimateGas?: G\n): Promise<ReceiptOrDecimal<G> | number> {\n  const tokenContract = new ethers.Contract(tokenAddress, minAbi, signer)\n  if (!force) {\n    const currentAllowence = await allowance(signer, tokenAddress, account, spender)\n    if (new Decimal(currentAllowence).greaterThanOrEqualTo(new Decimal(amount))) {\n      return <ReceiptOrDecimal<G>>new Decimal(currentAllowence).toNumber()\n    }\n  }\n  const amountFormatted = await amountToUnits(signer, tokenAddress, amount, tokenDecimals)\n  const estGas = await tokenContract.estimateGas.approve(spender, amountFormatted)\n  if (estimateGas) return <ReceiptOrDecimal<G>>(<unknown>new Decimal(estGas.toString()))\n\n  const trxReceipt = await sendTx(\n    estGas,\n    signer,\n    config?.gasFeeMultiplier,\n    tokenContract.approve,\n    spender,\n    amountFormatted\n  )\n  return <ReceiptOrDecimal<G>>trxReceipt\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {Signer} signer - The signer object\n * @param {Config} config - The config object\n * @param {string} account - The address of the caller\n * @param {string} tokenAddress - The address of the token\n * @param {string} spender - The address of the spender\n * @param {string} amount amount of ERC20 tokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {boolean} [estimateGas]  if true, returns the estimate gas cost for calling the method\n */\nexport async function approveWei<G extends boolean = false>(\n  signer: Signer,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new ethers.Contract(tokenAddress, minAbi, signer)\n  if (!force) {\n    const currentAllowence = await allowanceWei(signer, tokenAddress, account, spender)\n    if (ethers.BigNumber.from(currentAllowence).gt(ethers.BigNumber.from(amount))) {\n      return <ReceiptOrEstimate<G>>ethers.BigNumber.from(currentAllowence)\n    }\n  }\n  let result = null\n\n  const estGas = await tokenContract.estimateGas.approve(spender, amount)\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  try {\n    result = await sendTx(\n      estGas,\n      signer,\n      config?.gasFeeMultiplier,\n      tokenContract.approve,\n      spender,\n      amount\n    )\n  } catch (e) {\n    LoggerInstance.error(\n      `ERROR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Moves amount tokens from the caller’s account to recipient.\n * @param {Signer} signer - The signer object\n * @param {Config} config - The config object\n * @param {string} tokenAddress - The address of the token\n * @param {string} recipient - The address of the tokens receiver\n * @param {String} amount amount of ERC20 Datatokens (not as wei)\n * @param {String} estimateGas  if true returns the gas estimate\n */\nexport async function transfer<G extends boolean = false>(\n  signer: Signer,\n  config: Config,\n  tokenAddress: string,\n  recipient: string,\n  amount: string,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new ethers.Contract(tokenAddress, minAbi, signer)\n  const amountFormatted = await amountToUnits(signer, tokenAddress, amount)\n  const estGas = await tokenContract.estimateGas.transfer(recipient, amountFormatted)\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  const trxReceipt = await sendTx(\n    estGas,\n    signer,\n    config?.gasFeeMultiplier,\n    tokenContract.transfer,\n    recipient,\n    amountFormatted\n  )\n  return <ReceiptOrEstimate<G>>trxReceipt\n}\n\n/**\n * Get Allowance for any Datatoken\n * @param {Signer} signer - The signer object\n * @param {string} tokenAddress - The address of the token\n * @param {string} account - The address of the caller\n * @param {string} spender - The address of the spender\n * @param {number} tokenDecimals optional number of decimals of the token\n */\nexport async function allowance(\n  signer: Signer,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new ethers.Contract(tokenAddress, minAbi, signer)\n  const trxReceipt = await tokenContract.allowance(account, spender)\n\n  return await unitsToAmount(signer, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get balance for any Datatoken\n * @param {Signer} signer - The signer object\n * @param {string} tokenAddress - The address of the token\n * @param {string} account - The address of the caller\n * @param {number} [tokenDecimals] optional number of decimals of the token\n */\nexport async function balance(\n  signer: Signer,\n  tokenAddress: string,\n  account: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new ethers.Contract(tokenAddress, minAbi, signer)\n  const trxReceipt = await tokenContract.balanceOf(account)\n\n  return await unitsToAmount(signer, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get Allowance in wei for any erc20\n * @param {Signer} signer - The signer object\n * @param {string} tokenAddress - The address of the token\n * @param {string} account - The address of the caller\n * @param {string} spender - The address of the spneder\n */\nexport async function allowanceWei(\n  signer: Signer,\n  tokenAddress: string,\n  account: string,\n  spender: string\n): Promise<string> {\n  const tokenContract = new ethers.Contract(tokenAddress, minAbi, signer)\n  return await tokenContract.allowance(account, spender)\n}\n\n/**\n * Get decimals for any Datatoken\n * @param {Signer} signer - The signer object\n * @param {String} tokenAddress - The address of the token\n * @return {Promise<number>} Number of decimals of the token\n */\nexport async function decimals(signer: Signer, tokenAddress: string): Promise<number> {\n  const tokenContract = new ethers.Contract(tokenAddress, minAbi, signer)\n  return await tokenContract.decimals()\n}\n","import { LoggerInstance } from './Logger'\n\nconst PREDEFINED_ERRORS = {\n  datasets: {\n    invalid: 'Datasets is not a list, as expected'\n  },\n  algorithm: {\n    serviceId: {\n      missing: 'The serviceId key is missing from the algorithm s DDO.',\n      not_found: 'The provided serviceId does not exist.',\n      service_not_access_compute: 'Service type is neither access, nor compute.',\n      main_service_compute:\n        'If the main service is not compute for this asset when calling initialize endpoint.',\n      compute_services_not_in_same_provider:\n        'Files attached to the compute service are not decrypted by the correct provider. This occurs when both asset and algorithm are requested by their compute service which cannot be decrypted by a single provider as how it is supposed to be.'\n    },\n    container: {\n      checksum_prefix: 'Container checksum does not start with the prefix sha256:.',\n      mising_entrypoint_image_checksum:\n        'Either entrypoint, either image, or either checksum are missing from the container dictionary from the algorithm s DDO.'\n    },\n    documentId: {\n      did_not_found:\n        'The algorithm s DID could not be retrieved from the metadata store, because the algorithm asset does not exist.',\n      missing: 'The documentId key is missing from the algorithm s DDO.'\n    },\n    transferTxId: {\n      missing: 'The transferTxId key is missing from the algorithm s DDO.'\n    },\n    missing_meta_documentId: 'Either algorithm metadata, or algorithm DID are missing.',\n    did_not_found: 'Either algorithm metadata, or algorithm DID are missing.',\n    not_algo: 'Either algorithm metadata, or algorithm DID are missing.',\n    in_use_or_not_on_chain: 'Either algorithm metadata, or algorithm DID are missing.',\n    meta_oneof_url_rawcode_remote:\n      'Either algorithm metadata, or algorithm DID are missing.',\n    file_unavailable:\n      'One possibility is that the asset could not be retrieved from Aquariuss database. Otherwise, there are issues related to services'\n  },\n  error: {\n    not_trusted_algo_publisher:\n      \"The owner of the algorithm's DDO is not a trusted algorithms publishers list.\",\n    not_trusted_algo:\n      \"The algorithm's DID is not in the asset's trusted algorithms dictionary. \",\n    no_publisherTrustedAlgorithms:\n      \"The algorithm's key publisherTrustedAlgorithms does not exist in the algorithm's DDO.\",\n    algorithm_file_checksum_mismatch:\n      \"filesChecksum from the algorithm's DDO is invalid.\",\n    algorithm_container_checksum_mismatch:\n      \"The containerChecksum from the algorithm's DDO is invalid.\",\n    no_raw_algo_allowed: 'The asset does not allow raw algorithms to be run on it.',\n    'Asset malformed':\n      'The asset published on chain is malformed, missing some required keys or not compliant with our schemas.',\n    'Asset is not consumable.':\n      'Assets metadata status is not in the range of valid status codes for assets. The recognized states for the metadata are defined on our docs.',\n    'DID is not a valid algorithm.':\n      'Either the algorithm assets DID is incorrectly typed, either the algorithm timeout expired.',\n    'Compute environment does not exist.':\n      'The compute environment provided by the user does not exist, it is not served by our compute-to-data feature. The user can use get_c2d_environments to check the list of available compute environments.',\n    'The validUntil value is not correct.': 'validUntil value is most probably expired.',\n    'Cannot resolve DID': 'The dataset DID does not exist in the Metadata store.',\n    'Invalid serviceId': 'The serviceId of that dataset is not correct.',\n    'Unable to get dataset files':\n      'The files of that dataset could not be decrypted or retrieved',\n    'cannot decrypt files for this service.':\n      'The files of that dataset could not be decrypted due to the fact that file object, which contains the structure and the type of specific file, is missing from the validation part.',\n    'Unsupported type ': 'The file object type is not supported by Provider.',\n    'malformed file object':\n      'The file object structure is invalid and does not contain the wanted information for the specific file.'\n  },\n  order: {\n    fees_not_paid: ' Provider fees are not paid.'\n  },\n  output: {\n    invalid:\n      'The algorithms validation after the build stage has not been decoded properly as a dictionary.'\n  }\n}\n\nexport function getErrorMessage(error: Object): string {\n  const key = Object.keys(error)[0]\n  if (key === 'error') {\n    const message = error[key]\n    const errorMessage =\n      PREDEFINED_ERRORS[key][message] || `Provider request failed: ${message}`\n    return errorMessage\n  } else {\n    const errorObject = error[key]\n    const messagekey = Object.keys(error)[1]\n    const errorMessage = error[messagekey]\n    return `${errorMessage} : ${errorObject}`\n  }\n}\n","// eslint-disable-next-line import/no-named-default\n// import { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport { Config } from '.'\nimport { LoggerInstance } from '../utils'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '../../address.json'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'https://v4.provider.oceanprotocol.com',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    // comment th following configs if running on macOS\n    metadataCacheUri: 'http://172.15.0.5:5000',\n    providerUri: 'http://172.15.0.4:8030',\n    subgraphUri: 'https://172.15.0.15:8000'\n    // uncomment the following configs if running on macOS\n    // metadataCacheUri: 'http://127.0.0.1:5000',\n    // providerUri: 'http://127.0.0.1:8030/',\n    // subgraphUri: 'http://127.0.0.1:9000/'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 5,\n    network: 'goerli',\n    nodeUri: 'https://goerli.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://goerli.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 11155111,\n    network: 'sepolia',\n    nodeUri: 'https://sepolia.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.sepolia.oceanprotocol.com',\n    explorerUri: 'https://sepolia.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN',\n    gasFeeMultiplier: 1.6\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 81001,\n    network: 'polygonedge',\n    nodeUri: 'https://rpc-edgenet.polygon.technology',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://explorer-edgenet.polygon.technology/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 100,\n    network: 'gen-x-testnet',\n    nodeUri: 'https://rpc.genx.minimal-gaia-x.eu',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://logging.genx.minimal-gaia-x.eu/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 13520,\n    network: 'acentrik-testnet',\n    nodeUri: '',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: '',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      const {\n        FixedPrice,\n        Dispenser,\n        ERC721Factory,\n        OPFCommunityFeeCollector,\n        Ocean,\n        chainId,\n        startBlock,\n        veAllocate,\n        veOCEAN,\n        veDelegation,\n        veFeeDistributor,\n        veDelegationProxy,\n        DFRewards,\n        DFStrategyV1,\n        veFeeEstimate\n      } = customAddresses[network]\n      configAddresses = {\n        nftFactoryAddress: ERC721Factory,\n        opfCommunityFeeCollector: OPFCommunityFeeCollector,\n        fixedRateExchangeAddress: FixedPrice,\n        dispenserAddress: Dispenser,\n        oceanTokenAddress: Ocean,\n        chainId,\n        startBlock,\n        veAllocate,\n        veOCEAN,\n        veDelegation,\n        veFeeDistributor,\n        veDelegationProxy,\n        DFRewards,\n        DFStrategyV1,\n        veFeeEstimate,\n        ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock,\n          veAllocate,\n          veOCEAN,\n          veDelegation,\n          veFeeDistributor,\n          veDelegationProxy,\n          DFRewards,\n          DFStrategyV1,\n          veFeeEstimate\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          nftFactoryAddress: ERC721Factory,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId,\n          startBlock,\n          veAllocate,\n          veOCEAN,\n          veDelegation,\n          veFeeDistributor,\n          veDelegationProxy,\n          DFRewards,\n          DFStrategyV1,\n          veFeeEstimate,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  /**\n   * Returns the config object for a specific network supported by the oceanprotocol stack\n   * @param {string | number} network the network's chainId or name\n   * @param {string} infuraProjectId optional infura project id that will replace the configs node URI\n   * @return {Config} Config obhjedct\n   */\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n    console.log(`debug configHelperNetworks: `, configHelperNetworks)\n\n    if (!config) {\n      LoggerInstance.error(\n        `No config found for given network '${network}' filter by '${filterBy}'`\n      )\n      return null\n    }\n\n    const contractAddressesConfig = this.getAddressesFromEnv(config.network)\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import { ethers, Signer, Contract } from 'ethers'\nimport { AbiItem } from '../@types'\nimport { Config, ConfigHelper } from '../config'\nimport {\n  amountToUnits,\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount\n} from '../utils'\n\nexport abstract class SmartContract {\n  public signer: Signer\n  public config: Config\n  public abi: AbiItem[]\n\n  abstract getDefaultAbi()\n\n  /**\n   * Instantiate the smart contract.\n   * @param {Signer} signer The signer object.\n   * @param {string | number} [network] Network id or name\n   * @param {Config} [config] The configuration object.\n   * @param {AbiItem[]} [abi] ABI array of the smart contract\n   */\n  constructor(\n    signer: Signer,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem[]\n  ) {\n    this.signer = signer\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.abi = abi || this.getDefaultAbi()\n  }\n\n  /**\n   * Converts an amount of tokens to units\n   * @param {string} token - The token to convert\n   * @param {string} amount - The amount of tokens to convert\n   * @param {number} [tokenDecimals] - The number of decimals of the token\n   * @returns {Promise<string>} - The converted amount in units\n   */\n  protected async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return amountToUnits(this.signer, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Converts an amount of units to tokens\n   * @param {string} token - The token to convert\n   * @param {string} amount - The amount of units to convert\n   * @param {number} [tokenDecimals] - The number of decimals in the token\n   * @returns {Promise<string>} - The converted amount in tokens\n   */\n  protected async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.signer, token, amount, tokenDecimals)\n  }\n\n  /**\n   * Retruns the gas price\n   * @returns {Promise<string>} - The fair gas price\n   */\n  protected async getFairGasPrice(): Promise<string> {\n    return getFairGasPrice(this.signer, this.config?.gasFeeMultiplier)\n  }\n\n  /**\n   * Returns a contract instance for the given address\n   * @param {string} address - The address of the contract\n   * @param {AbiItem[]} [abi] - The ABI of the contract\n   * @returns {Contract} - The contract instance\n   */\n  protected getContract(address: string, abi?: AbiItem[]): Contract {\n    const abiToUse = abi || this.abi\n    const contract = new ethers.Contract(\n      address,\n      new ethers.utils.Interface(JSON.stringify(abiToUse)),\n      this.signer\n    )\n    return setContractDefaults(contract, this.config)\n  }\n}\n","import { Signer, Contract } from 'ethers'\nimport { AbiItem } from '../@types'\nimport { Config } from '../config'\nimport { SmartContract } from './SmartContract'\nexport abstract class SmartContractWithAddress extends SmartContract {\n  public address: string\n  public contract: Contract\n\n  /**\n   * Instantiate the smart contract.\n   * @param {string} address The address of the contract.\n   * @param {Signer} signer The signer object.\n   * @param {string | number} network Network id or name\n   * @param {Config} config The configuration object.\n   * @param {AbiItem[]} abi ABI array of the smart contract\n   */\n  constructor(\n    address: string,\n    signer: Signer,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem[]\n  ) {\n    super(signer, network, config, abi)\n    this.address = address\n    this.contract = this.getContract(this.address)\n  }\n}\n","import Decimal from 'decimal.js'\nimport DispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport { sendTx } from '../utils'\nimport { Datatoken } from './Datatoken'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\nimport { DispenserToken, ReceiptOrEstimate, AbiItem } from '../@types'\n\nexport class Dispenser extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return DispenserAbi.abi as AbiItem[]\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<DispenserToken>}\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    const status2: DispenserToken = await this.contract.status(dtAdress)\n    if (!status2) {\n      throw new Error(`Np dispenser found for the given datatoken address`)\n    }\n    const status = {\n      active: status2[0],\n      owner: status2[1],\n      isMinter: status2[2],\n      maxTokens: await this.unitsToAmount(null, status2[3], 18),\n      maxBalance: await this.unitsToAmount(null, status2[4], 18),\n      balance: await this.unitsToAmount(null, status2[5], 18),\n      allowedSwapper: status2[6]\n    }\n    return status\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async create<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.create(\n      dtAddress,\n      this.amountToUnits(null, maxTokens, 18),\n      this.amountToUnits(null, maxBalance, 18),\n      address,\n      allowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Call createFixedRate contract method\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.create,\n      dtAddress,\n      this.amountToUnits(null, maxTokens, 18),\n      this.amountToUnits(null, maxBalance, 18),\n      address,\n      allowedSwapper\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Activates a dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async activate<G extends boolean = false>(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.activate(\n      dtAddress,\n      this.amountToUnits(null, maxTokens, 18),\n      this.amountToUnits(null, maxBalance, 18)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.activate,\n      dtAddress,\n      this.amountToUnits(null, maxTokens, 18),\n      this.amountToUnits(null, maxBalance, 18)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async deactivate<G extends boolean = false>(\n    dtAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.deactivate(dtAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.deactivate,\n      dtAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sets a new allowed swapper.\n   * @param {String} dtAddress Datatoken address.\n   * @param {String} newAllowedSwapper The address of the new allowed swapper.\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setAllowedSwapper<G extends boolean = false>(\n    dtAddress: string,\n    newAllowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.setAllowedSwapper(\n      dtAddress,\n      newAllowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough datatokens (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress Datatoken address.\n   * @param {String} amount Amount of datatokens required.\n   * @param {String} destination address of tokens receiver\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async dispense<G extends boolean = false>(\n    dtAddress: string,\n    amount: string = '1',\n    destination: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.dispense(\n      dtAddress,\n      this.amountToUnits(null, amount, 18),\n      destination\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.dispense,\n      dtAddress,\n      this.amountToUnits(null, amount, 18),\n      destination\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress Datatoken address.\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async ownerWithdraw<G extends boolean = false>(\n    dtAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.ownerWithdraw(dtAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.ownerWithdraw,\n      dtAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import FixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { sendTx, ZERO_ADDRESS } from '../utils'\nimport {\n  PriceAndFees,\n  FeesInfo,\n  FixedPriceExchange,\n  ReceiptOrEstimate,\n  AbiItem\n} from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\nexport class FixedRateExchange extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return FixedRateExchangeAbi.abi as AbiItem[]\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.contract.generateExchangeId(baseToken, datatoken)\n    return exchangeId\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async buyDatatokens<G extends boolean = false>(\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0',\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = await this.amountToUnits(null, consumeMarketFee, 18)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const maxBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      maxBaseTokenAmount,\n      +exchange.btDecimals\n    )\n\n    const estGas = await this.contract.estimateGas.buyDT(\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sell datatokenAmount while expecting at least minBaseTokenAmount\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async sellDatatokens<G extends boolean = false>(\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0',\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = await this.amountToUnits(null, consumeMarketFee, 18)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const minBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      minBaseTokenAmount,\n      +exchange.btDecimals\n    )\n    const estGas = await this.contract.estimateGas.sellDT(\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.contract.getNumberOfExchanges()\n    return numExchanges\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId Exchange ID\n   * @param {String} newRate New rate\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setRate<G extends boolean = false>(\n    exchangeId: string,\n    newRate: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.setRate(\n      exchangeId,\n      await this.amountToUnits(null, newRate, 18)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.setRate,\n      exchangeId,\n      await this.amountToUnits(null, newRate, 18)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sets a new allowedSwapper\n   * @param {String} exchangeId Exchange ID\n   * @param {String} newAllowedSwapper  The address of the new allowed swapper (set address zero if we want to remove allowed swapper)\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setAllowedSwapper<G extends boolean = false>(\n    exchangeId: string,\n    newAllowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.setAllowedSwapper(\n      exchangeId,\n      newAllowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async activate<G extends boolean = false>(\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n    const estGas = await this.contract.estimateGas.toggleExchangeState(exchangeId)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.toggleExchangeState,\n      exchangeId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async deactivate<G extends boolean = false>(\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await this.contract.estimateGas.toggleExchangeState(exchangeId)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.toggleExchangeState,\n      exchangeId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get Exchange Rate\n   * @param {String} exchangeId Exchange ID\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.contract.getRate(exchangeId)\n    return await this.unitsToAmount(null, weiRate, 18)\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId Exchange Id\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDatatokenSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.contract.getDTSupply(exchangeId)\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.datatoken, dtSupply, +exchange.dtDecimals)\n  }\n\n  /**\n   * Returns basetoken supply in the exchange\n   * @param {String} exchangeId Exchange Id\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBasetokenSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.contract.getBTSupply(exchangeId)\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.baseToken, btSupply, +exchange.btDecimals)\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId Exchange Id\n   * @return {Promise<string>} address of allowed swapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.contract.getAllowedSwapper(exchangeId)\n  }\n\n  /**\n   * calcBaseInGivenDatatokensOut - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId Exchange Id\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenDatatokensOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const outDT = await this.contract.calcBaseInGivenOutDT(\n      exchangeId,\n      await this.amountToUnits(\n        fixedRateExchange.datatoken,\n        datatokenAmount,\n        +fixedRateExchange.dtDecimals\n      ),\n      await this.amountToUnits(null, consumeMarketFee, 18)\n    )\n    const priceAndFees = {\n      baseTokenAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.baseTokenAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      marketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.publishMarketFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      oceanFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.oceanFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      consumeMarketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.consumeMarketFeeAmount,\n        +fixedRateExchange.btDecimals\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * Returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId Exchange Id\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBasetokensOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const amount = await this.contract.calcBaseOutGivenInDT(\n      exchangeId,\n      await this.amountToUnits(exchange.datatoken, datatokenAmount, +exchange.dtDecimals),\n      await this.amountToUnits(null, consumeMarketFee, 18)\n    )\n\n    return await this.unitsToAmount(exchange.baseToken, amount[0], +exchange.btDecimals)\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId Exchange Id\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const result: FixedPriceExchange = await this.contract.getExchange(exchangeId)\n    const exchange: FixedPriceExchange = {\n      active: result.active,\n      datatoken: result.datatoken,\n      baseToken: result.baseToken,\n      withMint: result.withMint,\n      exchangeOwner: result.exchangeOwner,\n      allowedSwapper: result.allowedSwapper,\n      dtDecimals: result.dtDecimals.toString(),\n      btDecimals: result.btDecimals.toString(),\n      dtBalance: await this.unitsToAmount(\n        result.datatoken,\n        result.dtBalance,\n        +result.dtDecimals\n      ),\n      btBalance: await this.unitsToAmount(\n        result.baseToken,\n        result.btBalance,\n        +result.btDecimals\n      ),\n      dtSupply: await this.unitsToAmount(\n        result.datatoken,\n        result.dtSupply,\n        +result.dtDecimals\n      ),\n      btSupply: await this.unitsToAmount(\n        result.baseToken,\n        result.btSupply,\n        +result.btDecimals\n      ),\n      fixedRate: await this.unitsToAmount(null, result.fixedRate, 18),\n      exchangeId\n    }\n    return exchange\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId Exchange Id\n   * @return {Promise<FeesInfo>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const result: FeesInfo = await this.contract.getFeesInfo(exchangeId)\n    const exchange = await this.getExchange(exchangeId)\n    const feesInfo: FeesInfo = {\n      opcFee: await this.unitsToAmount(null, result.opcFee.toString(), 18),\n      marketFee: await this.unitsToAmount(null, result.marketFee.toString(), 18),\n      marketFeeCollector: result.marketFeeCollector,\n      marketFeeAvailable: await this.unitsToAmount(\n        exchange.baseToken,\n        result.marketFeeAvailable,\n        +exchange.btDecimals\n      ),\n      oceanFeeAvailable: await this.unitsToAmount(\n        exchange.baseToken,\n        result.oceanFeeAvailable,\n        +exchange.btDecimals\n      ),\n\n      exchangeId\n    }\n    return feesInfo\n  }\n\n  /**\n   * Returns all exchanges\n   * @param {String} exchangeId Exchang eId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.contract.getExchanges()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>}\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const active = await this.contract.isActive(exchangeId)\n    return active\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId Exchang eId\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async activateMint<G extends boolean = false>(\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await this.contract.estimateGas.toggleMintState(exchangeId, true)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.toggleMintState,\n      exchangeId,\n      true\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async deactivateMint<G extends boolean = false>(\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await this.contract.estimateGas.toggleMintState(exchangeId, false)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.toggleMintState,\n      exchangeId,\n      false\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to Datatoken.paymentCollector)\n   * @param {String} exchangeId Exchange Id\n   * @param {String} amount amount to be collected\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectBasetokens<G extends boolean = false>(\n    exchangeId: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.contract.getExchange(exchangeId)\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n\n    const estGas = await this.contract.estimateGas.collectBT(exchangeId, amountWei)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.collectBT,\n      exchangeId,\n      amountWei\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to Datatoken.paymentCollector)\n   * @param {String} exchangeId Exchange Id\n   * @param {String} amount amount to be collected\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectDatatokens<G extends boolean = false>(\n    exchangeId: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.contract.getExchange(exchangeId)\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n\n    const estGas = await this.contract.estimateGas.collectDT(exchangeId, amountWei)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.collectDT,\n      exchangeId,\n      amountWei\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId Exchange Id\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectMarketFee<G extends boolean = false>(\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.contract.estimateGas.collectMarketFee(exchangeId)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.collectMarketFee,\n      exchangeId\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId Exchange Id\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectOceanFee<G extends boolean = false>(\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await this.contract.estimateGas.collectOceanFee(exchangeId)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.collectOceanFee,\n      exchangeId\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    const address = await this.contract.opcCollector()\n    return address\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  public async getRouter(): Promise<string> {\n    const address = await this.contract.router()\n    return address\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId Exchange Id\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    const address = await (await this.getExchange(exchangeId)).exchangeOwner\n    return address\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} exchangeId Exchange Id\n   * @param {String} newMarketFee New market fee\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async updateMarketFee<G extends boolean = false>(\n    exchangeId: string,\n    newMarketFee: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.updateMarketFee(\n      exchangeId,\n      await this.amountToUnits(null, newMarketFee, 18)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.updateMarketFee,\n      exchangeId,\n      await this.amountToUnits(null, newMarketFee, 18)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} exchangeId Exchange Id\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async updateMarketFeeCollector<G extends boolean = false>(\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.updateMarketFeeCollector(\n      exchangeId,\n      newMarketFeeCollector\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import FactoryRouter from '@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json'\nimport { sendTx } from '../utils'\nimport { Operation, ReceiptOrEstimate, AbiItem } from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\n/**\n * Provides an interface for FactoryRouter contract\n */\nexport class Router extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return FactoryRouter.abi as AbiItem[]\n  }\n\n  /**\n   * * Buys a batch of datatokens.\n   * one single call to buy multiple DT for multiple assets.\n   * require tokenIn approvals for router from user. (except for dispenser operations)\n   * @param {Operation[]} operations - The operations to execute.\n   * @param {boolean} [estimateGas=false] - Whether to return only the estimate gas or not.\n   * @return {Promise<ReceiptOrEstimate>} Transaction receipt\n   */\n  public async buyDatatokenBatch<G extends boolean = false>(\n    operations: Operation[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.buyDTBatch(operations)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.buyDTBatch,\n      operations\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Checks if a token is on approved tokens list,\n   * if true opfFee is lower in pools with that token/DT\n   * @param {string} address - The address of the token to check.\n   * @return {Promise<boolean>} true if is on the list.\n   */\n  public async isApprovedToken(address: string): Promise<boolean> {\n    return await this.contract.isApprovedToken(address)\n  }\n\n  /**\n   * Check if an address is a Fixed Rate contract.\n   * @param {string} address - The address of the fixed rate exchange to check.\n   * @return {Promise<boolean>} true if is a Fixed Rate contract\n   */\n  public async isFixedPrice(address: string): Promise<boolean> {\n    return await this.contract.isFixedRateContract(address)\n  }\n\n  /**\n   * Get Router Owner\n   * @return {Promise<string>} Router Owner address\n   */\n  public async getOwner(): Promise<string> {\n    return await this.contract.routerOwner()\n  }\n\n  /**\n   * Get NFT Factory address\n   * @return {Promise<string>} NFT Factory address\n   */\n  public async getNFTFactory(): Promise<string> {\n    return await this.contract.factory()\n  }\n\n  /**\n   * Adds a token to the list of tokens with reduced fees\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to add\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addApprovedToken<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.contract.estimateGas.addApprovedToken(tokenAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.addApprovedToken,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes a token if exists from the list of tokens with reduced fees\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to remove\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeApprovedToken<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.contract.estimateGas.removeApprovedToken(tokenAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.removeApprovedToken,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Adds an address to the list of fixed rate contracts\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to add\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addFixedRateContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.contract.estimateGas.addFixedRateContract(tokenAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.addFixedRateContract,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes an address from the list of fixed rate contracts\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to add\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeFixedRateContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.contract.estimateGas.removeFixedRateContract(tokenAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.removeFixedRateContract,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Adds an address to the list of dispensers\n   * @param {String} address caller address\n   * @param {String} tokenAddress contract address to add\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addDispenserContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.contract.estimateGas.addDispenserContract(tokenAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.addDispenserContract,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes an address from the list of dispensers\n   * @param {String} address caller address\n   * @param {String} tokenAddress address Contract to be removed\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeDispenserContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.contract.estimateGas.removeDispenserContract(tokenAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.removeDispenserContract,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get OPF Fee per token\n   * @return {Promise<number>} OPC fee for a specific baseToken\n   */\n  public async getOPCFee(baseToken: string): Promise<number> {\n    return await this.contract.getOPCFee(baseToken)\n  }\n\n  /** Get Current OPF Fee\n   * @return {Promise<number>} OPF fee\n   */\n  public async getCurrentOPCFee(): Promise<number> {\n    return await this.contract.swapOceanFee()\n  }\n\n  /**\n   * Updates OP Community Fees\n   * @param {String} address caller address\n   * @param {number} newSwapOceanFee Amount charged for swapping with ocean approved tokens\n   * @param {number} newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\n   * @param {number} newConsumeFee Amount charged from consumeFees\n   * @param {number} newProviderFee Amount charged for providerFees\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async updateOPCFee<G extends boolean = false>(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await this.contract.estimateGas.updateOPCFee(\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { BigNumber, ethers } from 'ethers'\nimport ERC721Template from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport { generateDtName, sendTx, getEventFromTx } from '../utils'\nimport {\n  MetadataProof,\n  MetadataAndTokenURI,\n  NftRoles,\n  ReceiptOrEstimate,\n  AbiItem\n} from '../@types'\nimport { SmartContract } from './SmartContract'\n\nexport class Nft extends SmartContract {\n  getDefaultAbi() {\n    return ERC721Template.abi as AbiItem[]\n  }\n\n  /**\n   * Create new ERC20 Datatoken - only user with DatatokenDeployer permission can succeed\n   * @param {String} nftAddress NFT address\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the Datatoken\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<string>} ERC20 Datatoken address\n   */\n  public async createDatatoken<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    estimateGas?: G\n  ): Promise<G extends false ? string : BigNumber> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = this.getContract(nftAddress)\n\n    const estGas = await nftContract.estimateGas.createERC20(\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [\n        await this.amountToUnits(null, cap, 18),\n        await this.amountToUnits(null, feeAmount, 18)\n      ],\n      []\n    )\n    if (estimateGas) return <G extends false ? string : BigNumber>estGas\n\n    const tx = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [\n        await this.amountToUnits(null, cap, 18),\n        await this.amountToUnits(null, feeAmount, 18)\n      ],\n      []\n    )\n    const trxReceipt = await tx.wait()\n    // console.log('trxReceipt =', trxReceipt)\n    const event = getEventFromTx(trxReceipt, 'TokenCreated')\n    return event?.args[0]\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addManager<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await nftContract.estimateGas.addManager(manager)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.addManager,\n      manager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeManager<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await nftContract.estimateGas.removeManager(manager)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.removeManager,\n      manager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add DatatokenDeployer permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} datatokenDeployer User adress which is going to have DatatokenDeployer permission\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addDatatokenDeployer<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    datatokenDeployer: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await nftContract.estimateGas.addToCreateERC20List(datatokenDeployer)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.addToCreateERC20List,\n      datatokenDeployer\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove DatatokenDeployer permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} datatokenDeployer Address of the user to be revoked DatatokenDeployer Permission\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeDatatokenDeployer<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    datatokenDeployer: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === datatokenDeployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor DatatokenDeployer`)\n    }\n    const estGas = await nftContract.estimateGas.removeFromCreateERC20List(\n      datatokenDeployer\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.removeFromCreateERC20List,\n      datatokenDeployer\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addMetadataUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await nftContract.estimateGas.addToMetadataList(metadataUpdater)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.addToMetadataList,\n      metadataUpdater\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeMetadataUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await nftContract.estimateGas.removeFromMetadataList(metadataUpdater)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.removeFromMetadataList,\n      metadataUpdater\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addStoreUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await nftContract.estimateGas.addTo725StoreList(storeUpdater)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.addTo725StoreList,\n      storeUpdater\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeStoreUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await nftContract.estimateGas.removeFrom725StoreList(storeUpdater)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.removeFrom725StoreList,\n      storeUpdater\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * This function allows to remove all ROLES at NFT level: Managers, DatatokenDeployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at Datatoken level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async cleanPermissions<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await nftContract.estimateGas.cleanPermissions()\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.cleanPermissions\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on NFT and Datatoken level.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async transferNft<G extends boolean = false>(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await nftContract.estimateGas.transferFrom(\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on NFT and Datatoken level.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async safeTransferNft<G extends boolean = false>(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await nftContract.estimateGas.safeTransferFrom(\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates or update Metadata cached by Aquarius. Also, updates the METADATA_DECRYPTOR key\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address NFT Owner adress\n   * @param {Number} metadataState\n   * @param {String} metadataDecryptorUrl\n   * @param {String} metadataDecryptorAddress\n   * @param {String} flags\n   * @param {String} data\n   * @param {String} metadataHash\n   * @param {MetadataProof[]} metadataProofs\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadata<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await nftContract.estimateGas.setMetaData(\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadataAndTokenURI<G extends boolean = false>(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const estGas = await nftContract.estimateGas.setMetaDataAndTokenURI(\n      sanitizedMetadataAndTokenURI\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadataState<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await nftContract.estimateGas.setMetaDataState(metadataState)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.setMetaDataState,\n      metadataState\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * set TokenURI on an nft\n   * @param {String} nftAddress NFT contract address\n   * @param {String} data input data for TokenURI\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setTokenURI<G extends boolean = false>(\n    nftAddress: string,\n    data: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    const estGas = await nftContract.estimateGas.setTokenURI('1', data)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.setTokenURI,\n      '1',\n      data\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get NFT Owner\n   * @param {String} nftAddress NFT contract address\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const trxReceipt = await nftContract.ownerOf(1)\n    return trxReceipt\n  }\n\n  /**\n   * Gets NFT Permissions for a specified user\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address user adress\n   * @return {Promise<NftRoles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<NftRoles> {\n    const nftContract = this.getContract(nftAddress)\n    const roles = await nftContract.getPermissions(address)\n    return roles\n  }\n\n  /**\n   * Returns Metadata details for an NFT\n   * @param {String} nftAddress NFT contract address\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = this.getContract(nftAddress)\n    return await nftContract.getMetaData()\n  }\n\n  /**\n   * Checks if user has DatatokenDeployer role\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address user adress\n   * @return {Promise<boolean>}\n   */\n  public async isDatatokenDeployer(\n    nftAddress: string,\n    address: string\n  ): Promise<boolean> {\n    const nftContract = this.getContract(nftAddress)\n    const isDatatokenDeployer = await nftContract.isERC20Deployer(address)\n    return isDatatokenDeployer\n  }\n\n  /**\n   * Allows users to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param {string} nftAddress Nft datatoken adress\n   * @param {string} address User adress\n   * @param {string} key Key of the data to be stored into 725Y standard\n   * @param {string} value Data to be stored into 725Y standard\n   * @param {boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async setData<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    key: string,\n    value: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getNftPermissions(nftAddress, address)).store !== true) {\n      throw new Error(`User is not ERC20 store updater`)\n    }\n\n    const nftContract = this.getContract(nftAddress)\n\n    const keyHash = ethers.utils.keccak256(key)\n    const valueHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(value))\n\n    const estGas = await nftContract.estimateGas.setNewData(keyHash, valueHex)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      nftContract.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Gets stored data at a given `key` in an NFT\n   * @param {string} nftAddress - The address of the NFT.\n   * @param {string} key - The key of the data to get.\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const keyHash = ethers.utils.keccak256(key)\n    const data = await nftContract.getData(keyHash)\n    return data ? ethers.utils.toUtf8String(data) : null\n  }\n\n  /**\n   * Gets the token URI of an NFT.\n   * @param {string} nftAddress - The address of the NFT.\n   * @param {number} id - The ID of the token.\n   * @returns {Promise&lt;string&gt;}\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const data = await nftContract.tokenURI(id)\n    return data\n  }\n}\n","import { ethers, Signer } from 'ethers'\nimport Decimal from 'decimal.js'\nimport ERC20Template from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport ERC20TemplateEnterprise from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport { amountToUnits, sendTx, ZERO_ADDRESS } from '../utils'\nimport {\n  AbiItem,\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees,\n  PublishingMarketFee,\n  DispenserParams,\n  OrderParams,\n  DatatokenRoles,\n  ReceiptOrEstimate\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../config'\nimport { SmartContract } from './SmartContract'\n\nexport class Datatoken extends SmartContract {\n  public abiEnterprise: AbiItem[]\n  public nft: Nft\n\n  getDefaultAbi() {\n    return ERC20Template.abi as AbiItem[]\n  }\n\n  /**\n   * Instantiate Datatoken class\n   * @param {Signer} signer The signer object.\n   * @param {string | number} [network] Network id or name\n   * @param {Config} [config] The configuration object.\n   * @param {AbiItem[]} [abi] ABI array of the smart contract\n   * @param {AbiItem[]} abiEnterprise Enterprise ABI array of the smart contract\n   */\n  constructor(\n    signer: Signer,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem[],\n    abiEnterprise?: AbiItem[]\n  ) {\n    super(signer, network, config, abi)\n    this.abiEnterprise = abiEnterprise || (ERC20TemplateEnterprise.abi as AbiItem[])\n    this.nft = new Nft(this.signer)\n  }\n\n  /**\n   * Approves a spender to spend a certain amount of datatokens.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async approve<G extends boolean = false>(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await dtContract.estimateGas.approve(\n      spender,\n      amountToUnits(null, null, amount, 18)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.approve,\n      spender,\n      amountToUnits(null, null, amount, 18)\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {FixedRateParams} fixedRateParams The parameters required to create a fixed-rate exchange contract.\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async createFixedRate<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n\n    const withMint = fixedRateParams.withMint === false ? 0 : 1\n\n    // should check DatatokenDeployer role using NFT level ..\n\n    const estGas = await dtContract.estimateGas.createFixedRate(\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress Dispenser contract address\n   * @param {DispenserParams} dispenserParams The parameters required to create a dispenser contract.\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async createDispenser<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n\n    const dtContract = this.getContract(dtAddress)\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    dispenserParams.withMint = dispenserParams.withMint !== false\n\n    // should check DatatokenDeployer role using NFT level ..\n\n    const estGas = await dtContract.estimateGas.createDispenser(\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Mints datatokens\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async mint<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.getPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await dtContract.estimateGas.mint(\n        toAddress || address,\n        amountToUnits(null, null, amount, 18)\n      )\n      if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n      const trxReceipt = await sendTx(\n        estGas,\n        this.signer,\n        this.config?.gasFeeMultiplier,\n        dtContract.mint,\n        toAddress || address,\n        amountToUnits(null, null, amount, 18)\n      )\n      return <ReceiptOrEstimate<G>>trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Add Minter for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address caller address\n   * @param {String} minter address which is going to be a Minter\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async addMinter<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await dtContract.estimateGas.addMinter(minter)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.addMinter,\n      minter\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address caller address\n   * @param {String} minter address which will have removed the Minter permission\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeMinter<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await dtContract.estimateGas.removeMinter(minter)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.removeMinter,\n      minter\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   *  Adds a payment manager on a datatoken to a desired address.(can set who's going to collect fee when consuming orders)\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} paymentManager  The address of the payment manager\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async addPaymentManager<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await dtContract.estimateGas.addPaymentManager(paymentManager)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.addPaymentManager,\n      paymentManager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removePaymentManager<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await dtContract.estimateGas.removePaymentManager(paymentManager)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.removePaymentManager,\n      paymentManager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress Datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setPaymentCollector<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    const isPaymentManager = (await this.getPermissions(dtAddress, address))\n      .paymentManager\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isDatatokenDeployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isDatatokenDeployer) {\n      throw new Error(`Caller is not Fee Manager, owner or Datatoken Deployer`)\n    }\n\n    const estGas = await dtContract.estimateGas.setPaymentCollector(paymentCollector)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.setPaymentCollector,\n      paymentCollector\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const paymentCollector = await dtContract.getPaymentCollector()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer tokens(as number) from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei.\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async transfer<G extends boolean = false>(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    return this.transferWei(\n      dtAddress,\n      toAddress,\n      await amountToUnits(null, null, amount, 18),\n      estimateGas\n    )\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens (number) expressed as wei\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async transferWei<G extends boolean = false>(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await dtContract.estimateGas.transfer(toAddress, amount)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.transfer,\n      toAddress,\n      amount\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} string\n   */\n  public async startOrder<G extends boolean = false>(\n    dtAddress: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: ZERO_ADDRESS,\n        consumeMarketFeeToken: ZERO_ADDRESS,\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const estGas = await dtContract.estimateGas.startOrder(\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reuse Order: called by payer or consumer having a valid order, but with expired provider access.\n   * Pays the provider fee again, but it will not require a new datatoken payment\n   * Requires previous approval of provider fee.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} string\n   */\n  public async reuseOrder<G extends boolean = false>(\n    dtAddress: string,\n    orderTxId: string,\n    providerFees: ProviderFees,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await dtContract.estimateGas.reuseOrder(orderTxId, providerFees)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.reuseOrder,\n      orderTxId,\n      providerFees\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {OrderParams} orderParams  The parameters required to place an order.\n   * @param {FreParams} freParams The parameters required to buy from a fixed-rate exchange.\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async buyFromFreAndOrder<G extends boolean = false>(\n    dtAddress: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress, this.abiEnterprise)\n\n    const freContractParams = await this.getFreOrderParams(freParams)\n\n    const estGas = await dtContract.estimateGas.buyFromFreAndOrder(\n      orderParams,\n      freContractParams\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.buyFromFreAndOrder,\n      orderParams,\n      freContractParams\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Gets 1 DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {OrderParams} orderParams - The parameters required to place an order.\n   * @param {String} dispenserContract  dispenser address\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async buyFromDispenserAndOrder<G extends boolean = false>(\n    dtAddress: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress, this.abiEnterprise)\n\n    const estGas = await dtContract.estimateGas.buyFromDispenserAndOrder(\n      orderParams,\n      dispenserContract\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(dtAddress)) into NFT 725 Store\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async setData<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    value: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n\n    const dtContract = this.getContract(dtAddress)\n\n    const valueHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(value))\n\n    const estGas = await dtContract.estimateGas.setData(valueHex)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.setData,\n      valueHex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Clean Datatoken level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 Datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param {string} dtAddress Datatoken address where we want to clean permissions\n   * @param {string} address User adress\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async cleanPermissions<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await dtContract.estimateGas.cleanPermissions()\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.cleanPermissions\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Returns ERC20 Datatoken user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<DatatokenRoles>}\n   */\n  public async getPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<DatatokenRoles> {\n    const dtContract = this.getContract(dtAddress)\n    const roles = await dtContract.permissions(address)\n    return roles\n  }\n\n  /**\n   * Returns the Datatoken cap\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const cap = await dtContract.cap()\n    return await this.unitsToAmount(null, cap, 18)\n  }\n\n  /**\n   * It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<number> {\n    const dtContract = this.getContract(dtAddress)\n    const decimals = await dtContract.decimals()\n    return decimals\n  }\n\n  /**\n   * It returns the token symbol\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getSymbol(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const symbol = await dtContract.symbol()\n    return symbol\n  }\n\n  /**\n   *  It returns the name of the token\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getName(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const name = await dtContract.name()\n    return name\n  }\n\n  /**\n   * It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const nftAddress = await dtContract.getERC721Address()\n    return nftAddress\n  }\n\n  /**\n   *  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isDatatokenDeployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = this.getContract(dtAddress)\n    const isDatatokenDeployer = await dtContract.isERC20Deployer(address)\n    return isDatatokenDeployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = this.getContract(datatokenAddress)\n    const balance = await dtContract.balanceOf(address)\n    return await this.unitsToAmount(null, balance, 18)\n  }\n\n  /**\n   * Allows to set the fee required by the publisherMarket\n   * only publishMarketFeeAddress can call it\n   * @param {string} datatokenAddress Datatoken adress\n   * @param {string} publishMarketFeeAddress  new publish Market Fee Address\n   * @param {string} publishMarketFeeToken new publish Market Fee Token\n   * @param {string} publishMarketFeeAmount new fee amount\n   * @param {String} address user adress\n   * @param {Boolean} estimateGas if True, return gas estimate\n   */\n  public async setPublishingMarketFee<G extends boolean = false>(\n    datatokenAddress: string,\n    publishMarketFeeAddress: string,\n    publishMarketFeeToken: string,\n    publishMarketFeeAmount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(datatokenAddress)\n    const mktFeeAddress = (await dtContract.getPublishingMarketFee())[0]\n    if (mktFeeAddress !== address) {\n      throw new Error(`Caller is not the Publishing Market Fee Address`)\n    }\n    const estGas = await dtContract.estimateGas.setPublishingMarketFee(\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      dtContract.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Returns the current fee set by the publishing market\n   * @param {String} datatokenAddress Datatoken adress\n   * @return {Promise<PublishingMarketFee>} Current fee set by the publishing market\n   */\n  public async getPublishingMarketFee(\n    datatokenAddress: string\n  ): Promise<PublishingMarketFee> {\n    const dtContract = this.getContract(datatokenAddress)\n\n    const publishingMarketFee = await dtContract.getPublishingMarketFee()\n    const returnValues = {\n      publishMarketFeeAddress: publishingMarketFee[0],\n      publishMarketFeeToken: publishingMarketFee[1],\n      publishMarketFeeAmount: publishingMarketFee[2].toString()\n    }\n    return returnValues\n  }\n\n  private async getFreOrderParams(freParams: FreOrderParams): Promise<any> {\n    return {\n      exchangeContract: freParams.exchangeContract,\n      exchangeId: freParams.exchangeId,\n      maxBaseTokenAmount: await amountToUnits(\n        this.signer,\n        freParams.baseTokenAddress,\n        freParams.maxBaseTokenAmount,\n        freParams.baseTokenDecimals\n      ),\n      swapMarketFee: await amountToUnits(\n        this.signer,\n        freParams.baseTokenAddress,\n        freParams.swapMarketFee,\n        freParams.baseTokenDecimals\n      ),\n\n      marketFeeAddress: freParams.marketFeeAddress\n    }\n  }\n}\n","import { BigNumber } from 'ethers'\nimport ERC721Factory from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport {\n  generateDtName,\n  ZERO_ADDRESS,\n  sendTx,\n  getEventFromTx,\n  getTokenDecimals,\n  LoggerInstance\n} from '../utils'\nimport {\n  AbiItem,\n  FreCreationParams,\n  DatatokenCreateParams,\n  DispenserCreationParams,\n  NftCreateData,\n  Template,\n  TokenOrder,\n  ReceiptOrEstimate\n} from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return ERC721Factory.abi as AbiItem[]\n  }\n\n  /**\n   * Create new data NFT\n   * @param {NFTCreateData} nftData The data needed to create an NFT.\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<string|BigNumber>} The transaction hash or the gas estimate.\n   */\n  public async createNFT<G extends boolean = false>(\n    nftData: NftCreateData,\n    estimateGas?: G\n  ): Promise<G extends false ? string : BigNumber> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await this.contract.estimateGas.deployERC721Contract(\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n    if (estimateGas) return <G extends false ? string : BigNumber>estGas\n    // Invoke createToken function of the contract\n    const tx = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n    const trxReceipt = await tx.wait()\n    const events = getEventFromTx(trxReceipt, 'NFTCreated')\n    return events.args[0]\n  }\n\n  /**\n   * Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const nftCount = await this.contract.getCurrentNFTCount()\n    return nftCount\n  }\n\n  /**\n   * Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const tokenCount = await this.contract.getCurrentTokenCount()\n    return tokenCount\n  }\n\n  /**\n   *  Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const owner = await this.contract.owner()\n    return owner\n  }\n\n  /**\n   * Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.contract.getCurrentNFTTemplateCount()\n    return count\n  }\n\n  /**\n   * Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of Datatoken Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.contract.getCurrentTemplateCount()\n    return count\n  }\n\n  /**\n   * Get NFT Template\n   * @param {number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.contract.getNFTTemplate(index)\n    return template\n  }\n\n  /**\n   * Get Datatoken (ERC20) Template\n   * @param {number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.contract.getTokenTemplate(index)\n    return template\n  }\n\n  /**\n   * Check if Datatoken is deployed from the factory\n   * @param {String} datatoken Datatoken address to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.contract.erc20List(datatoken)\n    return isDeployed\n  }\n\n  /**\n   * Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.contract.erc721List(nftAddress)\n    return confirmAddress\n  }\n\n  /**\n   * Add a new NFT token template - only factory Owner\n   * @param {String} address caller address\n   * @param {String} templateAddress template address to add\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await this.contract.estimateGas.add721TokenTemplate(templateAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.add721TokenTemplate,\n      templateAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async disableNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await this.contract.estimateGas.disable721TokenTemplate(templateIndex)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.disable721TokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async reactivateNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await this.contract.estimateGas.reactivate721TokenTemplate(\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.reactivate721TokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add a new NFT token template - only factory Owner\n   * @param {String} address caller address\n   * @param {String} templateAddress template address to add\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await this.contract.estimateGas.addTokenTemplate(templateAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.addTokenTemplate,\n      templateAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address caller address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async disableTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await this.contract.estimateGas.disableTokenTemplate(templateIndex)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.disableTokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address caller address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async reactivateTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await this.contract.estimateGas.reactivateTokenTemplate(templateIndex)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.reactivateTokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ Datatoken contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - ERC20 Datatokens\n   * @param {TokenOrder[]} orders array of of orders\n   * @param {Boolean} [estimateGas] if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async startMultipleTokenOrder<G extends boolean = false>(\n    orders: TokenOrder[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await this.contract.estimateGas.startMultipleTokenOrder(orders)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.startMultipleTokenOrder,\n      orders\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   *  Creates a new NFT, then a datatoken,all in one call\n   * @param {NftCreateData} nftCreateData - The data required to create an NFT.\n   * @param {DatatokenCreateParams} dtParams - The parameters required to create a datatoken.\n   * @param {boolean} [estimateGas] - Whether to return only estimate gas or not.\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n\n  public async createNftWithDatatoken<G extends boolean = false>(\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = await this.getErcCreationParams(dtParams)\n    const estGas = await this.contract.estimateGas.createNftWithErc20(\n      nftCreateData,\n      ercCreateData\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates an NFT with a datatoken with a fixed rate  all in one call.\n   * be aware if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param {NftCreateData} nftCreateData - The data required to create an NFT.\n   * @param {DatatokenCreateParams} dtParams - The parameters required to create a datatoken.\n   * @param {FreCreationParams} freParams - The parameters required to create a fixed-rate exchange contract.\n   * @param {boolean} [estimateGas] - Whether to return only estimate gas or not.\n   * @returns {Promis<ReceiptOrEstimate<G>>}\n   */\n  public async createNftWithDatatokenWithFixedRate<G extends boolean = false>(\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    freParams: FreCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = await this.getErcCreationParams(dtParams)\n    const fixedData = await this.getFreCreationParams(freParams)\n\n    const estGas = await this.contract.estimateGas.createNftWithErc20WithFixedRate(\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates an NFT with a datatoken with a dispenser in one call.\n   * Be aware if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param {NftCreateData} nftCreateData - The data required to create an NFT.\n   * @param {DatatokenCreateParams} dtParams - The parameters required to create a datatoken.\n   * @param {DispenserCreationParams} dispenserParams - The parameters required to create a dispenser contract.\n   * @param {boolean} [estimateGas] - Whether to estimate gas or not.\n   * @returns {Promis<ReceiptOrEstimate<G>>}\n   */\n  public async createNftWithDatatokenWithDispenser<G extends boolean = false>(\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    dispenserParams: DispenserCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = await this.getErcCreationParams(dtParams)\n\n    dispenserParams.maxBalance = await this.amountToUnits(\n      null,\n      dispenserParams.maxBalance,\n      18\n    )\n\n    dispenserParams.maxTokens = await this.amountToUnits(\n      null,\n      dispenserParams.maxTokens,\n      18\n    )\n\n    const estGas = await this.contract.estimateGas.createNftWithErc20WithDispenser(\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Gets the parameters required to create an ERC20 token.\n   * @param {DatatokenCreateParams} dtParams - The parameters required to create a datatoken.\n   * @returns {Promise<any>}\n   */\n  private async getErcCreationParams(dtParams: DatatokenCreateParams): Promise<any> {\n    let name: string, symbol: string\n    // Generate name & symbol if not present\n    if (!dtParams.name || !dtParams.symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    let feeTokenDecimals = 18\n    if (dtParams.feeToken !== ZERO_ADDRESS) {\n      try {\n        feeTokenDecimals = await getTokenDecimals(this.signer, dtParams.feeToken)\n      } catch (error) {\n        LoggerInstance.error('getTokenDecimals error', error)\n      }\n    }\n\n    return {\n      templateIndex: dtParams.templateIndex,\n      strings: [dtParams.name || name, dtParams.symbol || symbol],\n      addresses: [\n        dtParams.minter,\n        dtParams.paymentCollector,\n        dtParams.mpFeeAddress,\n        dtParams.feeToken\n      ],\n      uints: [\n        await this.amountToUnits(null, dtParams.cap, 18),\n        await this.amountToUnits(null, dtParams.feeAmount, feeTokenDecimals)\n      ],\n      bytess: []\n    }\n  }\n\n  /**\n   * Gets the parameters required to create a fixed-rate exchange contract.\n   * @param {FreCreationParams} freParams - The parameters required to create a fixed-rate exchange contract.\n   * @returns {Promise<any> }\n   */\n  private async getFreCreationParams(freParams: FreCreationParams): Promise<any> {\n    if (!freParams.allowedConsumer) freParams.allowedConsumer = ZERO_ADDRESS\n    const withMint = freParams.withMint === false ? 0 : 1\n\n    return {\n      fixedPriceAddress: freParams.fixedRateAddress,\n      addresses: [\n        freParams.baseTokenAddress,\n        freParams.owner,\n        freParams.marketFeeCollector,\n        freParams.allowedConsumer\n      ],\n      uints: [\n        freParams.baseTokenDecimals,\n        freParams.datatokenDecimals,\n        await this.amountToUnits(null, freParams.fixedRate, 18),\n        await this.amountToUnits(null, freParams.marketFee, 18),\n        withMint\n      ]\n    }\n  }\n}\n","import veOceanABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veOCEAN.vy/veOCEAN.json'\nimport { sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate, AbiItem } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeOcean extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return veOceanABI.abi as AbiItem[]\n  }\n\n  /**\n   * Deposit `amount` tokens for `userAddress` and lock until `unlockTime`\n   * @param {String} amount Amount of tokens to be locked\n   * @param {Number} unlockTime Timestamp for unlock\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async lockTokens<G extends boolean = false>(\n    amount: string,\n    unlockTime: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await this.contract.estimateGas.create_lock(\n      amountFormatted,\n      unlockTime\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.create_lock,\n      amountFormatted,\n      unlockTime\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deposit `amount` tokens for `toAddress` and add to the existing lock\n   * Anyone (even a smart contract) can deposit for someone else, but cannot extend their locktime and deposit for a brand new user\n   * @param {String} toAddress user address to deposit for\n   * @param {String} amount Amount of tokens to be locked\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async depositFor<G extends boolean = false>(\n    toAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await this.contract.estimateGas.deposit_for(toAddress, amountFormatted)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.deposit_for,\n      toAddress,\n      amountFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deposit `amount` additional tokens for `userAddress` without modifying the unlock time\n   * @param {String} amount Amount of tokens to be locked\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async increaseAmount<G extends boolean = false>(\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await this.contract.estimateGas.increase_amount(amountFormatted)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.increase_amount,\n      amountFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Extend the unlock time for `userAddress` to `unlockTime`\n   * @param {Number} unlockTime Timestamp for new unlock time\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async increaseUnlockTime<G extends boolean = false>(\n    unlockTime: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.increase_unlock_time(unlockTime)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.increase_unlock_time,\n      unlockTime\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Withdraw all tokens for `userAddress`\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async withdraw<G extends boolean = false>(\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.withdraw()\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.withdraw\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get voting power for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async getVotingPower(userAddress: string): Promise<number> {\n    const balance = await this.contract.balanceOf(userAddress)\n    return balance\n  }\n\n  /** Get locked balance\n   * @param {String} userAddress user address\n   * @return {Promise<string>}\n   */\n  public async getLockedAmount(userAddress: string): Promise<string> {\n    const balance = await this.contract.locked(userAddress)\n    const balanceFormated = await this.unitsToAmount(\n      await this.getToken(),\n      balance.amount.toString()\n    )\n\n    return balanceFormated\n  }\n\n  /** Get untilLock for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async lockEnd(userAddress: string): Promise<number> {\n    const untilLock = await this.contract.locked__end(userAddress)\n    return parseInt(untilLock.toString())\n  }\n\n  /** Get total supply\n   * @return {Promise<number>}\n   */\n  public async totalSupply(): Promise<string> {\n    const supplyFormated = await this.unitsToAmount(\n      await this.getToken(),\n      await this.contract.totalSupply()\n    )\n    return supplyFormated\n  }\n\n  /** Get token\n   * @return {Promise<string>}\n   */\n  public async getToken(): Promise<string> {\n    const tokenAddress = await this.contract.token()\n    return tokenAddress\n  }\n}\n","import veFeeABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veFeeDistributor.vy/veFeeDistributor.json'\nimport { sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate, AbiItem } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeFeeDistributor extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return veFeeABI.abi as AbiItem[]\n  }\n\n  /**\n   * Claim fees for `userAddress`\n   * Each call to claim look at a maximum of 50 user veOCEAN points.\n         For accounts with many veOCEAN related actions, this function\n         may need to be called more than once to claim all available\n         fees. In the `Claimed` event that fires, if `claim_epoch` is\n         less than `max_epoch`, the account may claim again\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claim<G extends boolean = false>(\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.claim()\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.claim\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Make multiple fee claims in a single call\n    Used to claim for many accounts at once, or to make\n         multiple claims for the same address when that address\n         has significant veOCEAN history\n   * @param {String} addresses array of addresses to claim\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimMany<G extends boolean = false>(\n    addresses: string[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.claim_many(addresses)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.claim_many,\n      addresses\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import veFeeEstimate from '@oceanprotocol/contracts/artifacts/contracts/ve/veFeeEstimate.vy/veFeeEstimate.json'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { VeOcean } from './VeOcean'\nimport { AbiItem } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeFeeEstimate extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return veFeeEstimate.abi as AbiItem[]\n  }\n\n  /**\n   * estimateClaim\n   * @param {String} userAddress user address\n   * @return {Promise<string>}\n   */\n  public async estimateClaim(userAddress: string): Promise<string> {\n    const amount = await this.contract.estimateClaim(userAddress)\n    const veOcean = new VeOcean(await this.contract.voting_escrow(), this.signer)\n    const amountFormated = await this.unitsToAmount(await veOcean.getToken(), amount)\n    return amountFormated\n  }\n}\n","import veAllocateABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veAllocate.sol/veAllocate.json'\nimport { sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate, AbiItem } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeAllocate extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return veAllocateABI.abi as AbiItem[]\n  }\n\n  /**\n   * set a specific percentage of veOcean to a specific nft\n   * Maximum allocated percentage is 10000, so 1% is specified as 100\n   * @param {String} amount Percentage used\n   * @param {String} nft NFT address to allocate to\n   * @param {String} chainId chainId of NFT\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setAllocation<G extends boolean = false>(\n    amount: string,\n    nft: string,\n    chainId: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.setAllocation(amount, nft, chainId)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.setAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * set specific percetage of veOcean to multiple nfts\n   * Maximum allocated percentage is 10000, so 1% is specified as 100\n   * @param {String[]} amount Array of percentages used\n   * @param {String[]} nft Array of NFT addresses\n   * @param {String[]} chainId Array of chainIds\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setBatchAllocation<G extends boolean = false>(\n    amount: string[],\n    nft: string[],\n    chainId: number[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.setBatchAllocation(\n      amount,\n      nft,\n      chainId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas.add(20000),\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.setBatchAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get totalAllocation for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async getTotalAllocation(userAddress: string): Promise<number> {\n    const allocation = await this.contract.getTotalAllocation(userAddress)\n    return allocation\n  }\n\n  /** Get getveAllocation for address, nft, chainId\n   * @param {String} userAddress user address\n   * @param {String} nft NFT address to allocate to\n   * @param {String} chainId chainId of NFT\n   * @return {Promise<number>}\n   */\n  public async getVeAllocation(\n    userAddress: string,\n    nft: string,\n    chainId: string\n  ): Promise<number> {\n    const allocation = await this.contract.getveAllocation(userAddress, nft, chainId)\n    return allocation\n  }\n}\n","import dfRewardsABI from '@oceanprotocol/contracts/artifacts/contracts/df/DFRewards.sol/DFRewards.json'\nimport { sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { AbiItem, ReceiptOrEstimate } from '../../@types'\n\n/**\n * Provides an interface for DFRewards contract\n */\nexport class DfRewards extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return dfRewardsABI.abi as AbiItem[]\n  }\n\n  /** Get available DF Rewards for a token\n   * @param {String} userAddress user address\n   * @param {String} tokenAddress token address\n   * @return {Promise<string>}\n   */\n  public async getAvailableRewards(\n    userAddress: string,\n    tokenAddress: string\n  ): Promise<string> {\n    const rewards = await this.contract.claimable(userAddress, tokenAddress)\n    const rewardsFormated = await this.unitsToAmount(tokenAddress, rewards)\n\n    return rewardsFormated\n  }\n\n  /**\n   * claim rewards for any address\n   * @param {String} userAddress user address to claim\n   * @param {String} tokenAddress token address\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimRewards<G extends boolean = false>(\n    userAddress: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.claimFor(userAddress, tokenAddress)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.claimFor,\n      userAddress,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * allocate rewards to address.  An approve must exist before calling this function.\n   * @param {String[]} userAddresses array of users that will receive rewards\n   * @param {String[]} amounts array of amounts\n   * @param {String} tokenAddress token address\n   * @param {Boolean} estimateGas if True, return gas estimate\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async allocateRewards<G extends boolean = false>(\n    userAddresses: string[],\n    amounts: string[],\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    for (let i = 0; i < amounts.length; i++) {\n      amounts[i] = await this.amountToUnits(tokenAddress, amounts[i])\n    }\n    const estGas = await this.contract.estimateGas.allocate(\n      userAddresses,\n      amounts,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.allocate,\n      userAddresses,\n      amounts,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import dfStrategyV1ABI from '@oceanprotocol/contracts/artifacts/contracts/df/DFStrategyV1.sol/DFStrategyV1.json'\nimport { sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate, AbiItem } from '../../@types'\n/**\n * Provides an interface for dfStrategyV1 contract\n */\nexport class DfStrategyV1 extends SmartContractWithAddress {\n  getDefaultAbi() {\n    return dfStrategyV1ABI.abi as AbiItem[]\n  }\n\n  /** Get available DF Rewards for multiple tokens\n   * @param {String} userAddress user address\n   * @param {String} tokenAddresses array of tokens\n   * @return {Promise<string[]>}\n   */\n  public async getMultipleAvailableRewards(\n    userAddress: string,\n    tokenAddresses: string[]\n  ): Promise<string[]> {\n    const rewards = await this.contract.claimables(userAddress, tokenAddresses)\n    const rewardsFormated: string[] = []\n    for (let i = 0; i < rewards.length; i++) {\n      rewardsFormated.push(await this.unitsToAmount(tokenAddresses[i], rewards[i]))\n    }\n    return rewardsFormated\n  }\n\n  /**\n   * claim multiple token rewards for any address\n   * @param {String} userAddress user address to claim\n   * @param {String} tokenAddresses array of tokens\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimMultipleRewards<G extends boolean = false>(\n    userAddress: string,\n    tokenAddresses: string[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await this.contract.estimateGas.claimMultiple(\n      userAddress,\n      tokenAddresses\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      estGas,\n      this.signer,\n      this.config?.gasFeeMultiplier,\n      this.contract.claimMultiple,\n      userAddress,\n      tokenAddresses\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import fetch from 'cross-fetch'\nimport { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types'\n\nexport interface SearchQuery {\n  from?: number\n  size?: number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query: any\n  sort?: { [jsonPath: string]: string }\n  aggs?: any\n}\n\nexport class Aquarius {\n  public aquariusURL: string\n\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did DID of the asset.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: { 'Content-Type': 'application/octet-stream' },\n        signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param {string} did DID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async getAssetMetadata(did: string, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/metadata/' + did\n\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error(\n          'getAssetMetadata failed: ' + response.status + response.statusText\n        )\n      }\n    } catch (error) {\n      LoggerInstance.error('Error getting metadata: ', error)\n      throw new Error('Error getting metadata: ' + error)\n    }\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param  {SearchQuery} query Query to filter the DDOs.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async querySearch(query: SearchQuery, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/query'\n\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(query),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error('querySearch failed: ' + response.status + response.statusText)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error querying metadata: ', error)\n      throw new Error('Error querying metadata: ' + error)\n    }\n  }\n}\n","import fetch from 'cross-fetch'\nimport { ethers, Signer, providers } from 'ethers'\nimport { LoggerInstance } from '../utils'\nimport {\n  Arweave,\n  FileInfo,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize,\n  ProviderComputeInitializeResults,\n  ServiceEndpoint,\n  UrlFile,\n  UserCustomParameters,\n  Ipfs,\n  Smartcontract,\n  GraphqlQuery\n} from '../@types'\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @param {string} providerUri - the provider url\n   * @return {Promise<any>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await this.getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /**\n   * This function returns the endpoint URL for a given service name.\n   * @param {ServiceEndpoint[]} servicesEndpoints - The array of service endpoints\n   * @param {string} serviceName - The name of the service\n   * @returns {ServiceEndpoint} The endpoint URL for the given service name\n   */\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * This function returns an array of service endpoints for a given provider endpoint.\n   * @param {string} providerEndpoint - The provider endpoint\n   * @param {any} endpoints - The endpoints object\n   * @returns {ServiceEndpoint[]} An array of service endpoints\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /**\n   * Get current nonce from the provider.\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /**\n   * Sign a provider request with a signer.\n   * @param {Signer} signer - The signer to use.\n   * @param {string} message - The message to sign.\n   * @returns {Promise<string>} A promise that resolves with the signature.\n   */\n  public async signProviderRequest(signer: Signer, message: string): Promise<string> {\n    //  const isMetaMask = web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n    //  if (isMetaMask) return await web3.eth.personal.sign(consumerMessage, accountId, password)\n    //  await web3.eth.sign(consumerMessage, await signer.getAddress())\n    const consumerMessage = ethers.utils.solidityKeccak256(\n      ['bytes'],\n      [ethers.utils.hexlify(ethers.utils.toUtf8Bytes(message))]\n    )\n    const messageHashBytes = ethers.utils.arrayify(consumerMessage)\n    const chainId = await signer.getChainId()\n    if (chainId === 8996) {\n      return await (signer as providers.JsonRpcSigner)._legacySignMessage(\n        messageHashBytes\n      )\n    }\n    return await signer.signMessage(messageHashBytes)\n  }\n\n  /**\n   * Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {number} chainId network's id so provider can choose the corresponding Signer object\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    chainId: number,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path =\n      (this.getEndpointURL(serviceEndpoints, 'encrypt')\n        ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n        : null) + `?chainId=${chainId}`\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: { 'Content-Type': 'application/octet-stream' },\n        signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /**\n   * Get file details for a given DID and service ID.\n   * @param {string} did - The DID to check.\n   * @param {string} serviceId - The service ID to check.\n   * @param {string} providerUri - The URI of the provider.\n   * @param {boolean} [withChecksum=false] - Whether or not to include a checksum.\n   * @param {AbortSignal} [signal] - An optional abort signal.\n   * @returns {Promise<FileInfo[]>} A promise that resolves with an array of file info objects.\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: string,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did, serviceId, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    let response\n    try {\n      response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('File info call failed: ')\n      LoggerInstance.error(e)\n      throw new Error(e)\n    }\n    if (response?.ok) {\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    }\n    const resolvedResponse = await response.json()\n    LoggerInstance.error(\n      'File info call failed: ',\n      response.status,\n      response.statusText,\n      resolvedResponse\n    )\n    throw new Error(JSON.stringify(resolvedResponse))\n  }\n\n  /**\n   * Get File details (if possible)\n   * @param {UrlFile | Arweave | Ipfs | GraphqlQuery | Smartcontract} file one of the supported file structures\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {boolean} [withChecksum=false] - Whether or not to include a checksum.\n   * @param {AbortSignal} [signal] - An optional abort signal.\n   * @param {any} headers headers key value pairs associated with the asset GET request\n   * @returns {Promise<FileInfo[]>} A promise that resolves with an array of file info objects.\n   */\n  public async getFileInfo(\n    file: UrlFile | Arweave | Ipfs | GraphqlQuery | Smartcontract,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal,\n    headers?: any\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { ...file, headers, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    let response\n    try {\n      response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('File info call failed: ')\n      LoggerInstance.error(e)\n      throw new Error(e)\n    }\n    if (response?.ok) {\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    }\n    const resolvedResponse = await response.json()\n    LoggerInstance.error(\n      'File info call failed: ',\n      response.status,\n      response.statusText,\n      resolvedResponse\n    )\n    throw new Error(JSON.stringify(resolvedResponse))\n  }\n\n  /**\n   * Returns compute environments from a provider.\n   * @param {string} providerUri - The URI of the provider.\n   * @param {AbortSignal} [signal] - An optional abort signal.\n   * @returns {Promise<{[chainId: number]: ComputeEnvironment[]}>} A promise that resolves with an object containing compute environments for each chain ID.\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<{ [chainId: number]: ComputeEnvironment[] }> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    let response\n    try {\n      response = await fetch(path, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('Fetch compute env failed: ')\n      LoggerInstance.error(e)\n      throw new Error(e)\n    }\n    if (response?.ok) {\n      const result = response.json()\n      if (Array.isArray(result)) {\n        const providerChain: number = providerEndpoints.chainId\n        return { [providerChain]: result }\n      }\n      return result\n    }\n    const resolvedResponse = await response.json()\n    LoggerInstance.error(\n      'Fetch compute env failed: ',\n      response.status,\n      response.statusText,\n      resolvedResponse\n    )\n    throw new Error(JSON.stringify(resolvedResponse))\n  }\n\n  /**\n   * Initializes the provider for a service request.\n   * @param {string} did - The asset DID .\n   * @param {string} serviceId - The asset service ID.\n   * @param {number} fileIndex - The file index.\n   * @param {string} consumerAddress - The consumer address.\n   * @param {string} providerUri - The URI of the provider.\n   * @param {AbortSignal} [signal] - The abort signal if any.\n   * @param {UserCustomParameters} [userCustomParameters] - The custom parameters if any.\n   * @param {string} [computeEnv] - The compute environment if any.\n   * @param {number} [validUntil] - The validity time if any.\n   * @returns {Promise<ProviderInitialize>} A promise that resolves with ProviderInitialize response.\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    let response\n    try {\n      response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('Provider initialized failed: ')\n      LoggerInstance.error(e)\n      throw new Error(`Provider initialize failed url: ${initializeUrl} `)\n    }\n    if (response?.ok) {\n      const results: ProviderInitialize = await response.json()\n      return results\n    }\n    const resolvedResponse = await response.json()\n    LoggerInstance.error(\n      'Provider initialized failed: ',\n      response.status,\n      response.statusText,\n      resolvedResponse\n    )\n    throw new Error(JSON.stringify(resolvedResponse))\n  }\n\n  /** Initializes the provider for a compute request.\n   * @param {ComputeAsset[]} assets The datasets array to initialize compute request.\n   * @param {ComputeAlgorithmber} algorithm The algorithm to use.\n   * @param {string} computeEnv The compute environment.\n   * @param {number} validUntil  The job expiration date.\n   * @param {string} providerUri The provider URI.\n   * @param {string} accountId caller address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderComputeInitialize>} ProviderComputeInitialize data\n   */\n  public async initializeCompute(\n    assets: ComputeAsset[],\n    algorithm: ComputeAlgorithm,\n    computeEnv: string,\n    validUntil: number,\n    providerUri: string,\n    accountId: string,\n    signal?: AbortSignal\n  ): Promise<ProviderComputeInitializeResults> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const providerData = {\n      datasets: assets,\n      algorithm,\n      compute: { env: computeEnv, validUntil },\n      consumerAddress: accountId\n    }\n    const initializeUrl = this.getEndpointURL(serviceEndpoints, 'initializeCompute')\n      ? this.getEndpointURL(serviceEndpoints, 'initializeCompute').urlPath\n      : null\n    if (!initializeUrl) return null\n    let response\n    try {\n      response = await fetch(initializeUrl, {\n        method: 'POST',\n        body: JSON.stringify(providerData),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('Initialize compute failed: ')\n      LoggerInstance.error(e)\n      throw new Error('ComputeJob cannot be initialized')\n    }\n    if (response?.ok) {\n      const params = await response.json()\n      return params\n    }\n    const resolvedResponse = await response.json()\n    LoggerInstance.error(\n      'Initialize compute failed: ',\n      response.status,\n      response.statusText,\n      resolvedResponse\n    )\n    LoggerInstance.error('Payload was:', providerData)\n    throw new Error(JSON.stringify(resolvedResponse))\n  }\n\n  /**\n   * Gets the download URL.\n   * @param {string} did - The DID.\n   * @param {string} serviceId - The service ID.\n   * @param {number} fileIndex - The file index.\n   * @param {string} transferTxId - The transfer transaction ID.\n   * @param {string} providerUri - The provider URI.\n   * @param {Signer} signer - The signer.\n   * @param {UserCustomParameters} userCustomParameters - The user custom parameters.\n   * @returns {Promise<any>} The download URL.\n   */\n  public async getDownloadUrl(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    signer: Signer,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.signProviderRequest(signer, did + nonce)\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${await signer.getAddress()}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} providerUri The provider URI.\n   * @param {Signer} signer The consumer signer object.\n   * @param {string} computeEnv The compute environment.\n   * @param {ComputeAsset} dataset The dataset to start compute on\n   * @param {ComputeAlgorithm} algorithm The algorithm to start compute with.\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeAsset[]} additionalDatasets The additional datasets if that is the case.\n   * @param {ComputeOutput} output The compute job output settings.\n   * @return {Promise<ComputeJob | ComputeJob[]>} The compute job or jobs.\n   */\n  public async computeStart(\n    providerUri: string,\n    consumer: Signer,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = await consumer.getAddress()\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(consumer, signatureMessage)\n    const payload = Object()\n    payload.consumerAddress = await consumer.getAddress()\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    let response\n    try {\n      response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n    if (response?.ok) {\n      const params = await response.json()\n      return params\n    }\n    LoggerInstance.error(\n      'Compute start failed: ',\n      response.status,\n      response.statusText,\n      await response.json()\n    )\n    LoggerInstance.error('Payload was:', payload)\n    return null\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did the asset did\n   * @param {string} consumerAddress The consumer address.\n   * @param {string} jobId the compute job id\n   * @param {string} providerUri The provider URI.\n   * @param {Signer} signer The consumer signer object.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    signer: Signer,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${this.noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(signer, signatureMessage)\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = this.noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    let response\n    try {\n      response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n\n    if (response?.ok) {\n      const params = await response.json()\n      return params\n    }\n    const resolvedResponse = await response.json()\n    LoggerInstance.error(\n      'Compute stop failed: ',\n      response.status,\n      response.statusText,\n      resolvedResponse\n    )\n    LoggerInstance.error('Payload was:', payload)\n    throw new Error(JSON.stringify(resolvedResponse))\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${this.noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    let response\n    try {\n      response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      throw new Error(e)\n    }\n    if (response?.ok) {\n      const params = await response.json()\n      return params\n    }\n    LoggerInstance.error(\n      'Get compute status failed:',\n      response.status,\n      response.statusText\n    )\n    if (response?.ok) {\n      const params = await response.json()\n      return params\n    }\n    const resolvedResponse = await response.json()\n    LoggerInstance.error(\n      'Get compute status failed:',\n      response.status,\n      response.statusText,\n      resolvedResponse\n    )\n    throw new Error(JSON.stringify(resolvedResponse))\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Signer} consumer consumer Signer wallet object\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @return {Promise<string>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    consumer: Signer,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = await consumer.getAddress()\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(consumer, signatureMessage)\n    if (!computeResultUrl) return null\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${await consumer.getAddress()}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did asset did\n   * @param {Signer} consumer consumer Signer wallet object\n   * @param {string} jobId the compute job ID\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumer: Signer,\n    jobId: string,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      await consumer.getAddress(),\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = await consumer.getAddress()\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${this.noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(consumer, signatureMessage)\n    const payload = Object()\n    payload.documentId = this.noZeroX(did)\n    payload.consumerAddress = await consumer.getAddress()\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    let response\n    try {\n      response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n    if (response?.ok) {\n      const params = await response.json()\n      return params\n    }\n    const resolvedResponse = await response.json()\n    LoggerInstance.error(\n      'Delete compute job failed:',\n      response.status,\n      response.statusText,\n      resolvedResponse\n    )\n    LoggerInstance.error('Payload was:', payload)\n    throw new Error(JSON.stringify(resolvedResponse))\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} valid or not\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && (params.providerAddress || params.providerAddresses)) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n\n  /**\n   * Private method that removes the leading 0x from a string.\n   * @param {string} input - The input string.\n   * @returns The transformed string.\n   */\n  private noZeroX(input: string): string {\n    return this.zeroXTransformer(input, false)\n  }\n\n  /**\n   * Private method that removes the leading 0x from a string.\n   * @param {string} input - The input string.\n   * @param {boolean} zeroOutput - Whether to include 0x in the output if the input is valid and zeroOutput is true.\n   * @returns The transformed string.\n   */\n  private zeroXTransformer(input = '', zeroOutput: boolean): string {\n    const { valid, output } = this.inputMatch(\n      input,\n      /^(?:0x)*([a-f0-9]+)$/i,\n      'zeroXTransformer'\n    )\n    return (zeroOutput && valid ? '0x' : '') + output\n  }\n\n  /**\n   * Private method that matches an input string against a regular expression and returns the first capture group.\n   * @param {string} input - The input string to match.\n   * @param {RegExp} regexp - The regular expression to match against.\n   * @param {string} conversorName - The name of the method calling this function.\n   * @returns An object with two properties: `valid` (a boolean indicating whether the input matched the regular expression) and `output` (the first capture group of the match, or the original input if there was no match).\n   */\n  private inputMatch(\n    input: string,\n    regexp: RegExp,\n    conversorName: string\n  ): { valid: boolean; output: string } {\n    if (typeof input !== 'string') {\n      LoggerInstance.debug('Not input string:')\n      LoggerInstance.debug(input)\n      throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n    }\n    const match = input.match(regexp)\n    if (!match) {\n      LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n      return { valid: false, output: input }\n    }\n    return { valid: true, output: match[1] }\n  }\n\n  /**\n   * Private method that fetches data from a URL using the GET method.\n   * @param {string} url - The URL to fetch data from.\n   * @returns A Promise that resolves to a Response object.\n   */\n  private async getData(url: string): Promise<Response> {\n    return fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-type': 'application/json'\n      }\n    })\n  }\n}\n\nexport const ProviderInstance = new Provider()\n"],"names":["Config","nodeUri","providerAddress","metadataCacheUri","providerUri","web3Provider","oceanTokenAddress","nftFactoryAddress","datatokensABI","fixedRateExchangeAddress","fixedRateExchangeAddressABI","dispenserAddress","dispenserABI","opfCommunityFeeCollector","sideStakingAddress","startBlock","verbose","authMessage","authTokenExpiration","parityUri","threshold","chainId","network","subgraphUri","explorerUri","oceanTokenSymbol","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","gasFeeMultiplier","veAllocate","veOCEAN","veDelegation","veFeeDistributor","veDelegationProxy","DFRewards","DFStrategyV1","veFeeEstimate","ZERO_ADDRESS","GASLIMIT_DEFAULT","MAX_UINT_256","FEE_HISTORY_NOT_SUPPORTED","setContractDefaults","contract","config","getFairGasPrice","signer","price","provider","getFeeData","gasPrice","x","ethers","BigNumber","from","toString","mul","toBigInt","getTokenDecimals","token","Contract","minAbi","decimals","unitsToAmount","amount","tokenDecimals","utils","formatUnits","amountToUnits","parseUnits","getEventFromTx","txReceipt","eventName","events","_txReceipt$events","filter","log","event","sendTx","estGas","functionToSend","args","getNetwork","feeHistory","overrides","maxPriorityFeePerGas","aggressiveFeePriorityFeePerGas","aggressiveFeePerGas","maxFeePerGas","Math","round","toNumber","Number","gasLimit","add","e","LogLevel","generateDtName","wordList","list","wordListDefault","random1","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","generateDid","nftAddress","getAddress","sha256","getHash","data","downloadFileBrowser","url","contentHeader","fetch","method","headers","get","fileName","split","xhr","XMLHttpRequest","responseType","open","onload","blobURL","window","URL","createObjectURL","response","a","document","createElement","href","setAttribute","body","appendChild","click","remove","revokeObjectURL","send","downloadFile","index","ok","Error","filename","match","pop","arrayBuffer","sleep","ms","Promise","resolve","setTimeout","Logger","constructor","logLevel","this","setLevel","bypass","dispatch","Infinity","debug","Verbose","Log","warn","Warn","error","verb","level","console","LoggerInstance","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","signHash","message","messageHashBytes","arrayify","signedMessage","_legacySignMessage","substr","r","slice","s","v","approve","account","tokenAddress","spender","force","estimateGas","tokenContract","currentAllowence","allowance","Decimal","greaterThanOrEqualTo","amountFormatted","approveWei","allowanceWei","gt","result","transfer","recipient","trxReceipt","balance","balanceOf","PREDEFINED_ERRORS","datasets","invalid","algorithm","serviceId","missing","not_found","service_not_access_compute","main_service_compute","compute_services_not_in_same_provider","container","checksum_prefix","mising_entrypoint_image_checksum","documentId","did_not_found","transferTxId","missing_meta_documentId","not_algo","in_use_or_not_on_chain","meta_oneof_url_rawcode_remote","file_unavailable","not_trusted_algo_publisher","not_trusted_algo","no_publisherTrustedAlgorithms","algorithm_file_checksum_mismatch","algorithm_container_checksum_mismatch","no_raw_algo_allowed","order","fees_not_paid","output","getErrorMessage","key","Object","keys","errorObject","configHelperNetworksBase","configHelperNetworks","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","FixedPrice","Dispenser","ERC721Factory","OPFCommunityFeeCollector","Ocean","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","SmartContract","abi","getDefaultAbi","async","_this$config","getContract","address","Interface","JSON","stringify","SmartContractWithAddress","super","DispenserAbi","dtAdress","status2","status","active","owner","isMinter","maxTokens","maxBalance","allowedSwapper","dtAddress","create","activate","_this$config2","deactivate","_this$config3","newAllowedSwapper","setAllowedSwapper","_this$config4","destination","dispense","_this$config5","ownerWithdraw","_this$config6","datatoken","String","greaterThan","FixedRateExchange","FixedRateExchangeAbi","baseToken","generateExchangeId","exchangeId","datatokenAmount","maxBaseTokenAmount","consumeMarketAddress","consumeMarketFee","exchange","getExchange","consumeMarketFeeFormatted","dtAmountFormatted","dtDecimals","maxBtFormatted","btDecimals","buyDT","minBaseTokenAmount","minBtFormatted","sellDT","getNumberOfExchanges","newRate","setRate","toggleExchangeState","weiRate","getRate","dtSupply","getDTSupply","btSupply","getBTSupply","getAllowedSwapper","fixedRateExchange","outDT","calcBaseInGivenOutDT","baseTokenAmount","marketFeeAmount","publishMarketFeeAmount","oceanFeeAmount","consumeMarketFeeAmount","calcBaseOutGivenInDT","withMint","exchangeOwner","dtBalance","btBalance","fixedRate","getFeesInfo","opcFee","marketFee","marketFeeCollector","marketFeeAvailable","oceanFeeAvailable","getExchanges","isActive","toggleMintState","_this$config7","_this$config8","fixedrate","amountWei","collectBT","_this$config9","collectDT","_this$config10","collectMarketFee","_this$config11","collectOceanFee","_this$config12","opcCollector","router","newMarketFee","updateMarketFee","_this$config13","newMarketFeeCollector","updateMarketFeeCollector","_this$config14","Router","FactoryRouter","operations","buyDTBatch","isApprovedToken","isFixedRateContract","routerOwner","factory","getOwner","addApprovedToken","removeApprovedToken","addFixedRateContract","removeFixedRateContract","addDispenserContract","removeDispenserContract","getOPCFee","swapOceanFee","newSwapOceanFee","newSwapNonOceanFee","newConsumeFee","newProviderFee","updateOPCFee","Nft","ERC721Template","minter","paymentCollector","mpFeeAddress","feeToken","feeAmount","cap","templateIndex","getNftPermissions","deployERC20","nftContract","createERC20","tx","wait","manager","getNftOwner","addManager","removeManager","datatokenDeployer","addToCreateERC20List","removeFromCreateERC20List","metadataUpdater","addToMetadataList","updateMetadata","removeFromMetadataList","storeUpdater","addTo725StoreList","store","removeFrom725StoreList","cleanPermissions","nftOwner","nftReceiver","tokenId","tokenIdentifier","transferFrom","safeTransferFrom","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","metadataHash","metadataProofs","setMetaData","metadataAndTokenURI","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetaDataState","_this$config15","setTokenURI","_this$config16","ownerOf","getPermissions","getMetaData","isERC20Deployer","value","keyHash","keccak256","valueHex","hexlify","toUtf8Bytes","setNewData","_this$config17","getData","toUtf8String","id","tokenURI","Datatoken","ERC20Template","abiEnterprise","nft","ERC20TemplateEnterprise","dtContract","fixedRateParams","isDatatokenDeployer","allowedConsumer","createFixedRate","fixedRateAddress","baseTokenAddress","baseTokenDecimals","datatokenDecimals","dispenserParams","createDispenser","toAddress","capAvailble","getCap","gte","mint","addMinter","removeMinter","paymentManager","addPaymentManager","removePaymentManager","isPaymentManager","getNFTAddress","isNftOwner","nftPermissions","setPaymentCollector","getPaymentCollector","transferWei","consumer","serviceIndex","providerFees","consumeMarketFeeAddress","consumeMarketFeeToken","startOrder","orderTxId","reuseOrder","orderParams","freParams","freContractParams","getFreOrderParams","buyFromFreAndOrder","dispenserContract","buyFromDispenserAndOrder","setData","permissions","getERC721Address","datatokenAddress","publishMarketFeeAddress","publishMarketFeeToken","getPublishingMarketFee","setPublishingMarketFee","publishingMarketFee","exchangeContract","swapMarketFee","marketFeeAddress","NftFactory","nftData","getCurrentNFTTemplateCount","getNFTTemplate","deployERC721Contract","transferable","getCurrentNFTCount","getCurrentTokenCount","getCurrentTemplateCount","getTokenTemplate","erc20List","erc721List","templateAddress","add721TokenTemplate","disable721TokenTemplate","reactivate721TokenTemplate","addTokenTemplate","getCurrentTokenTemplateCount","disableTokenTemplate","reactivateTokenTemplate","orders","startMultipleTokenOrder","nftCreateData","dtParams","ercCreateData","getErcCreationParams","createNftWithErc20","fixedData","getFreCreationParams","createNftWithErc20WithFixedRate","createNftWithErc20WithDispenser","feeTokenDecimals","strings","addresses","uints","bytess","fixedPriceAddress","VeOcean","veOceanABI","unlockTime","getToken","create_lock","deposit_for","increase_amount","increase_unlock_time","withdraw","userAddress","locked","untilLock","locked__end","parseInt","totalSupply","VeFeeDistributor","veFeeABI","claim","claim_many","VeFeeEstimate","estimateClaim","veOcean","voting_escrow","VeAllocate","veAllocateABI","setAllocation","setBatchAllocation","getTotalAllocation","getveAllocation","DfRewards","dfRewardsABI","rewards","claimable","claimFor","userAddresses","amounts","i","allocate","DfStrategyV1","dfStrategyV1ABI","tokenAddresses","claimables","rewardsFormated","push","claimMultiple","Aquarius","aquariusURL","did","signal","path","json","txid","tries","ddo","valid","jsonResponse","hash","proof","validatorAddress","publicKey","errors","statusText","query","Provider","endpoints","getEndpointURL","servicesEndpoints","serviceName","providerEndpoint","serviceEndpoints","urlPath","consumerAddress","providerEndpoints","getEndpoints","getServiceEndpoints","nonce","consumerMessage","solidityKeccak256","getChainId","signMessage","text","withChecksum","checksum","files","_response","results","resolvedResponse","file","_response2","_this$getEndpointURL","_response3","Array","isArray","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","_response4","assets","accountId","providerData","compute","_response5","downloadUrl","Date","now","signature","signProviderRequest","consumeUrl","dataset","additionalDatasets","computeStartUrl","signatureMessage","payload","environment","_response6","jobId","computeStopUrl","getNonce","noZeroX","_response7","computeStatusUrl","_response8","_response9","computeResultUrl","resultUrl","computeDeleteUrl","_response10","params","providerAddresses","input","zeroXTransformer","zeroOutput","inputMatch","regexp","conversorName","ProviderInstance"],"mappings":"27CAGaA,qBAKJC,oBAMAC,4BAMAC,6BAMAC,wBAMAC,yBAMAC,8BAMAC,8BAMAC,0BAMAC,qCAMAC,wCAMAC,6BAMAC,yBAMAC,qCAMAC,+BAMAC,uBAKAC,oBAMAC,wBAMAC,gCAMAC,sBAEAC,sBAMPC,oBAMAC,oBAMAC,wBAMAC,wBAMAC,6BAMAC,oCAMAC,0CAMAC,sCAMAC,6BAEAC,uBACAC,oBACAC,yBACAC,6BACAC,8BACAC,sBACAC,yBACAC,sOCpLWC,MAAAA,EAAe,6CACfC,EAAmB,IACnBC,EACX,iFACWC,EACX,gECIcC,EAAoBC,EAAoBC,GAWtD,OAAOD,CACR,gBAQqBE,EACpBC,EACAjB,GAEA,MAAMkB,cAAqBD,EAAOE,SAASC,cAAcC,SACnDC,EAAIC,EAAOC,UAAUC,KAAKP,EAAMQ,YACtC,OAAI1B,EAAyBsB,EAAEK,IAAI3B,GAAkB4B,WAAWF,SAAS,IAC7DJ,EAAEI,UACf,gBAQqBG,EAAiBZ,EAAgBa,GAErD,OADsB,IAAIP,EAAOQ,SAASD,EAAOE,EAAQf,GACpCgB,UACtB,gBAUqBC,EACpBjB,EACAa,EACAK,EACAC,GAEA,IAAIH,EAAWG,SAAwBP,EAAiBZ,EAAQa,GAMhE,MALiB,MAAbG,IACFA,EAAW,IAGWV,EAAOc,MAAMC,YAAYH,EAAQF,GAClCP,UACxB,gBAUqBa,EACpBtB,EACAa,EACAK,EACAC,GAEA,IAAIH,EAAWG,SAAwBP,EAAiBZ,EAAQa,GAKhE,MAJiB,MAAbG,IACFA,EAAW,IAEWV,EAAOc,MAAMG,WAAWL,EAAQF,GACjCP,UACxB,UAEee,EAAeC,EAAWC,SACxC,aAAOD,YAAAA,EAAWE,eAAXC,EAAmBC,OAAQC,GACzBA,EAAIC,QAAUL,GACpB,EACJ,gBAWqBM,EACpBC,EACAjC,EACAjB,EACAmD,KACGC,GAEH,MAAM5D,QAAEA,SAAkByB,EAAOE,SAASkC,aACpCC,QAAmBrC,EAAOE,SAASC,aACzC,IAAImC,EACJ,GAAID,EAAWE,qBAAsB,CACnC,IAAIC,EAAiCH,EAAWE,qBAAqB9B,WACjEgC,EAAsBJ,EAAWK,aAAajC,WAC9C1B,EAAmB,IACrByD,EAAiCG,KAAKC,MACpCP,EAAWE,qBAAqBM,WAAa9D,GAC7C0B,WACFgC,EAAsBE,KAAKC,MACzBP,EAAWK,aAAaG,WAAa9D,GACrC0B,YAEJ6B,EAAY,CACVC,sBA7HoB,QA8HjBhE,GA/HkB,MA+HeA,IAClCuE,OAAON,GAjIa,UAmIhBM,OAAON,GACbE,cAlIoB,QAmIjBnE,GApIkB,MAoIeA,IAClCuE,OAAOL,GAtIa,UAwIhBK,OAAOL,GAEhB,MACCH,EAAY,CACVlC,SAAUiC,EAAWjC,UAGzBkC,EAAUS,SAAWd,EAAOe,IAAI,KAChC,IAEE,aADyBd,KAAkBC,EAAMG,EAIlD,CAFC,MAAOW,GACP,WACD,CACF,KC1JWC,2qECQIC,EAAeC,GAI7B,MAAMC,EAAOD,GAAYE,EACnBC,EAAUZ,KAAKa,MAAMb,KAAKc,SAAWJ,EAAKK,WAAWC,QACrDC,EAAUjB,KAAKa,MAAMb,KAAKc,SAAWJ,EAAKQ,MAAMF,QAChDG,EAAcnB,KAAKa,MAAsB,IAAhBb,KAAKc,UAG9BM,EAAYV,EAAKK,WAAWH,GAASS,QAAQ,MAAQC,GAAMA,EAAEC,eAC7DC,EAAOd,EAAKQ,MAAMD,GAASI,QAAQ,MAAQC,GAAMA,EAAEC,eAQzD,MAAO,CAAEE,QANOL,KAAaI,UAMdE,WAHbN,EAAUO,UAAU,EAAG,GAAKH,EAAKG,UAAU,EAAG,IAC9CJ,iBAAiBJ,IAGpB,UCpBeS,EAAYC,EAAoBjG,GAG9C,OAFAiG,EAAalE,EAAOc,MAAMqD,WAAWD,aACpBE,EAAOF,EAAajG,EAAQkC,SAAS,KAC5BA,YAC3B,UAOekE,EAAQC,GACtB,OAAOF,EAAOE,GAAMnE,UACrB,gBCdqBoE,EAAoBC,GACxC,MACMC,SADqBC,EAAMF,EAAK,CAAEG,OAAQ,UACbC,QAAQC,IAAI,uBACzCC,QAAWL,GAAAA,EAAeM,MAAM,KAAK,SAAKN,SAAAA,EAAeM,MAAM,KAAK,GAAK,OACzEC,EAAM,IAAIC,eAChBD,EAAIE,aAAe,OACnBF,EAAIG,KAAK,MAAOX,GAChBQ,EAAII,OAAS,KACX,MAAMC,EAAUC,OAAOC,IAAIC,gBAAgBR,EAAIS,UACzCC,EAAIC,SAASC,cAAc,KACjCF,EAAEG,KAAOR,EACTK,EAAEI,aAAa,WAAYhB,GAC3Ba,SAASI,KAAKC,YAAYN,GAC1BA,EAAEO,QACFP,EAAEQ,SACFZ,OAAOC,IAAIY,gBAAgBd,IAE7BL,EAAIoB,KAAK,KACV,gBAQqBC,EACpB7B,EACA8B,GAEA,MAAMb,QAAiBf,EAAMF,GAC7B,IAAKiB,EAASc,GACZ,UAAUC,MAAM,mBAElB,IAAIC,EACJ,IACEA,EAAWhB,EAASb,QACjBC,IAAI,uBACJ6B,MAAM,4BAA4B,EAOtC,CANC,SACA,IACED,EAAWjC,EAAIO,MAAM,KAAK4B,KAG3B,CAFC,SACAF,SAAkBH,GACnB,CACF,CAED,MAAO,CAAEhC,WAAYmB,EAASmB,cAAeH,WAC9C,gBCpDqBI,EAAMC,GAC1B,WAAWC,QAASC,IAClBC,WAAWD,EAASF,IAEvB,EJPD,SAAYlE,GACVA,oBACAA,qBACAA,mBACAA,iBACAA,wBALF,CAAA,CAAYA,IAAAA,aASCsE,EACXC,YAAoBC,EAAqBxE,EAAS4D,YAA9BY,gBAAAC,cAAAD,CAAuC,CAEpDE,SAASF,GACdC,KAAKD,SAAWA,CACjB,CAEMG,UAAU1F,GACfwF,KAAKG,SAAS,OAAQC,YAAoB5F,EAC3C,CAEM6F,SAAS7F,GACdwF,KAAKG,SAAS,QAAS5E,EAAS+E,WAAY9F,EAC7C,CAEML,OAAOK,GACZwF,KAAKG,SAAS,MAAO5E,EAASgF,OAAQ/F,EACvC,CAEMgG,QAAQhG,GACbwF,KAAKG,SAAS,OAAQ5E,EAASkF,QAASjG,EACzC,CAEMkG,SAASlG,GACdwF,KAAKG,SAAS,QAAS5E,EAAS4D,SAAU3E,EAC3C,CAEO2F,SAASQ,EAAcC,KAAoBpG,GAC7CwF,KAAKD,UAAYa,GACnBC,QAAQF,MAASnG,EAEpB,EAGUsG,MAAAA,EAAiB,IAAIjB,EK5CrBzG,EAAS,CACpB,CACE2H,UAAU,EACVC,OAAQ,GACRvE,KAAM,OACNwE,QAAS,CACP,CACExE,KAAM,GACNyE,KAAM,WAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEvE,KAAM,WACNyE,KAAM,WAER,CACEzE,KAAM,SACNyE,KAAM,YAGVzE,KAAM,UACNwE,QAAS,CACP,CACExE,KAAM,GACNyE,KAAM,SAGVC,SAAS,EACTC,gBAAiB,aACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,GACRvE,KAAM,cACNwE,QAAS,CACP,CACExE,KAAM,GACNyE,KAAM,YAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEvE,KAAM,QACNyE,KAAM,WAER,CACEzE,KAAM,MACNyE,KAAM,WAER,CACEzE,KAAM,SACNyE,KAAM,YAGVzE,KAAM,eACNwE,QAAS,CACP,CACExE,KAAM,GACNyE,KAAM,SAGVC,SAAS,EACTC,gBAAiB,aACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,GACRvE,KAAM,WACNwE,QAAS,CACP,CACExE,KAAM,GACNyE,KAAM,UAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEvE,KAAM,SACNyE,KAAM,YAGVzE,KAAM,YACNwE,QAAS,CACP,CACExE,KAAM,UACNyE,KAAM,YAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,GACRvE,KAAM,SACNwE,QAAS,CACP,CACExE,KAAM,GACNyE,KAAM,WAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEvE,KAAM,MACNyE,KAAM,WAER,CACEzE,KAAM,SACNyE,KAAM,YAGVzE,KAAM,WACNwE,QAAS,CACP,CACExE,KAAM,GACNyE,KAAM,SAGVC,SAAS,EACTC,gBAAiB,aACjBF,KAAM,YAER,CACEH,UAAU,EACVC,OAAQ,CACN,CACEvE,KAAM,SACNyE,KAAM,WAER,CACEzE,KAAM,WACNyE,KAAM,YAGVzE,KAAM,YACNwE,QAAS,CACP,CACExE,KAAM,GACNyE,KAAM,YAGVC,SAAS,EACTC,gBAAiB,OACjBF,KAAM,YAER,CACEC,SAAS,EACTC,gBAAiB,UACjBF,KAAM,YAER,CACEG,WAAW,EACXL,OAAQ,CACN,CACEM,SAAS,EACT7E,KAAM,QACNyE,KAAM,WAER,CACEI,SAAS,EACT7E,KAAM,UACNyE,KAAM,WAER,CACEI,SAAS,EACT7E,KAAM,QACNyE,KAAM,YAGVzE,KAAM,WACNyE,KAAM,SAER,CACEG,WAAW,EACXL,OAAQ,CACN,CACEM,SAAS,EACT7E,KAAM,OACNyE,KAAM,WAER,CACEI,SAAS,EACT7E,KAAM,KACNyE,KAAM,WAER,CACEI,SAAS,EACT7E,KAAM,QACNyE,KAAM,YAGVzE,KAAM,WACNyE,KAAM,yBCnNYK,EAASlJ,EAAgBmJ,GAI7C,MAAMC,EAAmB9I,EAAOc,MAAMiI,SAASF,GAC/C,IAAIG,QAAuBtJ,EAAmCuJ,mBAC5DH,GAEFE,EAAgBA,EAAcE,OAAO,GACrC,MAAMC,EAAI,KAAOH,EAAcI,MAAM,EAAG,IAClCC,EAAI,KAAOL,EAAcI,MAAM,GAAI,KACzC,IAAIE,EAAI,KAAON,EAAcI,MAAM,IAAK,KAIxC,MAHU,SAANE,IAAcA,EAAI,QACZ,SAANA,IAAcA,EAAI,QAEf,CAAEA,IAAGH,IAAGE,EAChB,gBCNqBE,EACpB7J,EACAF,EACAgK,EACAC,EACAC,EACA9I,EACA+I,GAAQ,EACR9I,EACA+I,GAEA,MAAMC,EAAgB,IAAI7J,EAAOQ,SAASiJ,EAAchJ,EAAQf,GAChE,IAAKiK,EAAO,CACV,MAAMG,QAAyBC,EAAUrK,EAAQ+J,EAAcD,EAASE,GACxE,GAAI,IAAIM,EAAQF,GAAkBG,qBAAqB,IAAID,EAAQpJ,IACjE,WAAgCoJ,EAAQF,GAAkBvH,UAE7D,CACD,MAAM2H,QAAwBlJ,EAActB,EAAQ+J,EAAc7I,EAAQC,GACpEc,QAAekI,EAAcD,YAAYL,QAAQG,EAASQ,GAChE,OAAIN,MAAuDI,EAAQrI,EAAOxB,kBAEjDuB,EACvBC,EACAjC,QACAF,SAAAA,EAAQf,iBACRoL,EAAcN,QACdG,EACAQ,EAGH,gBAaqBC,EACpBzK,EACAF,EACAgK,EACAC,EACAC,EACA9I,EACA+I,GAAQ,EACRC,GAEA,MAAMC,EAAgB,IAAI7J,EAAOQ,SAASiJ,EAAchJ,EAAQf,GAChE,IAAKiK,EAAO,CACV,MAAMG,QAAyBM,EAAa1K,EAAQ+J,EAAcD,EAASE,GAC3E,GAAI1J,EAAOC,UAAUC,KAAK4J,GAAkBO,GAAGrK,EAAOC,UAAUC,KAAKU,IACnE,OAA6BZ,EAAOC,UAAUC,KAAK4J,EAEtD,CACD,IAAIQ,EAAS,KAEb,MAAM3I,QAAekI,EAAcD,YAAYL,QAAQG,EAAS9I,GAChE,GAAIgJ,EAAa,OAA6BjI,EAE9C,IACE2I,QAAe5I,EACbC,EACAjC,QACAF,SAAAA,EAAQf,iBACRoL,EAAcN,QACdG,EACA9I,EAMH,CAJC,MAAO+B,GACPwF,EAAeJ,4DACyCpF,EAAEkG,UAE3D,CACD,OAAOyB,CACR,gBAWqBC,EACpB7K,EACAF,EACAiK,EACAe,EACA5J,EACAgJ,GAEA,MAAMC,EAAgB,IAAI7J,EAAOQ,SAASiJ,EAAchJ,EAAQf,GAC1DwK,QAAwBlJ,EAActB,EAAQ+J,EAAc7I,GAC5De,QAAekI,EAAcD,YAAYW,SAASC,EAAWN,GACnE,OAAIN,EAA0CjI,QAErBD,EACvBC,EACAjC,QACAF,SAAAA,EAAQf,iBACRoL,EAAcU,SACdC,EACAN,EAGH,gBAUqBH,EACpBrK,EACA+J,EACAD,EACAE,EACA7I,GAEA,MAAMgJ,EAAgB,IAAI7J,EAAOQ,SAASiJ,EAAchJ,EAAQf,GAC1D+K,QAAmBZ,EAAcE,UAAUP,EAASE,GAE1D,aAAa/I,EAAcjB,EAAQ+J,EAAcgB,EAAY5J,EAC9D,gBASqB6J,EACpBhL,EACA+J,EACAD,EACA3I,GAEA,MAAMgJ,EAAgB,IAAI7J,EAAOQ,SAASiJ,EAAchJ,EAAQf,GAC1D+K,QAAmBZ,EAAcc,UAAUnB,GAEjD,aAAa7I,EAAcjB,EAAQ+J,EAAcgB,EAAY5J,EAC9D,gBASqBuJ,EACpB1K,EACA+J,EACAD,EACAE,GAEA,MAAMG,EAAgB,IAAI7J,EAAOQ,SAASiJ,EAAchJ,EAAQf,GAChE,aAAamK,EAAcE,UAAUP,EAASE,EAC/C,gBAQqBhJ,EAAShB,EAAgB+J,GAC7C,MAAMI,EAAgB,IAAI7J,EAAOQ,SAASiJ,EAAchJ,EAAQf,GAChE,aAAamK,EAAcnJ,UAC5B,CCtMD,MAAMkK,EAAoB,CACxBC,SAAU,CACRC,QAAS,uCAEXC,UAAW,CACTC,UAAW,CACTC,QAAS,yDACTC,UAAW,yCACXC,2BAA4B,+CAC5BC,qBACE,sFACFC,sCACE,iPAEJC,UAAW,CACTC,gBAAiB,6DACjBC,iCACE,2HAEJC,WAAY,CACVC,cACE,kHACFT,QAAS,2DAEXU,aAAc,CACZV,QAAS,6DAEXW,wBAAyB,2DACzBF,cAAe,2DACfG,SAAU,2DACVC,uBAAwB,2DACxBC,8BACE,2DACFC,iBACE,qIAEJjE,MAAO,CACLkE,2BACE,gFACFC,iBACE,4EACFC,8BACE,wFACFC,iCACE,qDACFC,sCACE,6DACFC,oBAAqB,2DACrB,kBACE,2GACF,2BACE,+IACF,gCACE,8FACF,sCACE,2MACF,uCAAwC,6CACxC,qBAAsB,wDACtB,oBAAqB,gDACrB,8BACE,gEACF,yCACE,sLACF,oBAAqB,qDACrB,wBACE,2GAEJC,MAAO,CACLC,cAAe,gCAEjBC,OAAQ,CACN3B,QACE,4GAIU4B,EAAgB3E,GAC9B,MAAM4E,EAAMC,OAAOC,KAAK9E,GAAO,GAC/B,GAAY,UAAR4E,EAAiB,CACnB,MAAM9D,EAAUd,EAAM4E,GAGtB,OADE/B,EAAkB+B,GAAK9D,gCAAwCA,GAElE,CAAM,CACL,MAAMiE,EAAc/E,EAAM4E,GAG1B,SADqB5E,EADF6E,OAAOC,KAAK9E,GAAO,SAEV+E,GAC7B,CACF,ylaCpFD,MAAMC,EAAmC,CACvC9O,QAAS,KACTC,QAAS,UACTnB,iBAAkB,wCAClBF,QAAS,wBACTG,YAAa,wCACbmB,YAAa,KACbC,YAAa,KACblB,kBAAmB,KACnBmB,iBAAkB,QAClBhB,yBAA0B,KAC1BE,iBAAkB,KAClBI,WAAY,EACZW,wBAAyB,GACzBC,8BAA+B,EAC/BC,0BAA2B,IAC3BC,iBAAkB,GAGPuO,EAAiC,MAEvCD,QAIAA,GACH9O,QAAS,KACTC,QAAS,cAETnB,iBAAkB,yBAClBC,YAAa,yBACbmB,YAAa,kCAOV4O,GACH9O,QAAS,EACTC,QAAS,SACTrB,QAAS,8BACTsB,YAAa,+CACbC,YAAa,8BACbK,iBAAkB,WAGfsO,GACH9O,QAAS,SACTC,QAAS,UACTrB,QAAS,+BACTsB,YAAa,gDACbC,YAAa,+BACbK,iBAAkB,WAGfsO,GACH9O,QAAS,EACTC,QAAS,UACTrB,QAAS,+BACTsB,YAAa,gDACbC,YAAa,uBACbT,WAAY,SACZW,wBAAyB,IACzBC,8BAA+B,EAC/BC,0BAA2B,KAC3BC,iBAAkB,YAGfsO,GACH9O,QAAS,IACTC,QAAS,UACTrB,QAAS,uCACTsB,YAAa,gDACbC,YAAa,0BACbC,iBAAkB,SAClBI,iBAAkB,WAGfsO,GACH9O,QAAS,OACTC,QAAS,eACTrB,QAAS,6CACTG,YAAa,qDACbmB,YAAa,qDACbC,YAAa,2DAGV2O,GACH9O,QAAS,MACTC,QAAS,SACTrB,QAAS,sCACTsB,YAAa,+CACbC,YAAa,iCACbK,iBAAkB,WAGfsO,GACH9O,QAAS,GACTC,QAAS,MACTrB,QAAS,mCACTsB,YAAa,4CACbC,YAAa,uBACbK,iBAAkB,YAGfsO,GACH9O,QAAS,IACTC,QAAS,YACTrB,QAAS,4BACTsB,YAAa,kDACbC,YAAa,iCACbK,iBAAkB,YAGfsO,GACH9O,QAAS,KACTC,QAAS,YACTrB,QAAS,6CACTsB,YAAa,kDACbC,YAAa,iCACbK,iBAAkB,YAGfsO,GACH9O,QAAS,MACTC,QAAS,cACTrB,QAAS,yCACTG,YAAa,+CACbmB,YAAa,+CACbC,YAAa,+CACbK,iBAAkB,YAGfsO,GACH9O,QAAS,IACTC,QAAS,gBACTrB,QAAS,qCACTG,YAAa,+CACbmB,YAAa,+CACbC,YAAa,0CACbK,iBAAkB,YAGfsO,GACH9O,QAAS,MACTC,QAAS,mBACTrB,QAAS,GACTG,YAAa,+CACbmB,YAAa,+CACbC,YAAa,GACbK,iBAAkB,cAITwO,GAEJC,oBAAoBhP,EAAiBiP,GAE1C,IAAIC,EAGJ,GAAID,EAAiB,CACnB,MAAME,WACJA,EADIC,UAEJA,EAFIC,cAGJA,EAHIC,yBAIJA,EAJIC,MAKJA,EALIxP,QAMJA,EANIN,WAOJA,EAPIe,WAQJA,EARIC,QASJA,EATIC,aAUJA,EAVIC,iBAWJA,EAXIC,kBAYJA,EAZIC,UAaJA,EAbIC,aAcJA,EAdIC,cAeJA,GACEkO,EAAgBjP,GACpBkP,KACEjQ,kBAAmBoQ,EACnB9P,yBAA0B+P,EAC1BnQ,yBAA0BgQ,EAC1B9P,iBAAkB+P,EAClBpQ,kBAAmBuQ,EACnBxP,UACAN,aACAe,aACAC,UACAC,eACAC,mBACAC,oBACAC,YACAC,eACAC,iBACIyO,QAAQC,IAAIC,cAAgB,CAAE7Q,iBAAkB2Q,QAAQC,IAAIC,cAEnE,MAEC,GAAIC,EAA0B3P,GAAU,CACtC,MAAMmP,WACJA,EADIC,UAEJA,EAFIE,yBAGJA,EAHID,cAIJA,EAJIE,MAKJA,EALIxP,QAMJA,EANIN,WAOJA,EAPIe,WAQJA,EARIC,QASJA,EATIC,aAUJA,EAVIC,iBAWJA,EAXIC,kBAYJA,EAZIC,UAaJA,EAbIC,aAcJA,EAdIC,cAeJA,GACE4O,EAA0B3P,GAC9BkP,KACEjQ,kBAAmBoQ,EACnB9P,yBAA0B+P,EAC1BnQ,yBAA0BgQ,EAC1B9P,iBAAkB+P,EAClBpQ,kBAAmBuQ,EACnBxP,UACAN,aACAe,aACAC,UACAC,eACAC,mBACAC,oBACAC,YACAC,eACAC,iBACIyO,QAAQC,IAAIC,cAAgB,CAAE7Q,iBAAkB2Q,QAAQC,IAAIC,cAEnE,CAEH,OAAOR,CACR,CAQMU,UAAU5P,EAA0B6P,GACzC,MAAMC,EAA8B,iBAAZ9P,EAAuB,UAAY,UAC3D,IAAIsB,EAASwN,EAAqBiB,KAAMtK,GAAMA,EAAEqK,KAAc9P,GAG9D,OAFAgK,QAAQ1G,mCAAoCwL,GAEvCxN,GAQLA,OAAcA,EADkB6H,KAAK6F,oBAAoB1N,EAAOtB,eAOpDsB,GAAQ3C,QAJJkR,KACTvO,EAAO3C,WAAWkR,IACrBvO,EAAO3C,YAXTsL,EAAeJ,4CACyB7J,iBAAuB8P,WAalE,QCxQmBE,GAcpB/G,YACEzH,EACAxB,EACAsB,EACA2O,QAjBKzO,mBACAF,mBACA2O,WAiBL9G,KAAK3H,OAASA,EACd2H,KAAK7H,OAASA,IAAU,IAAIyN,IAAea,UAAU5P,GAAW,WAChEmJ,KAAK8G,IAAMA,GAAO9G,KAAK+G,eACxB,CAS4BC,oBAC3B9N,EACAK,EACAC,GAEA,OAAOG,EAAcqG,KAAK3H,OAAQa,EAAOK,EAAQC,EAClD,CAS4BwN,oBAC3B9N,EACAK,EACAC,GAEA,OAAOF,EAAc0G,KAAK3H,OAAQa,EAAOK,EAAQC,EAClD,CAM8BwN,8BAC7B,OAAO5O,EAAgB4H,KAAK3H,gBAAQ2H,KAAK7H,eAAL8O,EAAa7P,iBAClD,CAQS8P,YAAYC,EAAiBL,GAOrC,OAAO7O,EALU,IAAIU,EAAOQ,SAC1BgO,EACA,IAAIxO,EAAOc,MAAM2N,UAAUC,KAAKC,UAHjBR,GAAO9G,KAAK8G,MAI3B9G,KAAK3H,QAGR,QCnFmBkP,WAAiCV,GAYrD/G,YACEqH,EACA9O,EACAxB,EACAsB,EACA2O,GAEAU,MAAMnP,EAAQxB,EAASsB,EAAQ2O,QAlB1BK,oBACAjP,gBAkBL8H,KAAKmH,QAAUA,EACfnH,KAAK9H,SAAW8H,KAAKkH,YAAYlH,KAAKmH,QACvC,QCnBUlB,WAAkBsB,GAC7BR,gBACE,OAAOU,EAAaX,GACrB,CAOkBE,aAACU,GAClB,MAAMC,aAAqCzP,SAAS0P,OAAOF,GAC3D,IAAKC,EACH,UAAUxI,4DAWZ,MATe,CACb0I,OAAQF,EAAQ,GAChBG,MAAOH,EAAQ,GACfI,SAAUJ,EAAQ,GAClBK,qBAAsB1O,cAAc,KAAMqO,EAAQ,GAAI,IACtDM,sBAAuB3O,cAAc,KAAMqO,EAAQ,GAAI,IACvDtE,mBAAoB/J,cAAc,KAAMqO,EAAQ,GAAI,IACpDO,eAAgBP,EAAQ,GAG3B,CAYkBX,aACjBmB,EACAhB,EACAa,EACAC,EACAC,EACA3F,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAY6F,OAC7CD,EACAnI,KAAKrG,cAAc,KAAMqO,EAAW,IACpChI,KAAKrG,cAAc,KAAMsO,EAAY,IACrCd,EACAe,GAEF,OAAI3F,EAA0CjI,QAGrBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAASkQ,OACdD,EACAnI,KAAKrG,cAAc,KAAMqO,EAAW,IACpChI,KAAKrG,cAAc,KAAMsO,EAAY,IACrCd,EACAe,EAIH,CAUoBlB,eACnBmB,EACAH,EACAC,EACA1F,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAY8F,SAC7CF,EACAnI,KAAKrG,cAAc,KAAMqO,EAAW,IACpChI,KAAKrG,cAAc,KAAMsO,EAAY,KAEvC,OAAI1F,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb4I,KAAK9H,SAASmQ,SACdF,EACAnI,KAAKrG,cAAc,KAAMqO,EAAW,IACpChI,KAAKrG,cAAc,KAAMsO,EAAY,IAIxC,CAQsBjB,iBACrBmB,EACA5F,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYgG,WAAWJ,GAC1D,OAAI5F,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALqQ,EAAapR,iBACb4I,KAAK9H,SAASqQ,WACdJ,EAIH,CAS6BnB,wBAC5BmB,EACAM,EACAlG,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYmG,kBAC7CP,EACAM,GAEF,OAAIlG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwQ,EAAavR,iBACb4I,KAAK9H,SAASwQ,kBACdP,EACAM,EAGH,CAYoBzB,eACnBmB,EACA5O,EAAiB,IACjBqP,EACArG,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYsG,SAC7CV,EACAnI,KAAKrG,cAAc,KAAMJ,EAAQ,IACjCqP,GAEF,OAAIrG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL2Q,EAAa1R,iBACb4I,KAAK9H,SAAS2Q,SACdV,EACAnI,KAAKrG,cAAc,KAAMJ,EAAQ,IACjCqP,EAGH,CAQyB5B,oBACxBmB,EACA5F,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYwG,cAAcZ,GAC7D,OAAI5F,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL6Q,EAAa5R,iBACb4I,KAAK9H,SAAS6Q,cACdZ,EAIH,CASyBnB,oBACxBmB,EACAc,EACA9B,EACA5N,EAAiB,KAEjB,MAAMqO,aAAoBA,OAAOO,GACjC,SAAKP,IAEiB,IAAlBA,EAAOC,QAES,IAAIlF,QAAcsG,EAAU5F,QAAQ8E,EAAWhB,IACnDvE,qBAAqBgF,EAAOK,aAExC,IAAItF,EAAQuG,OAAO3P,IAAS4P,YAAYvB,EAAOI,aAE3B,IAAIrF,EAAQiF,EAAOvE,SACvBT,qBAAqBrJ,KAA+B,IAApBqO,EAAOG,SAG5D,QC/OUqB,WAA0B7B,GACrCR,gBACE,OAAOsC,EAAqBvC,GAC7B,CAQ8BE,yBAACsC,EAAmBL,GAEjD,kBAD8B/Q,SAASqR,mBAAmBD,EAAWL,EAEtE,CAYyBjC,oBACxBwC,EACAC,EACAC,EACAC,EAA+B9R,EAC/B+R,EAA2B,IAC3BrH,SAEA,MAAMsH,aAAsBC,YAAYN,GAClCO,aAAuCpQ,cAAc,KAAMiQ,EAAkB,IAC7EI,aAA+BrQ,cACnCkQ,EAASZ,UACTQ,GACCI,EAASI,YAENC,aAA4BvQ,cAChCkQ,EAASP,UACTI,GACCG,EAASM,YAGN7P,aAAoBpC,SAASqK,YAAY6H,MAC7CZ,EACAQ,EACAE,EACAP,EACAI,GAEF,OAAIxH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAASkS,MACdZ,EACAQ,EACAE,EACAP,EACAI,EAIH,CAY0B/C,qBACzBwC,EACAC,EACAY,EACAV,EAA+B9R,EAC/B+R,EAA2B,IAC3BrH,SAEA,MAAMsH,aAAsBC,YAAYN,GAClCO,aAAuCpQ,cAAc,KAAMiQ,EAAkB,IAC7EI,aAA+BrQ,cACnCkQ,EAASZ,UACTQ,GACCI,EAASI,YAENK,aAA4B3Q,cAChCkQ,EAASP,UACTe,GACCR,EAASM,YAEN7P,aAAoBpC,SAASqK,YAAYgI,OAC7Cf,EACAQ,EACAM,EACAX,EACAI,GAEF,OAAIxH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb4I,KAAK9H,SAASqS,OACdf,EACAQ,EACAM,EACAX,EACAI,EAGH,CAMgC/C,6BAE/B,kBADgC9O,SAASsS,sBAE1C,CASmBxD,cAClBwC,EACAiB,EACAlI,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYmI,QAC7ClB,aACW7P,cAAc,KAAM8Q,EAAS,KAE1C,OAAIlI,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALqQ,EAAapR,iBACb4I,KAAK9H,SAASwS,QACdlB,aACW7P,cAAc,KAAM8Q,EAAS,IAI3C,CAS6BzD,wBAC5BwC,EACAf,EACAlG,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYmG,kBAC7Cc,EACAf,GAEF,OAAIlG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwQ,EAAavR,iBACb4I,KAAK9H,SAASwQ,kBACdc,EACAf,EAGH,CAQoBzB,eACnBwC,EACAjH,SAEA,MAAMsH,aAAsBC,YAAYN,GACxC,IAAKK,EAAU,YACf,IAAwB,IAApBA,EAAShC,OAAiB,YAC9B,MAAMvN,aAAoBpC,SAASqK,YAAYoI,oBAAoBnB,GACnE,OAAIjH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL2Q,EAAa1R,iBACb4I,KAAK9H,SAASyS,oBACdnB,EAGH,CAQsBxC,iBACrBwC,EACAjH,SAEA,MAAMsH,aAAsBC,YAAYN,GACxC,IAAKK,EAAU,YACf,IAAwB,IAApBA,EAAShC,OAAkB,YAE/B,MAAMvN,aAAoBpC,SAASqK,YAAYoI,oBAAoBnB,GACnE,OAAIjH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL6Q,EAAa5R,iBACb4I,KAAK9H,SAASyS,oBACdnB,EAGH,CAOmBxC,cAACwC,GACnB,MAAMoB,aAAqB1S,SAAS2S,QAAQrB,GAC5C,kBAAkBlQ,cAAc,KAAMsR,EAAS,GAChD,CAO8B5D,yBAACwC,GAC9B,MAAMsB,aAAsB5S,SAAS6S,YAAYvB,GAC3CK,aAAsBC,YAAYN,GACxC,kBAAkBlQ,cAAcuQ,EAASZ,UAAW6B,GAAWjB,EAASI,WACzE,CAO8BjD,yBAACwC,GAC9B,MAAMwB,aAAsB9S,SAAS+S,YAAYzB,GAC3CK,aAAsBC,YAAYN,GACxC,kBAAkBlQ,cAAcuQ,EAASP,UAAW0B,GAAWnB,EAASM,WACzE,CAO6BnD,wBAACwC,GAC7B,kBAAkBtR,SAASgT,kBAAkB1B,EAC9C,CASwCxC,mCACvCwC,EACAC,EACAG,EAA2B,KAE3B,MAAMuB,aAA+BrB,YAAYN,GAC3C4B,aAAmBlT,SAASmT,qBAChC7B,aACW7P,cACTwR,EAAkBlC,UAClBQ,GACC0B,EAAkBlB,uBAEVtQ,cAAc,KAAMiQ,EAAkB,KAwBnD,MAtBqB,CACnB0B,2BAA4BhS,cAC1B6R,EAAkB7B,UAClB8B,EAAME,iBACLH,EAAkBhB,YAErBoB,2BAA4BjS,cAC1B6R,EAAkB7B,UAClB8B,EAAMI,wBACLL,EAAkBhB,YAErBsB,0BAA2BnS,cACzB6R,EAAkB7B,UAClB8B,EAAMK,gBACLN,EAAkBhB,YAErBuB,kCAAmCpS,cACjC6R,EAAkB7B,UAClB8B,EAAMM,wBACLP,EAAkBhB,YAIxB,CASkCnD,6BACjCwC,EACAC,EACAG,EAA2B,KAE3B,MAAMC,aAAsBC,YAAYN,GAClCjQ,aAAoBrB,SAASyT,qBACjCnC,aACW7P,cAAckQ,EAASZ,UAAWQ,GAAkBI,EAASI,uBAC7DtQ,cAAc,KAAMiQ,EAAkB,KAGnD,kBAAkBtQ,cAAcuQ,EAASP,UAAW/P,EAAO,IAAKsQ,EAASM,WAC1E,CAOuBnD,kBAACwC,GACvB,MAAMvG,aAAwC/K,SAAS4R,YAAYN,GAiCnE,MAhCqC,CACnC3B,OAAQ5E,EAAO4E,OACfoB,UAAWhG,EAAOgG,UAClBK,UAAWrG,EAAOqG,UAClBsC,SAAU3I,EAAO2I,SACjBC,cAAe5I,EAAO4I,cACtB3D,eAAgBjF,EAAOiF,eACvB+B,WAAYhH,EAAOgH,WAAWnR,WAC9BqR,WAAYlH,EAAOkH,WAAWrR,WAC9BgT,qBAAsBxS,cACpB2J,EAAOgG,UACPhG,EAAO6I,WACN7I,EAAOgH,YAEV8B,qBAAsBzS,cACpB2J,EAAOqG,UACPrG,EAAO8I,WACN9I,EAAOkH,YAEVW,oBAAqBxR,cACnB2J,EAAOgG,UACPhG,EAAO6H,UACN7H,EAAOgH,YAEVe,oBAAqB1R,cACnB2J,EAAOqG,UACPrG,EAAO+H,UACN/H,EAAOkH,YAEV6B,qBAAsB1S,cAAc,KAAM2J,EAAO+I,UAAW,IAC5DxC,aAGH,CAOuBxC,kBAACwC,GACvB,MAAMvG,aAA8B/K,SAAS+T,YAAYzC,GACnDK,aAAsBC,YAAYN,GAkBxC,MAjB2B,CACzB0C,kBAAmB5S,cAAc,KAAM2J,EAAOiJ,OAAOpT,WAAY,IACjEqT,qBAAsB7S,cAAc,KAAM2J,EAAOkJ,UAAUrT,WAAY,IACvEsT,mBAAoBnJ,EAAOmJ,mBAC3BC,8BAA+B/S,cAC7BuQ,EAASP,UACTrG,EAAOoJ,oBACNxC,EAASM,YAEZmC,6BAA8BhT,cAC5BuQ,EAASP,UACTrG,EAAOqJ,mBACNzC,EAASM,YAGZX,aAGH,CAOwBxC,qBACvB,kBAAkB9O,SAASqU,cAC5B,CAOoBvF,eAACwC,GAEpB,kBAD0BtR,SAASsU,SAAShD,EAE7C,CAQwBxC,mBACvBwC,EACAjH,SAEA,MAAMsH,aAAsBC,YAAYN,GACxC,IAAKK,EAAU,YACf,IAA0B,IAAtBA,EAAS+B,SAAmB,YAEhC,MAAMtR,aAAoBpC,SAASqK,YAAYkK,gBAAgBjD,GAAY,GAC3E,OAAIjH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALuU,EAAatV,iBACb4I,KAAK9H,SAASuU,gBACdjD,GACA,EAGH,CAQ0BxC,qBACzBwC,EACAjH,SAEA,MAAMsH,aAAsBC,YAAYN,GACxC,IAAKK,EAAU,YACf,IAA0B,IAAtBA,EAAS+B,SAAoB,YAEjC,MAAMtR,aAAoBpC,SAASqK,YAAYkK,gBAAgBjD,GAAY,GAC3E,OAAIjH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwU,EAAavV,iBACb4I,KAAK9H,SAASuU,gBACdjD,GACA,EAGH,CAS6BxC,wBAC5BwC,EACAjQ,EACAgJ,SAGA,eAD4BuH,YAAYN,GACzB,YAEf,MAAMoD,aAA2C1U,SAAS4R,YAAYN,GAChEqD,aAAuBlT,cAC3BiT,EAAUtD,UACV/P,GACCqT,EAAUzC,YAGP7P,aAAoBpC,SAASqK,YAAYuK,UAAUtD,EAAYqD,GACrE,OAAItK,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL4U,EAAa3V,iBACb4I,KAAK9H,SAAS4U,UACdtD,EACAqD,EAGH,CAS6B7F,wBAC5BwC,EACAjQ,EACAgJ,SAGA,eAD4BuH,YAAYN,GACzB,YAEf,MAAMoD,aAA2C1U,SAAS4R,YAAYN,GAChEqD,aAAuBlT,cAC3BiT,EAAU3D,UACV1P,GACCqT,EAAU3C,YAGP3P,aAAoBpC,SAASqK,YAAYyK,UAAUxD,EAAYqD,GACrE,OAAItK,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8U,EAAa7V,iBACb4I,KAAK9H,SAAS8U,UACdxD,EACAqD,EAGH,CAQ4B7F,uBAC3BwC,EACAjH,SAGA,eAD4BuH,YAAYN,GACzB,YAEf,MAAMlP,aAAoBpC,SAASqK,YAAY2K,iBAAiB1D,GAChE,OAAIjH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALgV,EAAa/V,iBACb4I,KAAK9H,SAASgV,iBACd1D,EAIH,CAQ2BxC,sBAC1BwC,EACAjH,SAGA,eAD4BuH,YAAYN,GACzB,YAEf,MAAMlP,aAAoBpC,SAASqK,YAAY6K,gBAAgB5D,GAC/D,OAAIjH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALkV,EAAajW,iBACb4I,KAAK9H,SAASkV,gBACd5D,EAIH,CAMoBxC,wBAEnB,kBAD2B9O,SAASoV,cAErC,CAMqBtG,kBAEpB,kBAD2B9O,SAASqV,QAErC,CAOqBvG,uBAACwC,GAErB,wBADkCM,YAAYN,IAAaqC,aAE5D,CAS2B7E,sBAC1BwC,EACAgE,EACAjL,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYkL,gBAC7CjE,aACW7P,cAAc,KAAM6T,EAAc,KAE/C,OAAIjL,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALuV,EAAatW,iBACb4I,KAAK9H,SAASuV,gBACdjE,aACW7P,cAAc,KAAM6T,EAAc,IAIhD,CASoCxG,+BACnCwC,EACAmE,EACApL,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYqL,yBAC7CpE,EACAmE,GAEF,OAAIpL,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL0V,EAAazW,iBACb4I,KAAK9H,SAAS0V,yBACdpE,EACAmE,EAIH,QC3sBUG,WAAevG,GAC1BR,gBACE,OAAOgH,EAAcjH,GACtB,CAU6BE,wBAC5BgH,EACAzL,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAY0L,WAAWD,GAC1D,OAAIzL,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAAS+V,WACdD,EAIH,CAQ2BhH,sBAACG,GAC3B,kBAAkBjP,SAASgW,gBAAgB/G,EAC5C,CAOwBH,mBAACG,GACxB,kBAAkBjP,SAASiW,oBAAoBhH,EAChD,CAMoBH,iBACnB,kBAAkB9O,SAASkW,aAC5B,CAMyBpH,sBACxB,kBAAkB9O,SAASmW,SAC5B,CAS4BrH,uBAC3BG,EACA/E,EACAG,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,oCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAYgM,iBAAiBnM,GAChE,OAAIG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb4I,KAAK9H,SAASqW,iBACdnM,EAIH,CAS+B4E,0BAC9BG,EACA/E,EACAG,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,oCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAYiM,oBAAoBpM,GACnE,OAAIG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALqQ,EAAapR,iBACb4I,KAAK9H,SAASsW,oBACdpM,EAGH,CASgC4E,2BAC/BG,EACA/E,EACAG,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,oCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAYkM,qBAAqBrM,GACpE,OAAIG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwQ,EAAavR,iBACb4I,KAAK9H,SAASuW,qBACdrM,EAIH,CASmC4E,8BAClCG,EACA/E,EACAG,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,oCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAYmM,wBAAwBtM,GACvE,OAAIG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL2Q,EAAa1R,iBACb4I,KAAK9H,SAASwW,wBACdtM,EAIH,CASgC4E,2BAC/BG,EACA/E,EACAG,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,oCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAYoM,qBAAqBvM,GACpE,OAAIG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL6Q,EAAa5R,iBACb4I,KAAK9H,SAASyW,qBACdvM,EAGH,CASmC4E,8BAClCG,EACA/E,EACAG,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,oCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAYqM,wBAAwBxM,GACvE,OAAIG,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALuU,EAAatV,iBACb4I,KAAK9H,SAAS0W,wBACdxM,EAGH,CAKqB4E,gBAACsC,GACrB,kBAAkBpR,SAAS2W,UAAUvF,EACtC,CAK4BtC,yBAC3B,kBAAkB9O,SAAS4W,cAC5B,CAYwB9H,mBACvBG,EACA4H,EACAC,EACAC,EACAC,EACA3M,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,oCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAY4M,aAC7CJ,EACAC,EACAC,EACAC,GAEF,OAAI3M,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwU,EAAavV,iBACb4I,KAAK9H,SAASiX,aACdJ,EACAC,EACAC,EACAC,EAIH,QCvSUE,WAAYvI,GACvBE,gBACE,OAAOsI,EAAevI,GACvB,CAkB2BE,sBAC1BnK,EACAsK,EACAmI,EACAC,EACAC,EACAC,EACAC,EACAC,EACAlT,EACAC,EACAkT,EACArN,SAEA,IAAwE,gBAAxDsN,kBAAkBhT,EAAYsK,IAAU2I,YACtD,UAAU3Q,yCAEPyQ,IAAeA,EAAgB,GAG/BnT,GAASC,KACRD,OAAMC,UAAWlB,KAIvB,MAAMuU,EAAc/P,KAAKkH,YAAYrK,GAE/BvC,QAAeyV,EAAYxN,YAAYyN,YAC3CJ,EACA,CAACnT,EAAMC,GACP,CAAC4S,EAAQC,EAAkBC,EAAcC,GACzC,YACa9V,cAAc,KAAMgW,EAAK,eACzBhW,cAAc,KAAM+V,EAAW,KAE5C,IAEF,GAAInN,EAAa,OAA6CjI,EAE9D,MAAM2V,QAAW5V,EACfC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb2Y,EAAYC,YACZJ,EACA,CAACnT,EAAMC,GACP,CAAC4S,EAAQC,EAAkBC,EAAcC,GACzC,YACa9V,cAAc,KAAMgW,EAAK,eACzBhW,cAAc,KAAM+V,EAAW,KAE5C,IAIItV,EAAQP,QAFWoW,EAAGC,OAEa,gBACzC,aAAO9V,SAAAA,EAAOI,KAAK,EACpB,CAUsBwM,iBACrBnK,EACAsK,EACAgJ,EACA5N,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,cAAgBuT,YAAYvT,KAAiBsK,EAC3C,UAAUhI,iCAGZ,MAAM7E,QAAeyV,EAAYxN,YAAY8N,WAAWF,GACxD,OAAI5N,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb2Y,EAAYM,WACZF,EAIH,CAUyBnJ,oBACxBnK,EACAsK,EACAgJ,EACA5N,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,cAAgBuT,YAAYvT,KAAiBsK,EAC3C,UAAUhI,iCAGZ,MAAM7E,QAAeyV,EAAYxN,YAAY+N,cAAcH,GAC3D,OAAI5N,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALqQ,EAAapR,iBACb2Y,EAAYO,cACZH,EAIH,CAUgCnJ,2BAC/BnK,EACAsK,EACAoJ,EACAhO,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,IAAoE,gBAApDgT,kBAAkBhT,EAAYsK,IAAUgJ,QACtD,UAAUhR,+BAIZ,MAAM7E,QAAeyV,EAAYxN,YAAYiO,qBAAqBD,GAClE,OAAIhO,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwQ,EAAavR,iBACb2Y,EAAYS,qBACZD,EAIH,CAUmCvJ,8BAClCnK,EACAsK,EACAoJ,EACAhO,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,IACkE,gBAApDgT,kBAAkBhT,EAAYsK,IAAUgJ,SACnDhJ,IAAYoJ,IACyD,gBAAxDV,kBAAkBhT,EAAYsK,IAAU2I,YAEtD,UAAU3Q,qDAEZ,MAAM7E,QAAeyV,EAAYxN,YAAYkO,0BAC3CF,GAEF,OAAIhO,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL2Q,EAAa1R,iBACb2Y,EAAYU,0BACZF,EAIH,CAU8BvJ,yBAC7BnK,EACAsK,EACAuJ,EACAnO,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,IAAoE,gBAApDgT,kBAAkBhT,EAAYsK,IAAUgJ,QACtD,UAAUhR,+BAGZ,MAAM7E,QAAeyV,EAAYxN,YAAYoO,kBAAkBD,GAC/D,OAAInO,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL6Q,EAAa5R,iBACb2Y,EAAYY,kBACZD,EAGH,CAUiC1J,4BAChCnK,EACAsK,EACAuJ,EACAnO,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,IACkE,gBAApDgT,kBAAkBhT,EAAYsK,IAAUgJ,SACnDhJ,IAAYuJ,IAC4D,gBAA3Db,kBAAkBhT,EAAYsK,IAAUyJ,eAEtD,UAAUzR,oDAGZ,MAAM7E,QAAeyV,EAAYxN,YAAYsO,uBAAuBH,GACpE,OAAInO,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALuU,EAAatV,iBACb2Y,EAAYc,uBACZH,EAGH,CAU2B1J,sBAC1BnK,EACAsK,EACA2J,EACAvO,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,IAAoE,gBAApDgT,kBAAkBhT,EAAYsK,IAAUgJ,QACtD,UAAUhR,+BAGZ,MAAM7E,QAAeyV,EAAYxN,YAAYwO,kBAAkBD,GAC/D,OAAIvO,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwU,EAAavV,iBACb2Y,EAAYgB,kBACZD,EAIH,CAU8B9J,yBAC7BnK,EACAsK,EACA2J,EACAvO,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,IACkE,gBAApDgT,kBAAkBhT,EAAYsK,IAAUgJ,SACnDhJ,IAAY2J,IACmD,gBAAlDjB,kBAAkBhT,EAAYsK,IAAU6J,MAEtD,UAAU7R,gDAGZ,MAAM7E,QAAeyV,EAAYxN,YAAY0O,uBAAuBH,GACpE,OAAIvO,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL4U,EAAa3V,iBACb2Y,EAAYkB,uBACZH,EAIH,CAY4B9J,uBAC3BnK,EACAsK,EACA5E,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,cAAgBuT,YAAYvT,KAAiBsK,EAC3C,UAAUhI,iCAGZ,MAAM7E,QAAeyV,EAAYxN,YAAY2O,mBAC7C,OAAI3O,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8U,EAAa7V,iBACb2Y,EAAYmB,iBAIf,CAYuBlK,kBACtBnK,EACAsU,EACAC,EACAC,EACA9O,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,cAAgBuT,YAAYvT,KAAiBsU,EAC3C,UAAUhS,iCAGZ,MAAMmS,EAAkBD,GAAW,EAE7B/W,QAAeyV,EAAYxN,YAAYgP,aAC3CJ,EACAC,EACAE,GAEF,OAAI/O,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALgV,EAAa/V,iBACb2Y,EAAYwB,aACZJ,EACAC,EACAE,EAIH,CAY2BtK,sBAC1BnK,EACAsU,EACAC,EACAC,EACA9O,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,cAAgBuT,YAAYvT,KAAiBsU,EAC3C,UAAUhS,iCAGZ,MAAMmS,EAAkBD,GAAW,EAE7B/W,QAAeyV,EAAYxN,YAAYiP,iBAC3CL,EACAC,EACAE,GAEF,OAAI/O,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALkV,EAAajW,iBACb2Y,EAAYyB,iBACZL,EACAC,EACAE,EAIH,CAgBuBtK,kBACtBnK,EACAsK,EACAsK,EACAC,EACAC,EACAC,EACA3U,EACA4U,EACAC,EACAvP,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,GADKiV,IAAgBA,EAAiB,iBACrBjC,kBAAkBhT,EAAYsK,IAAUyJ,eACvD,UAAUzR,wCAEZ,MAAM7E,QAAeyV,EAAYxN,YAAYwP,YAC3CN,EACAC,EACAC,EACAC,EACA3U,EACA4U,EACAC,GAEF,OAAIvP,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALuV,EAAatW,iBACb2Y,EAAYgC,YACZN,EACAC,EACAC,EACAC,EACA3U,EACA4U,EACAC,EAIH,CAUkC9K,6BACjCnK,EACA6T,EACAsB,EACAzP,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GACrC,gBAAiBgT,kBAAkBhT,EAAY6T,IAAkBE,eAC/D,UAAUzR,wCAEZ,MAAM8S,OACDD,GACHF,eAAgBE,EAAoBF,gBAAkB,KAElDxX,QAAeyV,EAAYxN,YAAY2P,uBAC3CD,GAEF,OAAI1P,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL0V,EAAazW,iBACb2Y,EAAYmC,uBACZD,EAIH,CAU4BjL,uBAC3BnK,EACAsK,EACAsK,EACAlP,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAErC,gBAAiBgT,kBAAkBhT,EAAYsK,IAAUyJ,eACvD,UAAUzR,wCAGZ,MAAM7E,QAAeyV,EAAYxN,YAAY4P,iBAAiBV,GAC9D,OAAIlP,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALia,EAAahb,iBACb2Y,EAAYoC,iBACZV,EAGH,CASuBzK,kBACtBnK,EACAI,EACAsF,SAEA,MAAMwN,EAAc/P,KAAKkH,YAAYrK,GAE/BvC,QAAeyV,EAAYxN,YAAY8P,YAAY,IAAKpV,GAC9D,OAAIsF,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALma,EAAalb,iBACb2Y,EAAYsC,YACZ,IACApV,EAGH,CAOuB+J,kBAACnK,GACvB,MAAMkT,EAAc/P,KAAKkH,YAAYrK,GAErC,aADyBkT,EAAYwC,QAAQ,EAE9C,CAQ6BvL,wBAACnK,EAAoBsK,GACjD,MAAM4I,EAAc/P,KAAKkH,YAAYrK,GAErC,aADoBkT,EAAYyC,eAAerL,EAEhD,CAOuBH,kBAACnK,GACvB,MAAMkT,EAAc/P,KAAKkH,YAAYrK,GACrC,aAAakT,EAAY0C,aAC1B,CAQ+BzL,0BAC9BnK,EACAsK,GAEA,MAAM4I,EAAc/P,KAAKkH,YAAYrK,GAErC,aADkCkT,EAAY2C,gBAAgBvL,EAE/D,CAYmBH,cAClBnK,EACAsK,EACA7B,EACAqN,EACApQ,SAEA,IAAkE,gBAAlDsN,kBAAkBhT,EAAYsK,IAAU6J,MACtD,UAAU7R,yCAGZ,MAAM4Q,EAAc/P,KAAKkH,YAAYrK,GAE/B+V,EAAUja,EAAOc,MAAMoZ,UAAUvN,GACjCwN,EAAWna,EAAOc,MAAMsZ,QAAQpa,EAAOc,MAAMuZ,YAAYL,IAEzDrY,QAAeyV,EAAYxN,YAAY0Q,WAAWL,EAASE,GACjE,OAAIvQ,EAA0CjI,QACrBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL+a,EAAa9b,iBACb2Y,EAAYkD,WACZL,EACAE,EAIH,CAQmB9L,cAACnK,EAAoByI,GACvC,MAAMyK,EAAc/P,KAAKkH,YAAYrK,GAC/B+V,EAAUja,EAAOc,MAAMoZ,UAAUvN,GACjCrI,QAAa8S,EAAYoD,QAAQP,GACvC,OAAO3V,EAAOtE,EAAOc,MAAM2Z,aAAanW,GAAQ,IACjD,CAQuB+J,kBAACnK,EAAoBwW,GAC3C,MAAMtD,EAAc/P,KAAKkH,YAAYrK,GAErC,aADmBkT,EAAYuD,SAASD,EAEzC,QC5uBUE,WAAkB1M,GAI7BE,gBACE,OAAOyM,EAAc1M,GACtB,CAUDhH,YACEzH,EACAxB,EACAsB,EACA2O,EACA2M,GAEAjM,MAAMnP,EAAQxB,EAASsB,EAAQ2O,QAtB1B2M,0BACAC,WAsBL1T,KAAKyT,cAAgBA,GAAkBE,EAAwB7M,IAC/D9G,KAAK0T,IAAM,IAAItE,GAAIpP,KAAK3H,OACzB,CAUmB2O,cAClBmB,EACA9F,EACA9I,EACAgJ,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAE9B7N,QAAesZ,EAAWrR,YAAYL,QAC1CG,EACA1I,EAAc,KAAM,KAAMJ,EAAQ,KAEpC,OAAIgJ,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACbwc,EAAW1R,QACXG,EACA1I,EAAc,KAAM,KAAMJ,EAAQ,IAGrC,CAU2ByN,sBAC1BmB,EACAhB,EACA0M,EACAtR,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GACpC,eAAiB2L,oBAAoB3L,EAAWhB,GAC9C,UAAUhI,wCAEP0U,EAAgBE,kBAAiBF,EAAgBE,gBAAkBlc,GAExE,MAAM+T,GAAwC,IAA7BiI,EAAgBjI,SAAqB,EAAI,EAIpDtR,QAAesZ,EAAWrR,YAAYyR,gBAC1CH,EAAgBI,iBAChB,CACEJ,EAAgBK,iBAChBL,EAAgB/L,MAChB+L,EAAgBzH,mBAChByH,EAAgBE,iBAElB,CACEF,EAAgBM,kBAChBN,EAAgBO,kBAChBP,EAAgB7H,UAChB6H,EAAgB1H,UAChBP,IAGJ,OAAIrJ,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACbwc,EAAWI,gBACXH,EAAgBI,iBAChB,CACEJ,EAAgBK,iBAChBL,EAAgB/L,MAChB+L,EAAgBzH,mBAChByH,EAAgBE,iBAElB,CACEF,EAAgBM,kBAChBN,EAAgBO,kBAChBP,EAAgB7H,UAChB6H,EAAgB1H,UAChBP,GAIL,CAW2B5E,sBAC1BmB,EACAhB,EACAjR,EACAme,EACA9R,SAEA,eAAiBuR,oBAAoB3L,EAAWhB,GAC9C,UAAUhI,wCAGZ,MAAMyU,EAAa5T,KAAKkH,YAAYiB,GAE/BkM,EAAgBnM,iBAAgBmM,EAAgBnM,eAAiBrQ,GAEtEwc,EAAgBzI,UAAwC,IAA7ByI,EAAgBzI,SAI3C,MAAMtR,QAAesZ,EAAWrR,YAAY+R,gBAC1Cpe,EACAme,EAAgBrM,UAChBqM,EAAgBpM,WAChBoM,EAAgBzI,SAChByI,EAAgBnM,gBAElB,OAAI3F,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALqQ,EAAapR,iBACbwc,EAAWU,gBACXpe,EACAme,EAAgBrM,UAChBqM,EAAgBpM,WAChBoM,EAAgBzI,SAChByI,EAAgBnM,eAGnB,CAWgBlB,WACfmB,EACAhB,EACA5N,EACAgb,EACAhS,GAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAEpC,IAA+D,gBAA/CqK,eAAerK,EAAWhB,IAAUmI,OAClD,UAAUnQ,8BAGZ,MAAMqV,aAAyBC,OAAOtM,GACtC,GAAI,IAAIxF,EAAQ6R,GAAaE,IAAInb,GAAS,OACxC,MAAMe,QAAesZ,EAAWrR,YAAYoS,KAC1CJ,GAAapN,EACbxN,EAAc,KAAM,KAAMJ,EAAQ,KAEpC,OAAIgJ,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwQ,EAAavR,iBACbwc,EAAWe,KACXJ,GAAapN,EACbxN,EAAc,KAAM,KAAMJ,EAAQ,IAGrC,CACC,UAAU4F,0CAEb,CAWqB6H,gBACpBmB,EACAhB,EACAmI,EACA/M,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAEpC,IAA6D,eAA7C2L,oBAAoB3L,EAAWhB,GAC7C,UAAUhI,yCAGZ,MAAM7E,QAAesZ,EAAWrR,YAAYqS,UAAUtF,GACtD,OAAI/M,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL2Q,EAAa1R,iBACbwc,EAAWgB,UACXtF,EAIH,CAWwBtI,mBACvBmB,EACAhB,EACAmI,EACA/M,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAEpC,IAA6D,eAA7C2L,oBAAoB3L,EAAWhB,GAC7C,UAAUhI,yCAGZ,MAAM7E,QAAesZ,EAAWrR,YAAYsS,aAAavF,GACzD,OAAI/M,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL6Q,EAAa5R,iBACbwc,EAAWiB,aACXvF,EAIH,CAW6BtI,wBAC5BmB,EACAhB,EACA2N,EACAvS,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAEpC,IAA6D,eAA7C2L,oBAAoB3L,EAAWhB,GAC7C,UAAUhI,yCAGZ,MAAM7E,QAAesZ,EAAWrR,YAAYwS,kBAAkBD,GAC9D,OAAIvS,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALuU,EAAatV,iBACbwc,EAAWmB,kBACXD,EAIH,CAWgC9N,2BAC/BmB,EACAhB,EACA2N,EACAvS,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAEpC,IAA6D,eAA7C2L,oBAAoB3L,EAAWhB,GAC7C,UAAUhI,yCAGZ,MAAM7E,QAAesZ,EAAWrR,YAAYyS,qBAAqBF,GACjE,OAAIvS,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwU,EAAavV,iBACbwc,EAAWoB,qBACXF,EAIH,CAY+B9N,0BAC9BmB,EACAhB,EACAoI,EACAhN,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAC9B8M,cAA+BzC,eAAerK,EAAWhB,IAC5D2N,eACGjY,GAAcoY,cAAgCC,cAAc/M,GAC5DgN,EAAatY,cAA0B6W,IAAItD,YAAYvT,KAAiBsK,EACxEiO,EACJvY,IAAesY,cAA0BzB,IAAI7D,kBAAkBhT,EAAYsK,GAE7E,IAAK8N,IAAqBE,WADEC,SAAAA,EAAgBtF,aAE1C,UAAU3Q,gEAGZ,MAAM7E,QAAesZ,EAAWrR,YAAY8S,oBAAoB9F,GAChE,OAAIhN,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL4U,EAAa3V,iBACbwc,EAAWyB,oBACX9F,EAGH,CAO+BvI,0BAACmB,GAC/B,MAAMyL,EAAa5T,KAAKkH,YAAYiB,GAEpC,aAD+ByL,EAAW0B,qBAE3C,CAUoBtO,eACnBmB,EACAoM,EACAhb,EACAgJ,GAEA,YAAYgT,YACVpN,EACAoM,QACM5a,EAAc,KAAM,KAAMJ,EAAQ,IACxCgJ,EAEH,CAUuByE,kBACtBmB,EACAoM,EACAhb,EACAgJ,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAE9B7N,QAAesZ,EAAWrR,YAAYW,SAASqR,EAAWhb,GAChE,OAAIgJ,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8U,EAAa7V,iBACbwc,EAAW1Q,SACXqR,EACAhb,EAGH,CAYsByN,iBACrBmB,EACAqN,EACAC,EACAC,EACA9L,EACArH,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAC/ByB,IACHA,EAAmB,CACjB+L,wBAAyB9d,EACzB+d,sBAAuB/d,EACvB6T,uBAAwB,MAI5B,MAAMpR,QAAesZ,EAAWrR,YAAYsT,WAC1CL,EACAC,EACAC,EACA9L,GAEF,OAAIrH,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALgV,EAAa/V,iBACbwc,EAAWiC,WACXL,EACAC,EACAC,EACA9L,EAGH,CAYsB5C,iBACrBmB,EACA2N,EACAJ,EACAnT,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,GAE9B7N,QAAesZ,EAAWrR,YAAYwT,WAAWD,EAAWJ,GAClE,OAAInT,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALkV,EAAajW,iBACbwc,EAAWmC,WACXD,EACAJ,EAGH,CAU8B1O,yBAC7BmB,EACA6N,EACAC,EACA1T,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,EAAWnI,KAAKyT,eAE9CyC,aAA+BC,kBAAkBF,GAEjD3b,QAAesZ,EAAWrR,YAAY6T,mBAC1CJ,EACAE,GAEF,OAAI3T,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALuV,EAAatW,iBACbwc,EAAWwC,mBACXJ,EACAE,EAGH,CAUoClP,+BACnCmB,EACA6N,EACAK,EACA9T,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYiB,EAAWnI,KAAKyT,eAE9CnZ,QAAesZ,EAAWrR,YAAY+T,yBAC1CN,EACAK,GAEF,OAAI9T,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL0V,EAAazW,iBACbwc,EAAW0C,yBACXN,EACAK,EAGH,CAWmBrP,cAClBmB,EACAhB,EACAwL,EACApQ,SAEA,eAAiBuR,oBAAoB3L,EAAWhB,GAC9C,UAAUhI,wCAGZ,MAAMyU,EAAa5T,KAAKkH,YAAYiB,GAE9B2K,EAAWna,EAAOc,MAAMsZ,QAAQpa,EAAOc,MAAMuZ,YAAYL,IAEzDrY,QAAesZ,EAAWrR,YAAYgU,QAAQzD,GACpD,OAAIvQ,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALia,EAAahb,iBACbwc,EAAW2C,QACXzD,EAIH,CAU4B9L,uBAC3BmB,EACAhB,EACA5E,SAEA,cAAgBmR,IAAItD,uBAAuB8E,cAAc/M,MAAiBhB,EACxE,UAAUhI,MAAM,2BAElB,MAAMyU,EAAa5T,KAAKkH,YAAYiB,GAE9B7N,QAAesZ,EAAWrR,YAAY2O,mBAC5C,OAAI3O,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALma,EAAalb,iBACbwc,EAAW1C,iBAId,CAQ0BlK,qBACzBmB,EACAhB,GAEA,MAAMyM,EAAa5T,KAAKkH,YAAYiB,GAEpC,aADoByL,EAAW4C,YAAYrP,EAE5C,CAOkBH,aAACmB,GAClB,MAAMyL,EAAa5T,KAAKkH,YAAYiB,GAC9BwH,QAAYiE,EAAWjE,MAC7B,kBAAkBrW,cAAc,KAAMqW,EAAK,GAC5C,CAOuB3I,kBAACmB,GACvB,MAAMyL,EAAa5T,KAAKkH,YAAYiB,GAEpC,aADuByL,EAAWva,UAEnC,CAOqB2N,gBAACmB,GACrB,MAAMyL,EAAa5T,KAAKkH,YAAYiB,GAEpC,aADqByL,EAAWlX,QAEjC,CAOmBsK,cAACmB,GACnB,MAAMyL,EAAa5T,KAAKkH,YAAYiB,GAEpC,aADmByL,EAAWnX,MAE/B,CAOyBuK,oBAACmB,GACzB,MAAMyL,EAAa5T,KAAKkH,YAAYiB,GAEpC,aADyByL,EAAW6C,kBAErC,CAQ+BzP,0BAACmB,EAAmBhB,GAClD,MAAMyM,EAAa5T,KAAKkH,YAAYiB,GAEpC,aADkCyL,EAAWlB,gBAAgBvL,EAE9D,CAQmBH,cAAC0P,EAA0BvP,GAC7C,MAAMyM,EAAa5T,KAAKkH,YAAYwP,GAC9BrT,QAAgBuQ,EAAWtQ,UAAU6D,GAC3C,kBAAkB7N,cAAc,KAAM+J,EAAS,GAChD,CAYkC2D,6BACjC0P,EACAC,EACAC,EACApL,EACArE,EACA5E,SAEA,MAAMqR,EAAa5T,KAAKkH,YAAYwP,GAEpC,UAD6B9C,EAAWiD,0BAA0B,KAC5C1P,EACpB,UAAUhI,yDAEZ,MAAM7E,QAAesZ,EAAWrR,YAAYuU,uBAC1CH,EACAC,EACApL,GAEF,OAAIjJ,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL+a,EAAa9b,iBACbwc,EAAWkD,uBACXH,EACAC,EACApL,EAIH,CAOkCxE,6BACjC0P,GAEA,MAAM9C,EAAa5T,KAAKkH,YAAYwP,GAE9BK,QAA4BnD,EAAWiD,yBAM7C,MALqB,CACnBF,wBAAyBI,EAAoB,GAC7CH,sBAAuBG,EAAoB,GAC3CvL,uBAAwBuL,EAAoB,GAAGje,WAGlD,CAE8BkO,wBAACiP,GAC9B,MAAO,CACLe,iBAAkBf,EAAUe,iBAC5BxN,WAAYyM,EAAUzM,WACtBE,yBAA0B/P,EACxBqG,KAAK3H,OACL4d,EAAU/B,iBACV+B,EAAUvM,mBACVuM,EAAU9B,mBAEZ8C,oBAAqBtd,EACnBqG,KAAK3H,OACL4d,EAAU/B,iBACV+B,EAAUgB,cACVhB,EAAU9B,mBAGZ+C,iBAAkBjB,EAAUiB,iBAE/B,QCp1BUC,WAAmB5P,GAC9BR,gBACE,OAAOb,EAAcY,GACtB,CAQqBE,gBACpBoQ,EACA7U,SAIA,GAFK6U,EAAQxH,gBAAewH,EAAQxH,cAAgB,IAE/CwH,EAAQ3a,OAAS2a,EAAQ1a,OAAQ,CACpC,MAAMD,KAAEA,EAAFC,OAAQA,GAAWlB,IACzB4b,EAAQ3a,KAAOA,EACf2a,EAAQ1a,OAASA,CAClB,CACD,GAAI0a,EAAQxH,yBAA4ByH,6BACtC,UAAUlY,qCAGZ,GAA8B,IAA1BiY,EAAQxH,cACV,UAAUzQ,uCAEZ,IAAoE,gBAApDmY,eAAeF,EAAQxH,gBAAgBpD,SACrD,UAAUrN,gCAEZ,MAAM7E,aAAoBpC,SAASqK,YAAYgV,qBAC7CH,EAAQ3a,KACR2a,EAAQ1a,OACR0a,EAAQxH,cACR/X,EACAA,EACAuf,EAAQ9D,SACR8D,EAAQI,aACRJ,EAAQtP,OAEV,GAAIvF,EAAa,OAA6CjI,EAE9D,MAAM2V,QAAW5V,EACfC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAASqf,qBACdH,EAAQ3a,KACR2a,EAAQ1a,OACR0a,EAAQxH,cACR/X,EACAA,EACAuf,EAAQ9D,SACR8D,EAAQI,aACRJ,EAAQtP,OAIV,OADejO,QADUoW,EAAGC,OACc,cAC5B1V,KAAK,EACpB,CAM8BwM,2BAE7B,kBAD4B9O,SAASuf,oBAEtC,CAMgCzQ,6BAE/B,kBAD8B9O,SAASwf,sBAExC,CAMoB1Q,iBAEnB,kBADyB9O,SAAS4P,OAEnC,CAMsCd,mCAErC,kBADyB9O,SAASmf,4BAEnC,CAMwCrQ,qCAEvC,kBADyB9O,SAASyf,yBAEnC,CAO0B3Q,qBAAC/H,GAC1B,GAAIA,aAAoBoY,6BACtB,UAAUlY,qCAGZ,GAAc,IAAVF,EACF,UAAUE,uCAGZ,kBAD4BjH,SAASof,eAAerY,EAErD,CAO4B+H,uBAAC/H,GAE5B,kBAD4B/G,SAAS0f,iBAAiB3Y,EAEvD,CAO0B+H,qBAACiC,GAE1B,kBAD8B/Q,SAAS2f,UAAU5O,EAElD,CAOoBjC,eAACnK,GAEpB,kBADkC3E,SAAS4f,WAAWjb,EAEvD,CAS0BmK,qBACzBG,EACA4Q,EACAxV,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,qCAEZ,GAAI4Y,IAAoBlgB,EACtB,UAAUsH,yCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAYyV,oBAAoBD,GACnE,OAAIxV,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb4I,KAAK9H,SAAS8f,oBACdD,EAGH,CAS8B/Q,yBAC7BG,EACAyI,EACArN,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,qCAEZ,GAAIyQ,aAA4ByH,6BAC9B,UAAUlY,qCAGZ,GAAsB,IAAlByQ,EACF,UAAUzQ,uCAEZ,MAAM7E,aAAoBpC,SAASqK,YAAY0V,wBAAwBrI,GACvE,OAAIrN,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALqQ,EAAapR,iBACb4I,KAAK9H,SAAS+f,wBACdrI,EAIH,CASiC5I,4BAChCG,EACAyI,EACArN,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,qCAEZ,GAAIyQ,aAA4ByH,6BAC9B,UAAUlY,qCAGZ,GAAsB,IAAlByQ,EACF,UAAUzQ,uCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAY2V,2BAC7CtI,GAEF,OAAIrN,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwQ,EAAavR,iBACb4I,KAAK9H,SAASggB,2BACdtI,EAIH,CAS4B5I,uBAC3BG,EACA4Q,EACAxV,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,qCAEZ,GAAI4Y,IAAoBlgB,EACtB,UAAUsH,yCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAY4V,iBAAiBJ,GAChE,OAAIxV,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL2Q,EAAa1R,iBACb4I,KAAK9H,SAASigB,iBACdJ,EAIH,CASgC/Q,2BAC/BG,EACAyI,EACArN,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,qCAEZ,GAAIyQ,aAA4BwI,+BAC9B,UAAUjZ,qCAGZ,GAAsB,IAAlByQ,EACF,UAAUzQ,uCAEZ,IAA8D,gBAA9CyY,iBAAiBhI,IAAgBpD,SAC/C,UAAUrN,sCAEZ,MAAM7E,aAAoBpC,SAASqK,YAAY8V,qBAAqBzI,GACpE,OAAIrN,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL6Q,EAAa5R,iBACb4I,KAAK9H,SAASmgB,qBACdzI,EAIH,CASmC5I,8BAClCG,EACAyI,EACArN,SAEA,cAAgB+L,aAAgBnH,EAC9B,UAAUhI,qCAEZ,GAAIyQ,aAA4BwI,+BAC9B,UAAUjZ,qCAGZ,GAAsB,IAAlByQ,EACF,UAAUzQ,uCAEZ,IAA8D,gBAA9CyY,iBAAiBhI,IAAgBpD,SAC/C,UAAUrN,oCAGZ,MAAM7E,aAAoBpC,SAASqK,YAAY+V,wBAAwB1I,GACvE,OAAIrN,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALuU,EAAatV,iBACb4I,KAAK9H,SAASogB,wBACd1I,EAIH,CAamC5I,8BAClCuR,EACAhW,SAEA,GAAIgW,EAAOvc,OAAS,GAClB,UAAUmD,yBAGZ,MAAM7E,aAAoBpC,SAASqK,YAAYiW,wBAAwBD,GACvE,OAAIhW,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALwU,EAAavV,iBACb4I,KAAK9H,SAASsgB,wBACdD,EAIH,CAUkCvR,6BACjCyR,EACAC,EACAnW,SAEA,MAAMoW,aAA2BC,qBAAqBF,GAChDpe,aAAoBpC,SAASqK,YAAYsW,mBAC7CJ,EACAE,GAEF,OAAIpW,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL4U,EAAa3V,iBACb4I,KAAK9H,SAAS2gB,mBACdJ,EACAE,EAIH,CAW+C3R,0CAC9CyR,EACAC,EACAzC,EACA1T,SAEA,MAAMoW,aAA2BC,qBAAqBF,GAChDI,aAAuBC,qBAAqB9C,GAE5C3b,aAAoBpC,SAASqK,YAAYyW,gCAC7CP,EACAE,EACAG,GAEF,OAAIvW,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8U,EAAa7V,iBACb4I,KAAK9H,SAAS8gB,gCACdP,EACAE,EACAG,EAIH,CAW+C9R,0CAC9CyR,EACAC,EACArE,EACA9R,SAEA,MAAMoW,aAA2BC,qBAAqBF,GAEtDrE,EAAgBpM,sBAAwBtO,cACtC,KACA0a,EAAgBpM,WAChB,IAGFoM,EAAgBrM,qBAAuBrO,cACrC,KACA0a,EAAgBrM,UAChB,IAGF,MAAM1N,aAAoBpC,SAASqK,YAAY0W,gCAC7CR,EACAE,EACAtE,GAEF,OAAI9R,EAA0CjI,QAErBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALgV,EAAa/V,iBACb4I,KAAK9H,SAAS+gB,gCACdR,EACAE,EACAtE,EAIH,CAOiCrN,2BAAC0R,GACjC,IAAIjc,EAAcC,EAEbgc,EAASjc,MAASic,EAAShc,UAC1BD,OAAMC,UAAWlB,KAGvB,IAAI0d,EAAmB,GACvB,GAAIR,EAASjJ,WAAa5X,EACxB,IACEqhB,QAAyBjgB,EAAiB+G,KAAK3H,OAAQqgB,EAASjJ,SAGjE,CAFC,MAAO/O,GACPI,EAAeJ,MAAM,yBAA0BA,EAChD,CAGH,MAAO,CACLkP,cAAe8I,EAAS9I,cACxBuJ,QAAS,CAACT,EAASjc,MAAQA,EAAMic,EAAShc,QAAUA,GACpD0c,UAAW,CACTV,EAASpJ,OACToJ,EAASnJ,iBACTmJ,EAASlJ,aACTkJ,EAASjJ,UAEX4J,MAAO,YACM1f,cAAc,KAAM+e,EAAS/I,IAAK,eAClChW,cAAc,KAAM+e,EAAShJ,UAAWwJ,IAErDI,OAAQ,GAEX,CAOiCtS,2BAACiP,GAC5BA,EAAUlC,kBAAiBkC,EAAUlC,gBAAkBlc,GAC5D,MAAM+T,GAAkC,IAAvBqK,EAAUrK,SAAqB,EAAI,EAEpD,MAAO,CACL2N,kBAAmBtD,EAAUhC,iBAC7BmF,UAAW,CACTnD,EAAU/B,iBACV+B,EAAUnO,MACVmO,EAAU7J,mBACV6J,EAAUlC,iBAEZsF,MAAO,CACLpD,EAAU9B,kBACV8B,EAAU7B,6BACCza,cAAc,KAAMsc,EAAUjK,UAAW,eACzCrS,cAAc,KAAMsc,EAAU9J,UAAW,IACpDP,GAGL,QC/lBU4N,WAAgBjS,GAC3BR,gBACE,OAAO0S,EAAW3S,GACnB,CASsBE,iBACrBzN,EACAmgB,EACAnX,SAEA,MAAMM,aAA6BlJ,yBAAyBggB,WAAYpgB,GAClEe,aAAoBpC,SAASqK,YAAYqX,YAC7C/W,EACA6W,GAEF,OAAInX,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAAS0hB,YACd/W,EACA6W,EAGH,CAUsB1S,iBACrBuN,EACAhb,EACAgJ,SAEA,MAAMM,aAA6BlJ,yBAAyBggB,WAAYpgB,GAClEe,aAAoBpC,SAASqK,YAAYsX,YAAYtF,EAAW1R,GACtE,OAAIN,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb4I,KAAK9H,SAAS2hB,YACdtF,EACA1R,EAGH,CAQ0BmE,qBACzBzN,EACAgJ,SAEA,MAAMM,aAA6BlJ,yBAAyBggB,WAAYpgB,GAClEe,aAAoBpC,SAASqK,YAAYuX,gBAAgBjX,GAC/D,OAAIN,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAALqQ,EAAapR,iBACb4I,KAAK9H,SAAS4hB,gBACdjX,EAGH,CAQ8BmE,yBAC7B0S,EACAnX,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYwX,qBAAqBL,GACpE,OAAInX,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAALwQ,EAAavR,iBACb4I,KAAK9H,SAAS6hB,qBACdL,EAGH,CAOoB1S,eACnBzE,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYyX,WAC/C,OAAIzX,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAAL2Q,EAAa1R,iBACb4I,KAAK9H,SAAS8hB,SAGjB,CAM0BhT,qBAACiT,GAE1B,kBAD2B/hB,SAASoL,UAAU2W,EAE/C,CAM2BjT,sBAACiT,GAC3B,MAAM5W,aAAqBnL,SAASgiB,OAAOD,GAM3C,kBALmC3gB,yBACtBqgB,WACXtW,EAAQ9J,OAAOT,WAIlB,CAMmBkO,cAACiT,GACnB,MAAME,aAAuBjiB,SAASkiB,YAAYH,GAClD,OAAOI,SAASF,EAAUrhB,WAC3B,CAKuBkO,oBAKtB,kBAJkC1N,yBACrBqgB,sBACAzhB,SAASoiB,cAGvB,CAKoBtT,iBAEnB,kBADgC9O,SAASgB,OAE1C,QCxLUqhB,WAAyBhT,GACpCR,gBACE,OAAOyT,EAAS1T,GACjB,CAYiBE,YAChBzE,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYkY,QAC/C,OAAIlY,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAASuiB,MAGjB,CAWqBzT,gBACpBoS,EACA7W,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYmY,WAAWtB,GAC1D,OAAI7W,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb4I,KAAK9H,SAASwiB,WACdtB,EAGH,QCxDUuB,WAAsBpT,GACjCR,gBACE,OAAOnP,EAAckP,GACtB,CAOyBE,oBAACiT,GACzB,MAAM1gB,aAAoBrB,SAAS0iB,cAAcX,GAC3CY,EAAU,IAAIrB,cAAmBthB,SAAS4iB,gBAAiB9a,KAAK3H,QAEtE,kBADkCiB,oBAAoBuhB,EAAQlB,WAAYpgB,EAE3E,QCfUwhB,WAAmBxT,GAC9BR,gBACE,OAAOiU,EAAclU,GACtB,CAUyBE,oBACxBzN,EACAma,EACA9c,EACA2L,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAY0Y,cAAc1hB,EAAQma,EAAK9c,GAC1E,OAAI2L,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAAS+iB,cACd1hB,EACAma,EACA9c,EAGH,CAU8BoQ,yBAC7BzN,EACAma,EACA9c,EACA2L,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAY2Y,mBAC7C3hB,EACAma,EACA9c,GAEF,OAAI2L,EAA0CjI,QAGrBD,EACvBC,EAAOe,IAAI,KACX2E,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb4I,KAAK9H,SAASgjB,mBACd3hB,EACAma,EACA9c,EAGH,CAM8BoQ,yBAACiT,GAE9B,kBAD8B/hB,SAASijB,mBAAmBlB,EAE3D,CAQ2BjT,sBAC1BiT,EACAvG,EACA9c,GAGA,kBAD8BsB,SAASkjB,gBAAgBnB,EAAavG,EAAK9c,EAE1E,QC1FUykB,WAAkB9T,GAC7BR,gBACE,OAAOuU,EAAaxU,GACrB,CAO+BE,0BAC9BiT,EACA7X,GAEA,MAAMmZ,aAAqBrjB,SAASsjB,UAAUvB,EAAa7X,GAG3D,kBAFmC9I,cAAc8I,EAAcmZ,EAGhE,CASwBvU,mBACvBiT,EACA7X,EACAG,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAYkZ,SAASxB,EAAa7X,GACrE,OAAIG,EAA0CjI,QAGrBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAASujB,SACdxB,EACA7X,EAGH,CAU2B4E,sBAC1B0U,EACAC,EACAvZ,EACAG,SAEA,IAAK,IAAIqZ,EAAI,EAAGA,EAAID,EAAQ3f,OAAQ4f,IAClCD,EAAQC,cAAgBjiB,cAAcyI,EAAcuZ,EAAQC,IAE9D,MAAMthB,aAAoBpC,SAASqK,YAAYsZ,SAC7CH,EACAC,EACAvZ,GAEF,OAAIG,EAA0CjI,QAGrBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAALmQ,EAAalR,iBACb4I,KAAK9H,SAAS2jB,SACdH,EACAC,EACAvZ,EAGH,QCnFU0Z,WAAqBvU,GAChCR,gBACE,OAAOgV,EAAgBjV,GACxB,CAOuCE,kCACtCiT,EACA+B,GAEA,MAAMT,aAAqBrjB,SAAS+jB,WAAWhC,EAAa+B,GACtDE,EAA4B,GAClC,IAAK,IAAIN,EAAI,EAAGA,EAAIL,EAAQvf,OAAQ4f,IAClCM,EAAgBC,gBAAgB7iB,cAAc0iB,EAAeJ,GAAIL,EAAQK,KAE3E,OAAOM,CACR,CAQgClV,2BAC/BiT,EACA+B,EACAzZ,SAEA,MAAMjI,aAAoBpC,SAASqK,YAAY6Z,cAC7CnC,EACA+B,GAEF,OAAIzZ,EAA0CjI,QAGrBD,EACvBC,EACA0F,KAAK3H,gBACL2H,KAAK7H,eAAL8O,EAAa7P,iBACb4I,KAAK9H,SAASkkB,cACdnC,EACA+B,EAGH,QC3CUK,GAOXvc,YAAYwc,QANLA,mBAOLtc,KAAKsc,YAAcA,CACpB,CAOmBtV,cAACuV,EAAaC,GAChC,MAAMC,EAAOzc,KAAKsc,YAAc,4BAA8BC,EAC9D,IACE,MAAMne,QAAiBf,EAAMof,EAAM,CACjCnf,OAAQ,MACRC,QAAS,CAAE,eAAgB,oBAC3Bif,WAGF,GAAIpe,EAASc,GAEX,aADkBd,EAASse,OAG3B,UAAUvd,MAAM,mCAAqCf,EAASwJ,OAKjE,CAHC,MAAOtM,GAEP,MADAwF,EAAeJ,MAAMpF,OACX6D,MAAM,sBACjB,CACF,CASuB6H,kBACtBuV,EACAI,EACAH,GAEA,IAAII,EAAQ,EACZ,EAAG,CACD,IACE,MAAMH,EAAOzc,KAAKsc,YAAc,4BAA8BC,EACxDne,QAAiBf,EAAMof,EAAM,CACjCnf,OAAQ,MACRC,QAAS,CAAE,eAAgB,oBAC3Bif,WAEF,GAAIpe,EAASc,GAAI,CACf,MAAM2d,QAAYze,EAASse,OAC3B,IAAIC,SAGUE,EADZ,GAAIA,EAAIziB,OAASyiB,EAAIziB,MAAMuiB,OAASA,EAAM,OAAOE,CAEpD,EACD,MAAOvhB,UAGHkE,EAAM,MACZod,GACD,OAAQA,EAAQ,KACjB,WACD,CAQoB5V,eAAC6V,EAAUL,GAC9B,MAAM5U,EAA2B,CAC/BkV,OAAO,GAET,IAAIC,EACJ,IACE,MAAMN,EAAOzc,KAAKsc,YAAc,oCAE1Ble,QAAiBf,EAAMof,EAAM,CACjCnf,OAAQ,OACRoB,KAAM2I,KAAKC,UAAUuV,GACrBtf,QAAS,CAAE,eAAgB,4BAC3Bif,WAGFO,QAAqB3e,EAASse,OACN,MAApBte,EAASwJ,QACXA,EAAOkV,OAAQ,EACflV,EAAOoV,KAAOD,EAAaC,KAC3BpV,EAAOqV,MAAQ,CACbC,iBAAkBH,EAAaI,UAC/Brb,EAAGib,EAAajb,EAAE,GAClBE,EAAG+a,EAAa/a,EAAE,GAClBC,EAAG8a,EAAa9a,KAGlB2F,EAAOwV,OAASL,EAChBjc,EAAeJ,MAAM,4BAA6BtC,EAASwJ,OAAQA,EAAOwV,QAI7E,CAFC,MAAO1c,GACPI,EAAeJ,MAAM,8BAA+BA,EACrD,CACD,OAAOkH,CACR,CAQ4BZ,uBAACuV,EAAaC,GACzC,MAAMC,EAAOzc,KAAKsc,YAAc,iCAAmCC,EAEnE,IACE,MAAMne,QAAiBf,EAAMof,EAAM,CACjCnf,OAAQ,MACRC,QAAS,CACP,eAAgB,oBAElBif,WAGF,GAAIpe,EAASc,GACX,OAAOd,EAASse,OAEhB,UAAUvd,MACR,4BAA8Bf,EAASwJ,OAASxJ,EAASif,WAM9D,CAHC,MAAO3c,GAEP,MADAI,EAAeJ,MAAM,2BAA4BA,OACvCvB,MAAM,2BAA6BuB,EAC9C,CACF,CAQuBsG,kBAACsW,EAAoBd,GAC3C,MAAMC,EAAOzc,KAAKsc,YAAc,6BAEhC,IACE,MAAMle,QAAiBf,EAAMof,EAAM,CACjCnf,OAAQ,OACRoB,KAAM2I,KAAKC,UAAUgW,GACrB/f,QAAS,CACP,eAAgB,oBAElBif,WAGF,GAAIpe,EAASc,GACX,OAAOd,EAASse,OAEhB,UAAUvd,MAAM,uBAAyBf,EAASwJ,OAASxJ,EAASif,WAKvE,CAHC,MAAO3c,GAEP,MADAI,EAAeJ,MAAM,4BAA6BA,OACxCvB,MAAM,4BAA8BuB,EAC/C,CACF,QCtKU6c,GAMOvW,mBAACrR,GACjB,IACE,MAAM6nB,aAAuBrK,QAAQxd,GACrC,aAAa6nB,EAAUd,MAIxB,CAHC,MAAOphB,GAEP,MADAwF,EAAeJ,MAAM,wCAAyCpF,OACpD6D,MAAM,uCACjB,CACF,CAQDse,eACEC,EACAC,GAEA,OAAKD,EACEA,EAAkB9W,KAAM5E,GAAMA,EAAE2b,cAAgBA,OACxD,CAQ+B3W,0BAAC4W,EAA0BJ,GACzD,MAAMK,EAAsC,GAC5C,IAAK,MAAMjC,KAAK4B,EAAUK,iBAMxBA,EAAiB1B,KALiB,CAChCwB,YAAa/B,EACbte,OAAQkgB,EAAUK,iBAAiBjC,GAAG,GACtCkC,QAASF,EAAmBJ,EAAUK,iBAAiBjC,GAAG,KAI9D,OAAOiC,CACR,CAWoB7W,eACnBrR,EACAooB,EACAvB,EACAwB,EACAH,GAEKG,IACHA,aAA+BC,aAAatoB,IAEzCkoB,IACHA,aAA8BK,oBAAoBvoB,EAAaqoB,IAEjE,MAAMvB,EAAOzc,KAAKyd,eAAeI,EAAkB,SAC/C7d,KAAKyd,eAAeI,EAAkB,SAASC,QAC/C,KACJ,IAAKrB,EAAM,YACX,IACE,MAAMre,QAAiBf,EAAMof,kBAAuBsB,IAAmB,CACrEzgB,OAAQ,MACRC,QAAS,CAAE,eAAgB,oBAC3Bif,WAEF,aAAcpe,EAASse,QAAQyB,MAAMrlB,UAItC,CAHC,MAAOwC,GAEP,MADAwF,EAAeJ,MAAMpF,OACX6D,MAAM,uCACjB,CACF,CAQ+B6H,0BAAC3O,EAAgBmJ,GAI/C,MAAM4c,EAAkBzlB,EAAOc,MAAM4kB,kBACnC,CAAC,SACD,CAAC1lB,EAAOc,MAAMsZ,QAAQpa,EAAOc,MAAMuZ,YAAYxR,MAE3CC,EAAmB9I,EAAOc,MAAMiI,SAAS0c,GAE/C,OAAgB,aADM/lB,EAAOimB,mBAEbjmB,EAAmCuJ,mBAC/CH,SAGSpJ,EAAOkmB,YAAY9c,EACjC,CAUmBuF,cAClB/J,EACArG,EACAjB,EACA6mB,GAEA,MAAMwB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEIvB,GACHzc,KAAKyd,eAAeI,EAAkB,WACnC7d,KAAKyd,eAAeI,EAAkB,WAAWC,QACjD,kBAAoBlnB,IAC1B,IAAK6lB,EAAM,YACX,IACE,MAAMre,QAAiBf,EAAMof,EAAM,CACjCnf,OAAQ,OACRoB,KAAM2I,KAAKC,UAAUrK,GACrBM,QAAS,CAAE,eAAgB,4BAC3Bif,WAEF,aAAape,EAASogB,MAIvB,CAHC,MAAOljB,GAEP,MADAwF,EAAeJ,MAAMpF,OACX6D,MAAM,uCACjB,CACF,CAWyB6H,oBACxBuV,EACA5Y,EACAhO,EACA8oB,GAAwB,EACxBjC,SAEA,MAAMwB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEIxjB,EAAO,CAAE+hB,MAAK5Y,YAAW+a,SAAUD,GACnCE,EAAoB,GACpBlC,EAAOzc,KAAKyd,eAAeI,EAAkB,YAC/C7d,KAAKyd,eAAeI,EAAkB,YAAYC,QAClD,KACJ,IAAKrB,EAAM,YACX,IAAIre,EACJ,IACEA,QAAiBf,EAAMof,EAAM,CAC3Bnf,OAAQ,OACRoB,KAAM2I,KAAKC,UAAU9M,GACrB+C,QAAS,CAAE,eAAgB,oBAC3Bif,UAMH,CAJC,MAAOlhB,GAGP,MAFAwF,EAAeJ,MAAM,2BACrBI,EAAeJ,MAAMpF,OACX6D,MAAM7D,EACjB,CACD,YAAI8C,IAAAwgB,EAAU1f,GAAI,CAChB,MAAM2f,QAA4BzgB,EAASse,OAC3C,IAAK,MAAMzZ,KAAU4b,EACnBF,EAAMxC,KAAKlZ,GAEb,OAAO0b,CACR,CACD,MAAMG,QAAyB1gB,EAASse,OAOxC,MANA5b,EAAeJ,MACb,0BACAtC,EAASwJ,OACTxJ,EAASif,WACTyB,OAEQ3f,MAAMkI,KAAKC,UAAUwX,GAChC,CAWuB9X,kBACtB+X,EACAppB,EACA8oB,GAAwB,EACxBjC,EACAjf,SAEA,MAAMygB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEIxjB,OAAYukB,GAAMxhB,UAASmhB,SAAUD,IACrCE,EAAoB,GACpBlC,EAAOzc,KAAKyd,eAAeI,EAAkB,YAC/C7d,KAAKyd,eAAeI,EAAkB,YAAYC,QAClD,KACJ,IAAKrB,EAAM,YACX,IAAIre,EACJ,IACEA,QAAiBf,EAAMof,EAAM,CAC3Bnf,OAAQ,OACRoB,KAAM2I,KAAKC,UAAU9M,GACrB+C,QAAS,CAAE,eAAgB,oBAC3Bif,UAMH,CAJC,MAAOlhB,GAGP,MAFAwF,EAAeJ,MAAM,2BACrBI,EAAeJ,MAAMpF,OACX6D,MAAM7D,EACjB,CACD,YAAI8C,IAAA4gB,EAAU9f,GAAI,CAChB,MAAM2f,QAA4BzgB,EAASse,OAC3C,IAAK,MAAMzZ,KAAU4b,EACnBF,EAAMxC,KAAKlZ,GAEb,OAAO0b,CACR,CACD,MAAMG,QAAyB1gB,EAASse,OAOxC,MANA5b,EAAeJ,MACb,0BACAtC,EAASwJ,OACTxJ,EAASif,WACTyB,OAEQ3f,MAAMkI,KAAKC,UAAUwX,GAChC,CAQkC9X,6BACjCrR,EACA6mB,WAEA,MAAMwB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEIvB,WAAOzc,KAAKyd,eAAeI,EAAkB,+BAAtCoB,EAA8DnB,QAC3E,IAAKrB,EAAM,YACX,IAAIre,EACJ,IACEA,QAAiBf,EAAMof,EAAM,CAC3Bnf,OAAQ,MACRC,QAAS,CAAE,eAAgB,oBAC3Bif,UAMH,CAJC,MAAOlhB,GAGP,MAFAwF,EAAeJ,MAAM,8BACrBI,EAAeJ,MAAMpF,OACX6D,MAAM7D,EACjB,CACD,YAAI8C,IAAA8gB,EAAUhgB,GAAI,CAChB,MAAM+D,EAAS7E,EAASse,OACxB,OAAIyC,MAAMC,QAAQnc,GAET,CAAE,CADqB+a,EAAkBpnB,SACtBqM,GAErBA,CACR,CACD,MAAM6b,QAAyB1gB,EAASse,OAOxC,MANA5b,EAAeJ,MACb,6BACAtC,EAASwJ,OACTxJ,EAASif,WACTyB,OAEQ3f,MAAMkI,KAAKC,UAAUwX,GAChC,CAesB9X,iBACrBuV,EACA5Y,EACA0b,EACAtB,EACApoB,EACA6mB,EACA8C,EACAC,EACAC,SAEA,MAAMxB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEF,IAaI5f,EAbAqhB,EAAgBzf,KAAKyd,eAAeI,EAAkB,cACtD7d,KAAKyd,eAAeI,EAAkB,cAAcC,QACpD,KAEJ,IAAK2B,EAAe,YACpBA,kBAAgClD,IAChCkD,iBAA+B9b,IAC/B8b,iBAA+BJ,IAC/BI,uBAAqC1B,IACjCuB,IACFG,GAAiB,aAAeC,UAAUrY,KAAKC,UAAUgY,KACvDC,IAAYE,GAAiB,gBAAkBC,UAAUH,IACzDC,IAAYC,GAAiB,eAAiBD,GAElD,IACEphB,QAAiBf,EAAMoiB,EAAe,CACpCniB,OAAQ,MACRC,QAAS,CAAE,eAAgB,oBAC3Bif,UAMH,CAJC,MAAOlhB,GAGP,MAFAwF,EAAeJ,MAAM,iCACrBI,EAAeJ,MAAMpF,OACX6D,yCAAyCsgB,KACpD,CACD,YAAIrhB,IAAAuhB,EAAUzgB,GAEZ,aAD0Cd,EAASse,OAGrD,MAAMoC,QAAyB1gB,EAASse,OAOxC,MANA5b,EAAeJ,MACb,gCACAtC,EAASwJ,OACTxJ,EAASif,WACTyB,OAEQ3f,MAAMkI,KAAKC,UAAUwX,GAChC,CAY6B9X,wBAC5B4Y,EACAlc,EACA6b,EACAC,EACA7pB,EACAkqB,EACArD,SAEA,MAAMwB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEI8B,EAAe,CACnBtc,SAAUoc,EACVlc,YACAqc,QAAS,CAAEzZ,IAAKiZ,EAAYC,cAC5BzB,gBAAiB8B,GAEbJ,EAAgBzf,KAAKyd,eAAeI,EAAkB,qBACxD7d,KAAKyd,eAAeI,EAAkB,qBAAqBC,QAC3D,KACJ,IAAK2B,EAAe,YACpB,IAAIrhB,EACJ,IACEA,QAAiBf,EAAMoiB,EAAe,CACpCniB,OAAQ,OACRoB,KAAM2I,KAAKC,UAAUwY,GACrBviB,QAAS,CAAE,eAAgB,oBAC3Bif,UAMH,CAJC,MAAOlhB,GAGP,MAFAwF,EAAeJ,MAAM,+BACrBI,EAAeJ,MAAMpF,OACX6D,MAAM,mCACjB,CACD,YAAIf,IAAA4hB,EAAU9gB,GAEZ,aADqBd,EAASse,OAGhC,MAAMoC,QAAyB1gB,EAASse,OAQxC,MAPA5b,EAAeJ,MACb,8BACAtC,EAASwJ,OACTxJ,EAASif,WACTyB,GAEFhe,EAAeJ,MAAM,eAAgBof,OAC3B3gB,MAAMkI,KAAKC,UAAUwX,GAChC,CAa0B9X,qBACzBuV,EACA5Y,EACA0b,EACA/a,EACA3O,EACA0C,EACAinB,GAEA,MAAMtB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEIiC,EAAcjgB,KAAKyd,eAAeI,EAAkB,YACtD7d,KAAKyd,eAAeI,EAAkB,YAAYC,QAClD,KACJ,IAAKmC,EAAa,YAClB,MAAM9B,EAAQ+B,KAAKC,MACbC,aAAuBC,oBAAoBhoB,EAAQkkB,EAAM4B,GAC/D,IAAImC,EAAaL,EAUjB,OATAK,iBAA4BjB,IAC5BiB,kBAA6B/D,IAC7B+D,oBAA+Bhc,IAC/Bgc,iBAA4B3c,IAC5B2c,6BAAwCjoB,EAAOyE,eAC/CwjB,aAAwBnC,IACxBmC,iBAA4BF,IACxBd,IACFgB,GAAc,aAAeZ,UAAUrY,KAAKC,UAAUgY,KACjDgB,CACR,CAawBtZ,mBACvBrR,EACA6f,EACA+J,EACAgB,EACA7c,EACA8Y,EACAgE,EACApb,SAEA,MAAM4Y,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEIyC,EAAkBzgB,KAAKyd,eAAeI,EAAkB,gBAC1D7d,KAAKyd,eAAeI,EAAkB,gBAAgBC,QACtD,KAEEK,EAAQ+B,KAAKC,MACnB,IAAIO,QAAyBlL,EAAS1Y,aACtC4jB,GAAoBH,EAAQnc,WAC5Bsc,GAAoBvC,EACpB,MAAMiC,aAAuBC,oBAAoB7K,EAAUkL,GACrDC,EAAUpb,SAShB,GARAob,EAAQ5C,sBAAwBvI,EAAS1Y,aACzC6jB,EAAQP,UAAYA,EACpBO,EAAQxC,MAAQA,EAChBwC,EAAQC,YAAcrB,EACtBoB,EAAQJ,QAAUA,EAClBI,EAAQjd,UAAYA,EAChBid,EAAQH,qBAAoBG,EAAQH,mBAAqBA,GACzDpb,IAAQub,EAAQvb,OAASA,IACxBqb,EAAiB,YACtB,IAAIriB,EACJ,IACEA,QAAiBf,EAAMojB,EAAiB,CACtCnjB,OAAQ,OACRoB,KAAM2I,KAAKC,UAAUqZ,GACrBpjB,QAAS,CAAE,eAAgB,oBAC3Bif,UAOH,CALC,MAAOlhB,GAIP,MAHAwF,EAAeJ,MAAM,yBACrBI,EAAeJ,MAAMpF,GACrBwF,EAAeJ,MAAM,eAAgBigB,OAC3BxhB,MAAM,uCACjB,CACD,gBAAIf,IAAAyiB,EAAU3hB,SACSd,EAASse,QAGhC5b,EAAeJ,MACb,yBACAtC,EAASwJ,OACTxJ,EAASif,iBACHjf,EAASse,QAEjB5b,EAAeJ,MAAM,eAAgBigB,QAEtC,CAWuB3Z,kBACtBuV,EACAwB,EACA+C,EACAnrB,EACA0C,EACAmkB,SAEA,MAAMwB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEI+C,EAAiB/gB,KAAKyd,eAAeI,EAAkB,eACzD7d,KAAKyd,eAAeI,EAAkB,eAAeC,QACrD,KAEEK,aAAmB6C,SACvBrrB,EACAooB,EACAvB,EACAwB,EACAH,GAGF,IAAI6C,EAAmB3C,EACvB2C,GAAoBI,GAAS,GAC7BJ,GAAqBnE,MAAUvc,KAAKihB,QAAQ1E,MAAW,GACvDmE,GAAoBvC,EACpB,MAAMiC,aAAuBC,oBAAoBhoB,EAAQqoB,GACnDC,EAAUpb,SAMhB,GALAob,EAAQP,UAAYA,EACpBO,EAAQvc,WAAapE,KAAKihB,QAAQ1E,GAClCoE,EAAQ5C,gBAAkBA,EACtB+C,IAAOH,EAAQG,MAAQA,IAEtBC,EAAgB,YACrB,IAAI3iB,EACJ,IACEA,QAAiBf,EAAM0jB,EAAgB,CACrCzjB,OAAQ,MACRoB,KAAM2I,KAAKC,UAAUqZ,GACrBpjB,QAAS,CAAE,eAAgB,oBAC3Bif,UAOH,CALC,MAAOlhB,GAIP,MAHAwF,EAAeJ,MAAM,wBACrBI,EAAeJ,MAAMpF,GACrBwF,EAAeJ,MAAM,eAAgBigB,OAC3BxhB,MAAM,uCACjB,CAED,YAAIf,IAAA8iB,EAAUhiB,GAEZ,aADqBd,EAASse,OAGhC,MAAMoC,QAAyB1gB,EAASse,OAQxC,MAPA5b,EAAeJ,MACb,wBACAtC,EAASwJ,OACTxJ,EAASif,WACTyB,GAEFhe,EAAeJ,MAAM,eAAgBigB,OAC3BxhB,MAAMkI,KAAKC,UAAUwX,GAChC,CAUyB9X,oBACxBrR,EACAooB,EACA+C,EACAvE,EACAC,WAEA,MAAMwB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEImD,EAAmBnhB,KAAKyd,eAAeI,EAAkB,iBAC3D7d,KAAKyd,eAAeI,EAAkB,iBAAiBC,QACvD,KAEJ,IAKI1f,EALAjB,sBAA0B4gB,IAI9B,GAHA5gB,GAAQof,kBAAsBvc,KAAKihB,QAAQ1E,MAAW,GACtDpf,GAAQ2jB,aAAmBA,KAAY,IAElCK,EAAkB,YAEvB,IACE/iB,QAAiBf,EAAM8jB,EAAmBhkB,EAAK,CAC7CG,OAAQ,MACRC,QAAS,CAAE,eAAgB,oBAC3Bif,UAMH,CAJC,MAAOlhB,GAGP,MAFAwF,EAAeJ,MAAM,6BACrBI,EAAeJ,MAAMpF,OACX6D,MAAM7D,EACjB,CACD,YAAI8C,IAAAgjB,EAAUliB,GAEZ,aADqBd,EAASse,OAQhC,GALA5b,EAAeJ,MACb,6BACAtC,EAASwJ,OACTxJ,EAASif,qBAEPjf,IAAAijB,EAAUniB,GAEZ,aADqBd,EAASse,OAGhC,MAAMoC,QAAyB1gB,EAASse,OAOxC,MANA5b,EAAeJ,MACb,6BACAtC,EAASwJ,OACTxJ,EAASif,WACTyB,OAEQ3f,MAAMkI,KAAKC,UAAUwX,GAChC,CAS+B9X,0BAC9BrR,EACA6f,EACAsL,EACA7hB,GAEA,MAAM+e,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEIsD,EAAmBthB,KAAKyd,eAAeI,EAAkB,iBAC3D7d,KAAKyd,eAAeI,EAAkB,iBAAiBC,QACvD,KAEEK,EAAQ+B,KAAKC,MACnB,IAAIO,QAAyBlL,EAAS1Y,aACtC4jB,GAAoBI,EACpBJ,GAAoBzhB,EAAMnG,WAC1B4nB,GAAoBvC,EACpB,MAAMiC,aAAuBC,oBAAoB7K,EAAUkL,GAC3D,IAAKY,EAAkB,YACvB,IAAIC,EAAYD,EAMhB,OALAC,6BAAuC/L,EAAS1Y,eAChDykB,aAAuBT,IACvBS,aAAuBtiB,EAAMnG,aAC7ByoB,aAAuBpD,IACvBoD,GAAcnB,iBAA2BA,KAAgB,GAClDmB,CACR,CAUyBva,oBACxBuV,EACA/G,EACAsL,EACAnrB,EACA6mB,SAEA,MAAMwB,aAA+BC,aAAatoB,GAC5CkoB,aAA8BK,oBAClCvoB,EACAqoB,GAEIwD,EAAmBxhB,KAAKyd,eAAeI,EAAkB,iBAC3D7d,KAAKyd,eAAeI,EAAkB,iBAAiBC,QACvD,KAEEK,aAAmB6C,SACvBrrB,QACM6f,EAAS1Y,aACf0f,EACAwB,EACAH,GAGF,IAAI6C,QAAyBlL,EAAS1Y,aACtC4jB,GAAoBI,GAAS,GAC7BJ,GAAqBnE,MAAUvc,KAAKihB,QAAQ1E,MAAW,GACvDmE,GAAoBvC,EACpB,MAAMiC,aAAuBC,oBAAoB7K,EAAUkL,GACrDC,EAAUpb,SAMhB,GALAob,EAAQvc,WAAapE,KAAKihB,QAAQ1E,GAClCoE,EAAQ5C,sBAAwBvI,EAAS1Y,aACzC6jB,EAAQG,MAAQA,EACZV,IAAWO,EAAQP,UAAYA,IAE9BoB,EAAkB,YACvB,IAAIpjB,EACJ,IACEA,QAAiBf,EAAMmkB,EAAkB,CACvClkB,OAAQ,SACRoB,KAAM2I,KAAKC,UAAUqZ,GACrBpjB,QAAS,CAAE,eAAgB,oBAC3Bif,UAOH,CALC,MAAOlhB,GAIP,MAHAwF,EAAeJ,MAAM,8BACrBI,EAAeJ,MAAMpF,GACrBwF,EAAeJ,MAAM,eAAgBigB,OAC3BxhB,MAAM,uCACjB,CACD,YAAIf,IAAAqjB,EAAUviB,GAEZ,aADqBd,EAASse,OAGhC,MAAMoC,QAAyB1gB,EAASse,OAQxC,MAPA5b,EAAeJ,MACb,6BACAtC,EAASwJ,OACTxJ,EAASif,WACTyB,GAEFhe,EAAeJ,MAAM,eAAgBigB,OAC3BxhB,MAAMkI,KAAKC,UAAUwX,GAChC,CAO2B9X,sBAAC7J,EAAaqf,GACxC,IACE,MAAMpe,QAAiBf,EAAMF,EAAK,CAChCG,OAAQ,MACRC,QAAS,CAAE,eAAgB,oBAC3Bif,WAEF,SAAIpe,GAAAA,EAAUc,GAAI,CAChB,MAAMwiB,QAAetjB,EAASse,OAC9B,GAAIgF,IAAWA,EAAOjsB,iBAAmBisB,EAAOC,mBAAoB,QACrE,CACD,QAID,CAHC,MAAOjhB,GAEP,OADAI,EAAeJ,oCAAoCA,EAAMc,aAE1D,CACF,CAOOyf,QAAQW,GACd,YAAYC,iBAAiBD,GAAO,EACrC,CAQOC,iBAAiBD,EAAQ,GAAIE,GACnC,MAAMhF,MAAEA,EAAF1X,OAASA,GAAWpF,KAAK+hB,WAC7BH,EACA,wBACA,oBAEF,OAAQE,GAAchF,EAAQ,KAAO,IAAM1X,CAC5C,CASO2c,WACNH,EACAI,EACAC,GAEA,GAAqB,iBAAVL,EAGT,MAFA9gB,EAAeT,MAAM,qBACrBS,EAAeT,MAAMuhB,OACXziB,UAAU8iB,0CAAsDL,KAE5E,MAAMviB,EAAQuiB,EAAMviB,MAAM2iB,GAC1B,OAAK3iB,EAIE,CAAEyd,OAAO,EAAM1X,OAAQ/F,EAAM,KAHlCyB,EAAeN,SAASyhB,mCACjB,CAAEnF,OAAO,EAAO1X,OAAQwc,GAGlC,CAOoB5a,cAAC7J,GACpB,OAAOE,EAAMF,EAAK,CAChBG,OAAQ,MACRC,QAAS,CACP,eAAgB,qBAGrB,EAGU2kB,MAAAA,GAAmB,IAAI3E"}