{"version":3,"file":"lib.modern.js","sources":["../src/config/Config.ts","../src/utils/Constants.ts","../src/utils/ContractUtils.ts","../src/utils/Logger.ts","../src/utils/DatatokenName.ts","../src/utils/DdoHelpers.ts","../src/utils/FetchHelper.ts","../src/utils/General.ts","../src/utils/minAbi.ts","../src/utils/SignatureUtils.ts","../src/utils/TokenUtils.ts","../src/config/ConfigHelper.ts","../src/contracts/SmartContract.ts","../src/contracts/SmartContractWithAddress.ts","../src/contracts/Dispenser.ts","../src/contracts/FixedRateExchange.ts","../src/contracts/Router.ts","../src/contracts/NFT.ts","../src/contracts/Datatoken.ts","../src/contracts/NFTFactory.ts","../src/contracts/ve/VeOcean.ts","../src/contracts/ve/VeFeeDistributor.ts","../src/contracts/ve/VeFeeEstimate.ts","../src/contracts/ve/VeAllocate.ts","../src/contracts/df/DfRewards.ts","../src/contracts/df/DfStrategyV1.ts","../src/services/Aquarius.ts","../src/services/Provider.ts"],"sourcesContent":["import { AbiItem } from 'web3-utils/types'\nimport { LogLevel } from '../utils'\n\nexport class Config {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public nftFactoryAddress?: string\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, goerli, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  gasFeeMultiplier: number\n\n  veAllocate?: string\n  veOCEAN?: string\n  veDelegation?: string\n  veFeeDistributor?: string\n  veDelegationProxy?: string\n  DFRewards?: string\n  DFStrategyV1?: string\n  veFeeEstimate?: string\n}\n","export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\nexport const MAX_UINT_256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\nexport const FEE_HISTORY_NOT_SUPPORTED =\n  'Returned error: Method eth_feeHistory not supported.'\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { Config } from '../config'\nimport { minAbi, GASLIMIT_DEFAULT, LoggerInstance, FEE_HISTORY_NOT_SUPPORTED } from '.'\nimport { TransactionReceipt } from 'web3-core'\n\nconst MIN_GAS_FEE_POLYGON = 30000000000 // minimum recommended 30 gwei polygon main and mumbai fees\nconst POLYGON_NETWORK_ID = 137\nconst MUMBAI_NETWORK_ID = 80001\n\nexport function setContractDefaults(contract: Contract, config: Config): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  return contract\n}\n\nexport async function getFairGasPrice(\n  web3: Web3,\n  gasFeeMultiplier: number\n): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  if (gasFeeMultiplier)\n    return x\n      .multipliedBy(gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, token)\n  let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n  if (decimals === '0') {\n    decimals = 18\n  }\n\n  const amountFormatted = new BigNumber(amount).div(\n    new BigNumber(10).exponentiatedBy(decimals)\n  )\n\n  BigNumber.config({ EXPONENTIAL_AT: 50 })\n  return amountFormatted.toString()\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, token)\n  let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n  if (decimals === '0') {\n    decimals = 18\n  }\n  BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n  const amountFormatted = new BigNumber(amount).times(\n    new BigNumber(10).exponentiatedBy(decimals)\n  )\n  return amountFormatted.toFixed(0)\n}\n\n/**\n * Estimates the gas used when a function would be executed on chain\n * @param {string} from account that calls the function\n * @param {Function} functionToEstimateGas function that we need to estimate the gas\n * @param {...any[]} args arguments of the function\n * @return {Promise<number>} gas cost of the function\n */\nexport async function calculateEstimatedGas(\n  from: string,\n  functionToEstimateGas: Function,\n  ...args: any[]\n): Promise<number> {\n  const estimatedGas = await functionToEstimateGas\n    .apply(null, args)\n    .estimateGas({ from }, (err, estGas) => (err ? GASLIMIT_DEFAULT : estGas))\n  return estimatedGas\n}\n\n/**\n * Send the transation on chain\n * @param {string} from account that calls the function\n * @param {any} estGas estimated gas for the transaction\n * @param {Web3} web3 web3 objcet\n * @param {Function} functionToSend function that we need to send\n * @param {...any[]} args arguments of the function\n * @return {Promise<any>} transaction receipt\n */\nexport async function sendTx(\n  from: string,\n  estGas: number,\n  web3: Web3,\n  gasFeeMultiplier: number,\n  functionToSend: Function,\n  ...args: any[]\n): Promise<TransactionReceipt> {\n  const sendTxValue: Record<string, any> = {\n    from,\n    gas: estGas + 1\n  }\n  const networkId = await web3.eth.getChainId()\n  try {\n    const feeHistory = await web3.eth.getFeeHistory(1, 'latest', [75])\n    if (feeHistory && feeHistory?.baseFeePerGas?.[0] && feeHistory?.reward?.[0]?.[0]) {\n      let aggressiveFee = new BigNumber(feeHistory?.reward?.[0]?.[0])\n      if (gasFeeMultiplier > 1) {\n        aggressiveFee = aggressiveFee.multipliedBy(gasFeeMultiplier)\n      }\n\n      sendTxValue.maxPriorityFeePerGas = aggressiveFee\n        .integerValue(BigNumber.ROUND_DOWN)\n        .toString(10)\n\n      sendTxValue.maxFeePerGas = aggressiveFee\n        .plus(new BigNumber(feeHistory?.baseFeePerGas?.[0]).multipliedBy(2))\n        .integerValue(BigNumber.ROUND_DOWN)\n        .toString(10)\n\n      // if network is polygon and mumbai and fees is lower than the 30 gwei trashold, sets MIN_GAS_FEE_POLYGON\n      sendTxValue.maxPriorityFeePerGas =\n        (networkId === MUMBAI_NETWORK_ID || networkId === POLYGON_NETWORK_ID) &&\n        new BigNumber(sendTxValue.maxPriorityFeePerGas).lte(\n          new BigNumber(MIN_GAS_FEE_POLYGON)\n        )\n          ? new BigNumber(MIN_GAS_FEE_POLYGON)\n              .integerValue(BigNumber.ROUND_DOWN)\n              .toString(10)\n          : sendTxValue.maxPriorityFeePerGas\n\n      sendTxValue.maxFeePerGas =\n        (networkId === MUMBAI_NETWORK_ID || networkId === POLYGON_NETWORK_ID) &&\n        new BigNumber(sendTxValue.maxFeePerGas).lte(new BigNumber(MIN_GAS_FEE_POLYGON))\n          ? new BigNumber(MIN_GAS_FEE_POLYGON)\n              .integerValue(BigNumber.ROUND_DOWN)\n              .toString(10)\n          : sendTxValue.maxFeePerGas\n    } else {\n      sendTxValue.gasPrice = await getFairGasPrice(web3, gasFeeMultiplier)\n    }\n  } catch (err) {\n    err?.message === FEE_HISTORY_NOT_SUPPORTED &&\n      LoggerInstance.log(\n        'Not able to use EIP 1559, getFeeHistory method not suported by network.'\n      )\n    sendTxValue.gasPrice = await getFairGasPrice(web3, gasFeeMultiplier)\n  }\n\n  const trxReceipt = await functionToSend.apply(null, args).send(sendTxValue)\n  return trxReceipt\n}\n","/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\n","import wordListDefault from './data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\n\nexport function generateDid(nftAddress: string, chainId: number): string {\n  nftAddress = Web3.utils.toChecksumAddress(nftAddress)\n  const checksum = sha256(nftAddress + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  return sha256(data).toString()\n}\n","import fetch from 'cross-fetch'\nimport { DownloadResponse } from '../@types'\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const headResponse = await fetch(url, { method: 'HEAD' })\n  const contentHeader = headResponse.headers.get('content-disposition')\n  const fileName = contentHeader?.split('=')[1] ? contentHeader?.split('=')[1] : 'file'\n  const xhr = new XMLHttpRequest()\n  xhr.responseType = 'blob'\n  xhr.open('GET', url)\n  xhr.onload = () => {\n    const blobURL = window.URL.createObjectURL(xhr.response)\n    const a = document.createElement('a')\n    a.href = blobURL\n    a.setAttribute('download', fileName)\n    document.body.appendChild(a)\n    a.click()\n    a.remove()\n    window.URL.revokeObjectURL(blobURL)\n  }\n  xhr.send(null)\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","import Web3 from 'web3'\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n","import Decimal from 'decimal.js'\nimport Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport {\n  amountToUnits,\n  calculateEstimatedGas,\n  unitsToAmount,\n  minAbi,\n  sendTx,\n  LoggerInstance\n} from '.'\nimport { Config } from '../config'\nimport { ReceiptOrEstimate } from '../@types'\n\n/**\n * Approve spender to spent amount tokens\n * @param {Web3} web3\n * @param {Config} config\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 Datatokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {boolean} estimateGas  if true, returns the estimate gas cost for calling the method\n */\nexport async function approve<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  tokenDecimals?: number,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowance(web3, tokenAddress, account, spender)\n    if (new Decimal(currentAllowence).greaterThanOrEqualTo(new Decimal(amount))) {\n      return <ReceiptOrEstimate<G>>new Decimal(currentAllowence).toNumber()\n    }\n  }\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount, tokenDecimals)\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amountFormatted\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  const trxReceipt = await sendTx(\n    account,\n    estGas + 1,\n    web3,\n    config?.gasFeeMultiplier,\n    tokenContract.methods.approve,\n    spender,\n    amountFormatted\n  )\n  return <ReceiptOrEstimate<G>>trxReceipt\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {Web3} web3\n * @param {Config} config\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 tokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {boolean} estimateGas  if true, returns the estimate gas cost for calling the method\n */\nexport async function approveWei<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowanceWei(web3, tokenAddress, account, spender)\n    if (new BigNumber(currentAllowence).gt(new BigNumber(amount))) {\n      return <ReceiptOrEstimate<G>>new Decimal(currentAllowence).toNumber()\n    }\n  }\n  let result = null\n\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amount\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  try {\n    result = await sendTx(\n      account,\n      estGas + 1,\n      web3,\n      config?.gasFeeMultiplier,\n      tokenContract.methods.approve,\n      spender,\n      amount\n    )\n  } catch (e) {\n    LoggerInstance.error(\n      `ERROR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Moves amount tokens from the callerâ€™s account to recipient.\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} recipient\n * @param {String} amount amount of ERC20 Datatokens (not as wei)\n * @param {String} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function transfer<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  recipient: string,\n  amount: string,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount)\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.transfer,\n    recipient,\n    amountFormatted\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  const trxReceipt = await sendTx(\n    account,\n    estGas + 1,\n    web3,\n    config?.gasFeeMultiplier,\n    tokenContract.methods.transfer,\n    recipient,\n    amountFormatted\n  )\n  return <ReceiptOrEstimate<G>>trxReceipt\n}\n\n/**\n * Get Allowance for any Datatoken\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get balance for any Datatoken\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} account\n * @param {String} spender\n */\nexport async function allowanceWei(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.allowance(account, spender).call()\n}\n\n/**\n * Get decimals for any Datatoken\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @return {Promise<number>} Number of decimals of the token\n */\nexport async function decimals(web3: Web3, tokenAddress: string): Promise<number> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.decimals().call()\n}\n","// eslint-disable-next-line import/no-named-default\n// import { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport { Config } from '.'\nimport { LoggerInstance } from '../utils'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '../../address.json'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'https://v4.provider.oceanprotocol.com',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://172.15.0.5:5000', // use http://127.0.0.1:5000/ if running on macOS\n    providerUri: 'http://172.15.0.4:8030', // use http://127.0.0.1:8030/ if running on macOS\n    subgraphUri: 'https://172.15.0.15:8000' // use http://127.0.0.1:9000/ if running on macOS\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 5,\n    network: 'goerli',\n    nodeUri: 'https://goerli.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://goerli.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN',\n    gasFeeMultiplier: 1.6\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 81001,\n    network: 'polygonedge',\n    nodeUri: 'https://rpc-edgenet.polygon.technology',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://explorer-edgenet.polygon.technology/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      const {\n        FixedPrice,\n        Dispenser,\n        ERC721Factory,\n        OPFCommunityFeeCollector,\n        Ocean,\n        chainId,\n        startBlock,\n        veAllocate,\n        veOCEAN,\n        veDelegation,\n        veFeeDistributor,\n        veDelegationProxy,\n        DFRewards,\n        DFStrategyV1,\n        veFeeEstimate\n      } = customAddresses[network]\n      configAddresses = {\n        nftFactoryAddress: ERC721Factory,\n        opfCommunityFeeCollector: OPFCommunityFeeCollector,\n        fixedRateExchangeAddress: FixedPrice,\n        dispenserAddress: Dispenser,\n        oceanTokenAddress: Ocean,\n        chainId,\n        startBlock,\n        veAllocate,\n        veOCEAN,\n        veDelegation,\n        veFeeDistributor,\n        veDelegationProxy,\n        DFRewards,\n        DFStrategyV1,\n        veFeeEstimate,\n        ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock,\n          veAllocate,\n          veOCEAN,\n          veDelegation,\n          veFeeDistributor,\n          veDelegationProxy,\n          DFRewards,\n          DFStrategyV1,\n          veFeeEstimate\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          nftFactoryAddress: ERC721Factory,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId,\n          startBlock,\n          veAllocate,\n          veOCEAN,\n          veDelegation,\n          veFeeDistributor,\n          veDelegationProxy,\n          DFRewards,\n          DFStrategyV1,\n          veFeeEstimate,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n\n    if (!config) {\n      LoggerInstance.error(\n        `No config found for given network '${network}' filter by '${filterBy}'`\n      )\n      return null\n    }\n\n    LoggerInstance.debug(\n      `getConfig getAddressesFromEnv after filter by '${filterBy}' to network'${config?.network}'`\n    )\n    const contractAddressesConfig = this.getAddressesFromEnv(config.network)\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import Web3 from 'web3'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils'\nimport { Config, ConfigHelper } from '../config'\nimport {\n  amountToUnits,\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount\n} from '../utils'\n\nexport abstract class SmartContract {\n  public web3: Web3\n  public config: Config\n  public abi: AbiItem | AbiItem[]\n\n  abstract getDefaultAbi(): AbiItem | AbiItem[]\n\n  /**\n   * Instantiate the smart contract.\n   * @param {Web3} web3\n   * @param {string | number} network Network id or name\n   * @param {Config} config Configutation of the smart contract\n   * @param {AbiItem | AbiItem[]} abi ABI of the smart contract\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[]\n  ) {\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.abi = abi || (this.getDefaultAbi() as AbiItem[])\n  }\n\n  protected async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  protected async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  protected async getFairGasPrice(): Promise<string> {\n    return getFairGasPrice(this.web3, this.config?.gasFeeMultiplier)\n  }\n\n  protected getContract(\n    address: string,\n    account?: string,\n    abi?: AbiItem | AbiItem[]\n  ): Contract {\n    const contract = new this.web3.eth.Contract(abi || this.abi, address, {\n      from: account\n    })\n    return setContractDefaults(contract, this.config)\n  }\n}\n","import Web3 from 'web3'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils'\nimport { Config } from '../config'\nimport { SmartContract } from './SmartContract'\n\nexport abstract class SmartContractWithAddress extends SmartContract {\n  public address: string\n  public contract: Contract\n\n  /**\n   * Instantiate the smart contract.\n   * @param {string} address Address of the smart contract\n   * @param {Web3} web3\n   * @param {string | number} network Network id or name\n   * @param {Config} config Configutation of the smart contract\n   * @param {AbiItem | AbiItem[]} abi ABI of the smart contract\n   */\n  constructor(\n    address: string,\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[]\n  ) {\n    super(web3, network, config, abi)\n    this.address = address\n    this.contract = this.getContract(this.address)\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport Decimal from 'decimal.js'\nimport DispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport { calculateEstimatedGas, sendTx } from '../utils'\nimport { Datatoken } from './Datatoken'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\nimport { DispenserToken, ReceiptOrEstimate } from '../@types'\n\nexport class Dispenser extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return DispenserAbi.abi as AbiItem[]\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    const status: DispenserToken = await this.contract.methods.status(dtAdress).call()\n    if (!status) {\n      throw new Error(`Np dispenser found for the given datatoken address`)\n    }\n    status.maxTokens = this.web3.utils.fromWei(status.maxTokens)\n    status.maxBalance = this.web3.utils.fromWei(status.maxBalance)\n    status.balance = this.web3.utils.fromWei(status.balance)\n    return status\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async create<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Call createFixedRate contract method\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async activate<G extends boolean = false>(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.activate,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.activate,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async deactivate<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.deactivate,\n      dtAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deactivate,\n      dtAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async setAllowedSwapper<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async dispense<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async ownerWithdraw<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.ownerWithdraw,\n      dtAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.ownerWithdraw,\n      dtAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import FixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { AbiItem } from 'web3-utils/types'\nimport { calculateEstimatedGas, sendTx, ZERO_ADDRESS } from '../utils'\nimport { PriceAndFees, FeesInfo, FixedPriceExchange, ReceiptOrEstimate } from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\nexport class FixedRateExchange extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return FixedRateExchangeAbi.abi as AbiItem[]\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.contract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async buyDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0',\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const maxBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      maxBaseTokenAmount,\n      +exchange.btDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sell datatokenAmount while expecting at least minBaseTokenAmount\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async sellDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0',\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const minBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      minBaseTokenAmount,\n      +exchange.btDecimals\n    )\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.contract.methods.getNumberOfExchanges().call()\n    return numExchanges\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setRate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newRate: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setRate,\n      exchangeId,\n      this.web3.utils.toWei(newRate)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setRate,\n      exchangeId,\n      this.web3.utils.toWei(newRate)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sets a new allowedSwapper\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setAllowedSwapper<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async activate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async deactivate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.contract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDatatokenSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.contract.methods.getDTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.datatoken, dtSupply, +exchange.dtDecimals)\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBasetokenSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.contract.methods.getBTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.baseToken, btSupply, +exchange.btDecimals)\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.contract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenDatatokensOut - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenDatatokensOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const outDT = await this.contract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(\n          fixedRateExchange.datatoken,\n          datatokenAmount,\n          +fixedRateExchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.baseTokenAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      marketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.marketFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      oceanFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.oceanFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      consumeMarketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.consumeMarketFeeAmount,\n        +fixedRateExchange.btDecimals\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBasetokensOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const amount = await this.contract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(\n          exchange.datatoken,\n          datatokenAmount,\n          +exchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(exchange.baseToken, amount[0], +exchange.btDecimals)\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const exchange: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    exchange.dtDecimals = exchange.dtDecimals.toString()\n    exchange.btDecimals = exchange.btDecimals.toString()\n    exchange.dtBalance = await this.unitsToAmount(\n      exchange.datatoken,\n      exchange.dtBalance,\n      +exchange.dtDecimals\n    )\n    exchange.btBalance = await this.unitsToAmount(\n      exchange.baseToken,\n      exchange.btBalance,\n      +exchange.btDecimals\n    )\n    exchange.dtSupply = await this.unitsToAmount(\n      exchange.datatoken,\n      exchange.dtSupply,\n      +exchange.dtDecimals\n    )\n    exchange.btSupply = await this.unitsToAmount(\n      exchange.baseToken,\n      exchange.btSupply,\n      +exchange.btDecimals\n    )\n    exchange.fixedRate = this.web3.utils.fromWei(exchange.fixedRate)\n    exchange.exchangeId = exchangeId\n    return exchange\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const feesInfo: FeesInfo = await this.contract.methods.getFeesInfo(exchangeId).call()\n    feesInfo.opcFee = this.web3.utils.fromWei(feesInfo.opcFee.toString())\n    feesInfo.marketFee = this.web3.utils.fromWei(feesInfo.marketFee.toString())\n\n    const exchange = await this.getExchange(exchangeId)\n    feesInfo.marketFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      feesInfo.marketFeeAvailable,\n      +exchange.btDecimals\n    )\n    feesInfo.oceanFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      feesInfo.oceanFeeAvailable,\n      +exchange.btDecimals\n    )\n\n    feesInfo.exchangeId = exchangeId\n    return feesInfo\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.contract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const active = await this.contract.methods.isActive(exchangeId).call()\n    return active\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async activateMint<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      true\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      true\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async deactivateMint<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      false\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      false\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to Datatoken.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectBasetokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectBT,\n      exchangeId,\n      amountWei\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectBT,\n      exchangeId,\n      amountWei\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to Datatoken.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectDT,\n      exchangeId,\n      amountWei\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectDT,\n      exchangeId,\n      amountWei\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectMarketFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectMarketFee,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectMarketFee,\n      exchangeId\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectOceanFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectOceanFee,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectOceanFee,\n      exchangeId\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    const address = await this.contract.methods.opcCollector().call()\n    return address\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  public async getRouter(): Promise<string> {\n    const address = await this.contract.methods.router().call()\n    return address\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    const address = await (await this.getExchange(exchangeId)).exchangeOwner\n    return address\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async updateMarketFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateMarketFee,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateMarketFee,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async updateMarketFeeCollector<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport FactoryRouter from '@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json'\nimport { calculateEstimatedGas, sendTx } from '../utils'\nimport { Operation, ReceiptOrEstimate } from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\n/**\n * Provides an interface for FactoryRouter contract\n */\nexport class Router extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return FactoryRouter.abi as AbiItem[]\n  }\n\n  /**\n   * buyDatatokenBatch\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<ReceiptOrEstimate>} Transaction receipt\n   */\n  public async buyDatatokenBatch<G extends boolean = false>(\n    address: string,\n    operations: Operation[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.buyDTBatch,\n      operations\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.buyDTBatch,\n      operations\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Check if a token is on approved tokens list, if true opfFee is lower in pools with that token/DT\n   * @return {Promise<boolean>} true if is on the list.\n   */\n  public async isApprovedToken(address: string): Promise<boolean> {\n    return await this.contract.methods.isApprovedToken(address).call()\n  }\n\n  /** Check if an address is a Fixed Rate contract.\n   * @return {Promise<boolean>} true if is a Fixed Rate contract\n   */\n  public async isFixedPrice(address: string): Promise<boolean> {\n    return await this.contract.methods.isFixedRateContract(address).call()\n  }\n\n  /** Get Router Owner\n   * @return {Promise<string>} Router Owner address\n   */\n  public async getOwner(): Promise<string> {\n    return await this.contract.methods.routerOwner().call()\n  }\n\n  /** Get NFT Factory address\n   * @return {Promise<string>} NFT Factory address\n   */\n  public async getNFTFactory(): Promise<string> {\n    return await this.contract.methods.factory().call()\n  }\n\n  /**\n   * Adds a token to the list of tokens with reduced fees\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addApprovedToken<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addApprovedToken,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addApprovedToken,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes a token if exists from the list of tokens with reduced fees\n   * @param {String} address\n   * @param {String} tokenAddress address to remove\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeApprovedToken<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeApprovedToken,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeApprovedToken,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Adds an address to the list of fixed rate contracts\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addFixedRateContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addFixedRateContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addFixedRateContract,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes an address from the list of fixed rate contracts\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeFixedRateContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeFixedRateContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeFixedRateContract,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Adds an address to the list of dispensers\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addDispenserContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addDispenserContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addDispenserContract,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes an address from the list of dispensers\n   * @param {String} address\n   * @param {String} tokenAddress address Contract to be removed\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeDispenserContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeDispenserContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeDispenserContract,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get OPF Fee per token\n   * @return {Promise<number>} OPC fee for a specific baseToken\n   */\n  public async getOPCFee(baseToken: string): Promise<number> {\n    return await this.contract.methods.getOPCFee(baseToken).call()\n  }\n\n  /** Get Current OPF Fee\n   * @return {Promise<number>} OPF fee\n   */\n  public async getCurrentOPCFee(): Promise<number> {\n    return await this.contract.methods.swapOceanFee().call()\n  }\n\n  /**\n   * Updates OP Community Fees\n   * @param {String} address\n   * @param {number} newSwapOceanFee Amount charged for swapping with ocean approved tokens\n   * @param {number} newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\n   * @param {number} newConsumeFee Amount charged from consumeFees\n   * @param {number} newProviderFee Amount charged for providerFees\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async updateOPCFee<G extends boolean = false>(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport ERC721Template from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport { generateDtName, calculateEstimatedGas, sendTx } from '../utils'\nimport {\n  MetadataProof,\n  MetadataAndTokenURI,\n  NftRoles,\n  ReceiptOrEstimate\n} from '../@types'\nimport { SmartContract } from './SmartContract'\n\nexport class Nft extends SmartContract {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC721Template.abi as AbiItem[]\n  }\n\n  /**\n   * Create new ERC20 Datatoken - only user with DatatokenDeployer permission can succeed\n   * @param {String} nftAddress NFT address\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the Datatoken\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 Datatoken address\n   */\n  public async createDatatoken<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    estimateGas?: G\n  ): Promise<G extends false ? string : number> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = this.getContract(nftAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n    if (estimateGas) return <G extends false ? string : number>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n\n    return trxReceipt?.events?.TokenCreated?.returnValues?.[0]\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addManager<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addManager,\n      manager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addManager,\n      manager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeManager<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeManager,\n      manager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeManager,\n      manager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add DatatokenDeployer permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} datatokenDeployer User adress which is going to have DatatokenDeployer permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addDatatokenDeployer<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    datatokenDeployer: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addToCreateERC20List,\n      datatokenDeployer\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addToCreateERC20List,\n      datatokenDeployer\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove DatatokenDeployer permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} datatokenDeployer Address of the user to be revoked DatatokenDeployer Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeDatatokenDeployer<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    datatokenDeployer: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === datatokenDeployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor DatatokenDeployer`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFromCreateERC20List,\n      datatokenDeployer\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFromCreateERC20List,\n      datatokenDeployer\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addMetadataUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addToMetadataList,\n      metadataUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addToMetadataList,\n      metadataUpdater\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeMetadataUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFromMetadataList,\n      metadataUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFromMetadataList,\n      metadataUpdater\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addStoreUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addTo725StoreList,\n      storeUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addTo725StoreList,\n      storeUpdater\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeStoreUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFrom725StoreList,\n      storeUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFrom725StoreList,\n      storeUpdater\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * This function allows to remove all ROLES at NFT level: Managers, DatatokenDeployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at Datatoken level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async cleanPermissions<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.cleanPermissions\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.cleanPermissions\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on NFT and Datatoken level.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async transferNft<G extends boolean = false>(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await calculateEstimatedGas(\n      nftOwner,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      nftOwner,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on NFT and Datatoken level.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async safeTransferNft<G extends boolean = false>(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await calculateEstimatedGas(\n      nftOwner,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      nftOwner,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates or update Metadata cached by Aquarius. Also, updates the METADATA_DECRYPTOR key\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadata<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadataAndTokenURI<G extends boolean = false>(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const estGas = await calculateEstimatedGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      metadataUpdater,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadataState<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress NFT contract address\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setTokenURI<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    data: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setTokenURI,\n      '1',\n      data\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setTokenURI,\n      '1',\n      data\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress NFT contract address\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address user adress\n   * @return {Promise<NftRoles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<NftRoles> {\n    const nftContract = this.getContract(nftAddress)\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress NFT contract address\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = this.getContract(nftAddress)\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users DatatokenDeployer role\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address user adress\n   * @return {Promise<boolean>}\n   */\n  public async isDatatokenDeployer(\n    nftAddress: string,\n    address: string\n  ): Promise<boolean> {\n    const nftContract = this.getContract(nftAddress)\n    const isDatatokenDeployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isDatatokenDeployer\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param key Key of the data to be stored into 725Y standard\n   * @param value Data to be stored into 725Y standard\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async setData(\n    nftAddress: string,\n    address: string,\n    key: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getNftPermissions(nftAddress, address)).store !== true) {\n      throw new Error(`User is not ERC20 store updater`)\n    }\n\n    const nftContract = this.getContract(nftAddress)\n\n    const keyHash = this.web3.utils.keccak256(key)\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    return trxReceipt\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress NFT contract address\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const keyHash = this.web3.utils.keccak256(key)\n    const data = await nftContract.methods.getData(keyHash).call()\n    return data ? this.web3.utils.hexToAscii(data) : null\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress NFT contract address\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport ERC20Template from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport ERC20TemplateEnterprise from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport { amountToUnits, sendTx, calculateEstimatedGas, ZERO_ADDRESS } from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees,\n  PublishingMarketFee,\n  DispenserParams,\n  OrderParams,\n  DatatokenRoles,\n  ReceiptOrEstimate\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../config'\nimport { SmartContract } from './SmartContract'\n\nexport class Datatoken extends SmartContract {\n  public abiEnterprise: AbiItem | AbiItem[]\n  public nft: Nft\n\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC20Template.abi as AbiItem[]\n  }\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[],\n    abiEnterprise?: AbiItem | AbiItem[]\n  ) {\n    super(web3, network, config, abi)\n    this.abiEnterprise = abiEnterprise || (ERC20TemplateEnterprise.abi as AbiItem[])\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async approve<G extends boolean = false>(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async createFixedRate<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n\n    const withMint = fixedRateParams.withMint === false ? 0 : 1\n\n    // should check DatatokenDeployer role using NFT level ..\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async createDispenser<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n\n    const dtContract = this.getContract(dtAddress)\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    dispenserParams.withMint = dispenserParams.withMint !== false\n\n    // should check DatatokenDeployer role using NFT level ..\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async mint<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.getPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await calculateEstimatedGas(\n        address,\n        dtContract.methods.mint,\n        toAddress || address,\n        this.web3.utils.toWei(amount)\n      )\n      if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n      const trxReceipt = await sendTx(\n        address,\n        estGas + 1,\n        this.web3,\n        this.config?.gasFeeMultiplier,\n        dtContract.methods.mint,\n        toAddress || address,\n        this.web3.utils.toWei(amount)\n      )\n      return <ReceiptOrEstimate<G>>trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Add Minter for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async addMinter<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.addMinter,\n      minter\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.addMinter,\n      minter\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.removeMinter,\n      minter\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.removeMinter,\n      minter\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async addPaymentManager<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.addPaymentManager,\n      paymentManager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.addPaymentManager,\n      paymentManager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removePaymentManager<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.removePaymentManager,\n      paymentManager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.removePaymentManager,\n      paymentManager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setPaymentCollector<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    const isPaymentManager = (await this.getPermissions(dtAddress, address))\n      .paymentManager\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isDatatokenDeployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isDatatokenDeployer) {\n      throw new Error(`Caller is not Fee Manager, owner or Datatoken Deployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setPaymentCollector,\n      paymentCollector\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setPaymentCollector,\n      paymentCollector\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async transferWei<G extends boolean = false>(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.transfer,\n      toAddress,\n      amount\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.transfer,\n      toAddress,\n      amount\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<ReceiptOrEstimate>} string\n   */\n  public async startOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: ZERO_ADDRESS,\n        consumeMarketFeeToken: ZERO_ADDRESS,\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Reuse Order: called by payer or consumer having a valid order, but with expired provider access.\n   * Pays the provider fee again, but it will not require a new datatoken payment\n   * Requires previous approval of provider fee.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @return {Promise<ReceiptOrEstimate>} string\n   */\n  public async reuseOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.reuseOrder,\n      orderTxId,\n      providerFees\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.reuseOrder,\n      orderTxId,\n      providerFees\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async buyFromFreAndOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress, null, this.abiEnterprise)\n\n    const freContractParams = await this.getFreOrderParams(freParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.buyFromFreAndOrder,\n      orderParams,\n      freContractParams\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.buyFromFreAndOrder,\n      orderParams,\n      freContractParams\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async buyFromDispenserAndOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress, null, this.abiEnterprise)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(dtAddress)) into NFT 725 Store\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async setData<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    value: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n\n    const dtContract = this.getContract(dtAddress)\n\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setData,\n      valueHex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setData,\n      valueHex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Clean Datatoken level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 Datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async cleanPermissions<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.cleanPermissions\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.cleanPermissions\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Returns ERC20 Datatoken user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<DatatokenRoles>}\n   */\n  public async getPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<DatatokenRoles> {\n    const dtContract = this.getContract(dtAddress)\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token symbol\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getSymbol(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const symbol = await dtContract.methods.symbol().call()\n    return symbol\n  }\n\n  /** It returns the name of the token\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getName(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const name = await dtContract.methods.name().call()\n    return name\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isDatatokenDeployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = this.getContract(dtAddress)\n    const isDatatokenDeployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isDatatokenDeployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = this.getContract(datatokenAddress, address)\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n\n  /**\n   * @dev setPublishingMarketFee\n   *      Only publishMarketFeeAddress can call it\n   *      This function allows to set the fee required by the publisherMarket\n   * @param {string} datatokenAddress Datatoken adress\n   * @param {string} publishMarketFeeAddress  new publish Market Fee Address\n   * @param {string} publishMarketFeeToken new publish Market Fee Token\n   * @param {string} publishMarketFeeAmount new fee amount\n   * @param {String} address user adress\n   */\n  public async setPublishingMarketFee<G extends boolean = false>(\n    datatokenAddress: string,\n    publishMarketFeeAddress: string,\n    publishMarketFeeToken: string,\n    publishMarketFeeAmount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(datatokenAddress, address)\n    const mktFeeAddress = (await dtContract.methods.getPublishingMarketFee().call())[0]\n    if (mktFeeAddress !== address) {\n      throw new Error(`Caller is not the Publishing Market Fee Address`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev getPublishingMarketFee\n   *      Get publishingMarket Fee\n   *      This function allows to get the current fee set by the publishing market\n   * @param {String} datatokenAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<PublishingMarketFee>} Current fee set by the publishing market\n   */\n  public async getPublishingMarketFee(\n    datatokenAddress: string,\n    address: string\n  ): Promise<PublishingMarketFee> {\n    const dtContract = this.getContract(datatokenAddress, address)\n\n    const publishingMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const returnValues = {\n      publishMarketFeeAddress: publishingMarketFee[0],\n      publishMarketFeeToken: publishingMarketFee[1],\n      publishMarketFeeAmount: publishingMarketFee[2]\n    }\n    return returnValues\n  }\n\n  private async getFreOrderParams(freParams: FreOrderParams): Promise<any> {\n    return {\n      exchangeContract: freParams.exchangeContract,\n      exchangeId: freParams.exchangeId,\n      maxBaseTokenAmount: await amountToUnits(\n        this.web3,\n        freParams.baseTokenAddress,\n        freParams.maxBaseTokenAmount,\n        freParams.baseTokenDecimals\n      ),\n      swapMarketFee: await amountToUnits(\n        this.web3,\n        freParams.baseTokenAddress,\n        freParams.swapMarketFee,\n        freParams.baseTokenDecimals\n      ),\n\n      marketFeeAddress: freParams.marketFeeAddress\n    }\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport ERC721Factory from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport { generateDtName, calculateEstimatedGas, ZERO_ADDRESS, sendTx } from '../utils'\nimport {\n  FreCreationParams,\n  DatatokenCreateParams,\n  DispenserCreationParams,\n  NftCreateData,\n  Template,\n  TokenOrder,\n  ReceiptOrEstimate\n} from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC721Factory.abi as AbiItem[]\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT<G extends boolean = false>(\n    address: string,\n    nftData: NftCreateData,\n    estimateGas?: G\n  ): Promise<G extends false ? string : number> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n    if (estimateGas) return <G extends false ? string : number>estGas\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n    return trxReceipt?.events?.NFTCreated?.returnValues?.[0]\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const nftCount = await this.contract.methods.getCurrentNFTCount().call()\n    return nftCount\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const tokenCount = await this.contract.methods.getCurrentTokenCount().call()\n    return tokenCount\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const owner = await this.contract.methods.owner().call()\n    return owner\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.contract.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of Datatoken Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.contract.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.contract.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken (ERC20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.contract.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if Datatoken is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.contract.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.contract.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Add a new NFT token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.add721TokenTemplate,\n      templateAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.add721TokenTemplate,\n      templateAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async disableNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.disable721TokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.disable721TokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async reactivateNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add a new NFT token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addTokenTemplate,\n      templateAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addTokenTemplate,\n      templateAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async disableTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.disableTokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.disableTokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async reactivateTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ Datatoken contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - ERC20 Datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async startMultipleTokenOrder<G extends boolean = false>(\n    address: string,\n    orders: TokenOrder[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.startMultipleTokenOrder,\n      orders\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.startMultipleTokenOrder,\n      orders\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatoken\n   *      Creates a new NFT, then a Datatoken,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for Datatoken creation\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n\n  public async createNftWithDatatoken<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatokenWithFixedRate\n   *      Creates a new NFT, then a Datatoken, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param dtParams input data for Datatoken Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftWithDatatokenWithFixedRate<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    freParams: FreCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n    const fixedData = this.getFreCreationParams(freParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatokenWithDispenser\n   *      Creates a new NFT, then a Datatoken, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param dtParams input data for Datatoken Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftWithDatatokenWithDispenser<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    dispenserParams: DispenserCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  private getErcCreationParams(dtParams: DatatokenCreateParams): any {\n    let name: string, symbol: string\n    // Generate name & symbol if not present\n    if (!dtParams.name || !dtParams.symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n    return {\n      templateIndex: dtParams.templateIndex,\n      strings: [dtParams.name || name, dtParams.symbol || symbol],\n      addresses: [\n        dtParams.minter,\n        dtParams.paymentCollector,\n        dtParams.mpFeeAddress,\n        dtParams.feeToken\n      ],\n      uints: [Web3.utils.toWei(dtParams.cap), Web3.utils.toWei(dtParams.feeAmount)],\n      bytess: []\n    }\n  }\n\n  private getFreCreationParams(freParams: FreCreationParams): any {\n    if (!freParams.allowedConsumer) freParams.allowedConsumer = ZERO_ADDRESS\n    const withMint = freParams.withMint === false ? 0 : 1\n\n    return {\n      fixedPriceAddress: freParams.fixedRateAddress,\n      addresses: [\n        freParams.baseTokenAddress,\n        freParams.owner,\n        freParams.marketFeeCollector,\n        freParams.allowedConsumer\n      ],\n      uints: [\n        freParams.baseTokenDecimals,\n        freParams.datatokenDecimals,\n        Web3.utils.toWei(freParams.fixedRate),\n        Web3.utils.toWei(freParams.marketFee),\n        withMint\n      ]\n    }\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veOceanABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veOCEAN.vy/veOCEAN.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeOcean extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veOceanABI.abi as AbiItem[]\n  }\n\n  /**\n   * Deposit `amount` tokens for `userAddress` and lock until `unlockTime`\n   * @param {String} userAddress user address\n   * @param {String} amount Amount of tokens to be locked\n   * @param {Number} unlockTime Timestamp for unlock\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async lockTokens<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    unlockTime: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.create_lock,\n      amountFormatted,\n      unlockTime\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.create_lock,\n      amountFormatted,\n      unlockTime\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deposit `amount` tokens for `toAddress` and add to the existing lock\n   * Anyone (even a smart contract) can deposit for someone else, but cannot extend their locktime and deposit for a brand new user\n   * @param {String} fromUserAddress user address that sends the tx\n   * @param {String} toAddress user address to deposit for\n   * @param {String} amount Amount of tokens to be locked\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async depositFor<G extends boolean = false>(\n    fromUserAddress: string,\n    toAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.deposit_for,\n      toAddress,\n      amountFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deposit_for,\n      toAddress,\n      amountFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deposit `amount` additional tokens for `userAddress` without modifying the unlock time\n   * @param {String} userAddress user address that sends the tx\n   * @param {String} amount Amount of tokens to be locked\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async increaseAmount<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.increase_amount,\n      amountFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.increase_amount,\n      amountFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Extend the unlock time for `userAddress` to `unlockTime`\n   * @param {String} userAddress user address that sends the tx\n   * @param {Number} unlockTime Timestamp for new unlock time\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async increaseUnlockTime<G extends boolean = false>(\n    userAddress: string,\n    unlockTime: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.increase_unlock_time,\n      unlockTime\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.increase_unlock_time,\n      unlockTime\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Withdraw all tokens for `userAddress`\n   * @param {String} userAddress user address that sends the tx\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async withdraw<G extends boolean = false>(\n    userAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.withdraw\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.withdraw\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get voting power for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async getVotingPower(userAddress: string): Promise<number> {\n    const balance = await this.contract.methods.balanceOf(userAddress).call()\n    return balance\n  }\n\n  /** Get locked balance\n   * @param {String} userAddress user address\n   * @return {Promise<string>}\n   */\n  public async getLockedAmount(userAddress: string): Promise<string> {\n    const balance = await this.contract.methods.locked(userAddress).call()\n    const balanceFormated = await this.unitsToAmount(\n      await this.getToken(),\n      balance.amount\n    )\n\n    return balanceFormated\n  }\n\n  /** Get untilLock for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async lockEnd(userAddress: string): Promise<number> {\n    const untilLock = await this.contract.methods.locked__end(userAddress).call()\n    return untilLock\n  }\n\n  /** Get total supply\n   * @return {Promise<number>}\n   */\n  public async totalSupply(): Promise<string> {\n    const supplyFormated = await this.unitsToAmount(\n      await this.getToken(),\n      await this.contract.methods.totalSupply().call()\n    )\n    return supplyFormated\n  }\n\n  /** Get token\n   * @return {Promise<string>}\n   */\n  public async getToken(): Promise<string> {\n    const tokenAddress = await this.contract.methods.token().call()\n    return tokenAddress\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veFeeABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veFeeDistributor.vy/veFeeDistributor.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeFeeDistributor extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veFeeABI.abi as AbiItem[]\n  }\n\n  /**\n   * Claim fees for `userAddress`\n   * Each call to claim look at a maximum of 50 user veOCEAN points.\n         For accounts with many veOCEAN related actions, this function\n         may need to be called more than once to claim all available\n         fees. In the `Claimed` event that fires, if `claim_epoch` is\n         less than `max_epoch`, the account may claim again\n   * @param {String} userAddress user address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claim<G extends boolean = false>(\n    userAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(userAddress, this.contract.methods.claim)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claim\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Make multiple fee claims in a single call\n    Used to claim for many accounts at once, or to make\n         multiple claims for the same address when that address\n         has significant veOCEAN history\n   * @param {String} fromUserAddress user address that sends the tx\n   * @param {String} addresses array of addresses to claim\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimMany<G extends boolean = false>(\n    fromUserAddress: string,\n    addresses: string[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claim_many,\n      addresses\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 20000,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claim_many,\n      addresses\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veFeeEstimate from '@oceanprotocol/contracts/artifacts/contracts/ve/veFeeEstimate.vy/veFeeEstimate.json'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { VeOcean } from './VeOcean'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeFeeEstimate extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veFeeEstimate.abi as AbiItem[]\n  }\n\n  /**\n   * estimateClaim\n   * @param {String} userAddress user address\n   * @return {Promise<string>}\n   */\n  public async estimateClaim(userAddress: string): Promise<string> {\n    const amount = await this.contract.methods.estimateClaim(userAddress).call()\n    const veOcean = new VeOcean(\n      await this.contract.methods.voting_escrow().call(),\n      this.web3\n    )\n    const amountFormated = await this.unitsToAmount(await veOcean.getToken(), amount)\n    return amountFormated\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veAllocateABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veAllocate.sol/veAllocate.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeAllocate extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veAllocateABI.abi as AbiItem[]\n  }\n\n  /**\n   * set a specific percentage of veOcean to a specific nft\n   * Maximum allocated percentage is 10000, so 1% is specified as 100\n   * @param {String} userAddress user address\n   * @param {String} amount Percentage used\n   * @param {String} nft NFT address to allocate to\n   * @param {String} chainId chainId of NFT\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setAllocation<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    nft: string,\n    chainId: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.setAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * set specific percetage of veOcean to multiple nfts\n   * Maximum allocated percentage is 10000, so 1% is specified as 100\n   * @param {String} userAddress user address\n   * @param {String[]} amount Array of percentages used\n   * @param {String[]} nft Array of NFT addresses\n   * @param {String[]} chainId Array of chainIds\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setBatchAllocation<G extends boolean = false>(\n    userAddress: string,\n    amount: string[],\n    nft: string[],\n    chainId: number[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.setBatchAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setBatchAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get totalAllocation for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async getTotalAllocation(userAddress: string): Promise<number> {\n    const allocation = await this.contract.methods.getTotalAllocation(userAddress).call()\n    return allocation\n  }\n\n  /** Get getveAllocation for address, nft, chainId\n   * @param {String} userAddress user address\n   * @param {String} nft NFT address to allocate to\n   * @param {String} chainId chainId of NFT\n   * @return {Promise<number>}\n   */\n  public async getVeAllocation(\n    userAddress: string,\n    nft: string,\n    chainId: string\n  ): Promise<number> {\n    const allocation = await this.contract.methods\n      .getveAllocation(userAddress, nft, chainId)\n      .call()\n    return allocation\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport dfRewardsABI from '@oceanprotocol/contracts/artifacts/contracts/df/DFRewards.sol/DFRewards.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n\n/**\n * Provides an interface for DFRewards contract\n */\nexport class DfRewards extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return dfRewardsABI.abi as AbiItem[]\n  }\n\n  /** Get available DF Rewards for a token\n   * @param {String} userAddress user address\n   * @param {String} tokenAddress token address\n   * @return {Promise<string>}\n   */\n  public async getAvailableRewards(\n    userAddress: string,\n    tokenAddress: string\n  ): Promise<string> {\n    const rewards = await this.contract.methods\n      .claimable(userAddress, tokenAddress)\n      .call()\n    const rewardsFormated = await this.unitsToAmount(tokenAddress, rewards)\n\n    return rewardsFormated\n  }\n\n  /**\n   * claim rewards for any address\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String} userAddress user address to claim\n   * @param {String} tokenAddress token address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddress: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claimFor,\n      userAddress,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claimFor,\n      userAddress,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * allocate rewards to address.  An approve must exist before calling this function.\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String[]} userAddresses array of users that will receive rewards\n   * @param {String[]} amounts array of amounts\n   * @param {String} tokenAddress token address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async allocateRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddresses: string[],\n    amounts: string[],\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    for (let i = 0; i < amounts.length; i++) {\n      amounts[i] = await this.amountToUnits(tokenAddress, amounts[i])\n    }\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.allocate,\n      userAddresses,\n      amounts,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.allocate,\n      userAddresses,\n      amounts,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport dfStrategyV1ABI from '@oceanprotocol/contracts/artifacts/contracts/df/DFStrategyV1.sol/DFStrategyV1.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n\n/**\n * Provides an interface for dfStrategyV1 contract\n */\nexport class DfStrategyV1 extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return dfStrategyV1ABI.abi as AbiItem[]\n  }\n\n  /** Get available DF Rewards for multiple tokens\n   * @param {String} userAddress user address\n   * @param {String} tokenAddresses array of tokens\n   * @return {Promise<string[]>}\n   */\n  public async getMultipleAvailableRewards(\n    userAddress: string,\n    tokenAddresses: string[]\n  ): Promise<string[]> {\n    const rewards = await this.contract.methods\n      .claimables(userAddress, tokenAddresses)\n      .call()\n    const rewardsFormated: string[] = []\n    for (let i = 0; i < rewards.length; i++) {\n      rewardsFormated.push(await this.unitsToAmount(tokenAddresses[i], rewards[i]))\n    }\n    return rewardsFormated\n  }\n\n  /**\n   * claim multiple token rewards for any address\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String} userAddress user address to claim\n   * @param {String} tokenAddresses array of tokens\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimMultipleRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddress: string,\n    tokenAddresses: string[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claimMultiple,\n      userAddress,\n      tokenAddresses\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claimMultiple,\n      userAddress,\n      tokenAddresses\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import fetch from 'cross-fetch'\nimport { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types'\n\nexport interface SearchQuery {\n  from?: number\n  size?: number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query: any\n  sort?: { [jsonPath: string]: string }\n  aggs?: any\n}\n\nexport class Aquarius {\n  public aquariusURL: string\n\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: { 'Content-Type': 'application/octet-stream' },\n        signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param {string} did DID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async getAssetMetadata(did: string, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/metadata/' + did\n\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error(\n          'getAssetMetadata failed: ' + response.status + response.statusText\n        )\n      }\n    } catch (error) {\n      LoggerInstance.error('Error getting metadata: ', error)\n      throw new Error('Error getting metadata: ' + error)\n    }\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param  {SearchQuery} query Query to filter the DDOs.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async querySearch(query: SearchQuery, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/query'\n\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(query),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error('querySearch failed: ' + response.status + response.statusText)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error querying metadata: ', error)\n      throw new Error('Error querying metadata: ' + error)\n    }\n  }\n}\n","import Web3 from 'web3'\nimport fetch from 'cross-fetch'\nimport { LoggerInstance } from '../utils'\nimport {\n  Arweave,\n  FileInfo,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize,\n  ProviderComputeInitializeResults,\n  ServiceEndpoint,\n  UrlFile,\n  UserCustomParameters,\n  Ipfs,\n  Smartcontract,\n  GraphqlQuery\n} from '../@types'\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await this.getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  public async signProviderRequest(\n    web3: Web3,\n    accountId: string,\n    message: string,\n    password?: string\n  ): Promise<string> {\n    const consumerMessage = web3.utils.soliditySha3({\n      t: 'bytes',\n      v: web3.utils.utf8ToHex(message)\n    })\n    const isMetaMask =\n      web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n    if (isMetaMask)\n      return await web3.eth.personal.sign(consumerMessage, accountId, password)\n    else return await web3.eth.sign(consumerMessage, accountId)\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {number} chainId network's id so provider can choose the corresponding web3 object\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    chainId: number,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path =\n      (this.getEndpointURL(serviceEndpoints, 'encrypt')\n        ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n        : null) + `?chainId=${chainId}`\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: { 'Content-Type': 'application/octet-stream' },\n        signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {UrlFile | Arweave | Ipfs | GraphqlQuery | Smartcontract} file one of the supported file structures\n   * @param {string} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {boolean} withChecksum if true, will return checksum of files content\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: string,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did, serviceId, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {UrlFile | Arweave | Ipfs | GraphqlQuery | Smartcontract} file one of the supported file structures\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {boolean} withChecksum if true, will return checksum of files content\n   * @param {AbortSignal} signal abort signal\n   * @param {any} headers headers key value pairs associated with the asset GET request\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async getFileInfo(\n    file: UrlFile | Arweave | Ipfs | GraphqlQuery | Smartcontract,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal,\n    headers?: any\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { ...file, headers, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Initialize a compute request.\n   * @param {ComputeAsset} assets\n   * @param {ComputeAlgorithmber} algorithm\n   * @param {string} computeEnv\n   * @param {number} validUntil\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {string} accountId\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderComputeInitialize>} ProviderComputeInitialize data\n   */\n  public async initializeCompute(\n    assets: ComputeAsset[],\n    algorithm: ComputeAlgorithm,\n    computeEnv: string,\n    validUntil: number,\n    providerUri: string,\n    accountId: string,\n    signal?: AbortSignal\n  ): Promise<ProviderComputeInitializeResults> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const providerData = {\n      datasets: assets,\n      algorithm,\n      compute: { env: computeEnv, validUntil },\n      consumerAddress: accountId\n    }\n    const initializeUrl = this.getEndpointURL(serviceEndpoints, 'initializeCompute')\n      ? this.getEndpointURL(serviceEndpoints, 'initializeCompute').urlPath\n      : null\n    if (!initializeUrl) return null\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'POST',\n        body: JSON.stringify(providerData),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('ComputeJob cannot be initialized')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.signProviderRequest(web3, accountId, did + nonce)\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Compute start failed: ',\n        response.status,\n        response.statusText,\n        await response.json()\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${this.noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = this.noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${this.noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @return {Promise<string>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    if (!computeResultUrl) return null\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${this.noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.documentId = this.noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && (params.providerAddress || params.providerAddresses)) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n\n  private noZeroX(input: string): string {\n    return this.zeroXTransformer(input, false)\n  }\n\n  private zeroXTransformer(input = '', zeroOutput: boolean): string {\n    const { valid, output } = this.inputMatch(\n      input,\n      /^(?:0x)*([a-f0-9]+)$/i,\n      'zeroXTransformer'\n    )\n    return (zeroOutput && valid ? '0x' : '') + output\n  }\n\n  // Shared functions\n  private inputMatch(\n    input: string,\n    regexp: RegExp,\n    conversorName: string\n  ): { valid: boolean; output: string } {\n    if (typeof input !== 'string') {\n      LoggerInstance.debug('Not input string:')\n      LoggerInstance.debug(input)\n      throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n    }\n    const match = input.match(regexp)\n    if (!match) {\n      LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n      return { valid: false, output: input }\n    }\n    return { valid: true, output: match[1] }\n  }\n\n  private async getData(url: string): Promise<Response> {\n    return fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-type': 'application/json'\n      }\n    })\n  }\n}\n\nexport const ProviderInstance = new Provider()\n"],"names":["Config","nodeUri","providerAddress","metadataCacheUri","providerUri","web3Provider","oceanTokenAddress","nftFactoryAddress","datatokensABI","fixedRateExchangeAddress","fixedRateExchangeAddressABI","dispenserAddress","dispenserABI","opfCommunityFeeCollector","sideStakingAddress","startBlock","verbose","authMessage","authTokenExpiration","parityUri","threshold","chainId","network","subgraphUri","explorerUri","oceanTokenSymbol","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","gasFeeMultiplier","veAllocate","veOCEAN","veDelegation","veFeeDistributor","veDelegationProxy","DFRewards","DFStrategyV1","veFeeEstimate","ZERO_ADDRESS","GASLIMIT_DEFAULT","MAX_UINT_256","FEE_HISTORY_NOT_SUPPORTED","MIN_GAS_FEE_POLYGON","POLYGON_NETWORK_ID","MUMBAI_NETWORK_ID","setContractDefaults","contract","config","getFairGasPrice","web3","x","BigNumber","eth","getGasPrice","multipliedBy","integerValue","ROUND_DOWN","toString","unitsToAmount","token","amount","tokenDecimals","tokenContract","Contract","minAbi","decimals","methods","call","amountFormatted","div","exponentiatedBy","EXPONENTIAL_AT","amountToUnits","times","toFixed","calculateEstimatedGas","from","functionToEstimateGas","args","apply","estimateGas","err","estGas","sendTx","functionToSend","sendTxValue","gas","networkId","getChainId","_feeHistory$baseFeePe","_feeHistory$reward","_feeHistory$reward$","feeHistory","getFeeHistory","baseFeePerGas","reward","_feeHistory$reward2","_feeHistory$reward2$","_feeHistory$baseFeePe2","aggressiveFee","maxPriorityFeePerGas","maxFeePerGas","plus","lte","gasPrice","message","LoggerInstance","log","send","LogLevel","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","generateDid","nftAddress","Web3","utils","toChecksumAddress","sha256","getHash","data","downloadFileBrowser","url","contentHeader","fetch","method","headers","get","fileName","split","xhr","XMLHttpRequest","responseType","open","onload","blobURL","window","URL","createObjectURL","response","a","document","createElement","href","setAttribute","body","appendChild","click","remove","revokeObjectURL","downloadFile","index","ok","Error","filename","match","_unused","pop","_unused2","arrayBuffer","sleep","ms","Promise","resolve","setTimeout","Logger","constructor","logLevel","this","setLevel","bypass","dispatch","Infinity","debug","Verbose","Log","warn","Warn","error","verb","level","console","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","signHash","address","signedMessage","sign","substr","r","slice","s","v","approve","account","tokenAddress","spender","force","currentAllowence","allowance","Decimal","greaterThanOrEqualTo","toNumber","approveWei","allowanceWei","gt","result","e","transfer","recipient","trxReceipt","balance","balanceOf","configHelperNetworksBase","configHelperNetworks","_extends","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","FixedPrice","Dispenser","ERC721Factory","OPFCommunityFeeCollector","Ocean","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","_config","SmartContract","abi","getDefaultAbi","async","_this$config","getContract","SmartContractWithAddress","super","DispenserAbi","dtAdress","status","maxTokens","fromWei","maxBalance","dtAddress","allowedSwapper","create","toWei","activate","_this$config2","deactivate","_this$config3","newAllowedSwapper","setAllowedSwapper","_this$config4","destination","dispense","_this$config5","ownerWithdraw","_this$config6","datatoken","active","String","greaterThan","isMinter","FixedRateExchange","FixedRateExchangeAbi","baseToken","generateExchangeId","exchangeId","datatokenAmount","maxBaseTokenAmount","consumeMarketAddress","consumeMarketFee","exchange","getExchange","consumeMarketFeeFormatted","dtAmountFormatted","dtDecimals","maxBtFormatted","btDecimals","buyDT","minBaseTokenAmount","minBtFormatted","sellDT","getNumberOfExchanges","newRate","setRate","toggleExchangeState","weiRate","getRate","dtSupply","getDTSupply","btSupply","getBTSupply","getAllowedSwapper","fixedRateExchange","outDT","calcBaseInGivenOutDT","baseTokenAmount","marketFeeAmount","oceanFeeAmount","consumeMarketFeeAmount","calcBaseOutGivenInDT","dtBalance","btBalance","fixedRate","feesInfo","getFeesInfo","opcFee","marketFee","marketFeeAvailable","oceanFeeAvailable","getExchanges","isActive","withMint","toggleMintState","_this$config7","_this$config8","fixedrate","amountWei","collectBT","_this$config9","collectDT","_this$config10","collectMarketFee","_this$config11","collectOceanFee","_this$config12","opcCollector","router","exchangeOwner","newMarketFee","updateMarketFee","_this$config13","newMarketFeeCollector","updateMarketFeeCollector","_this$config14","Router","FactoryRouter","operations","buyDTBatch","isApprovedToken","isFixedRateContract","routerOwner","factory","getOwner","addApprovedToken","removeApprovedToken","addFixedRateContract","removeFixedRateContract","addDispenserContract","removeDispenserContract","getOPCFee","swapOceanFee","newSwapOceanFee","newSwapNonOceanFee","newConsumeFee","newProviderFee","updateOPCFee","Nft","ERC721Template","minter","paymentCollector","mpFeeAddress","feeToken","feeAmount","cap","templateIndex","getNftPermissions","deployERC20","nftContract","createERC20","_trxReceipt$events","events","_trxReceipt$events$To","TokenCreated","_trxReceipt$events$To2","returnValues","manager","getNftOwner","addManager","removeManager","datatokenDeployer","addToCreateERC20List","removeFromCreateERC20List","metadataUpdater","addToMetadataList","updateMetadata","removeFromMetadataList","storeUpdater","addTo725StoreList","store","removeFrom725StoreList","cleanPermissions","nftOwner","nftReceiver","tokenId","tokenIdentifier","transferFrom","safeTransferFrom","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","metadataHash","metadataProofs","setMetaData","metadataAndTokenURI","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetaDataState","_this$config15","setTokenURI","_this$config16","ownerOf","getPermissions","getMetaData","isERC20Deployer","key","value","keyHash","keccak256","valueHex","asciiToHex","setNewData","_this$config17","getData","hexToAscii","id","tokenURI","Datatoken","ERC20Template","abiEnterprise","nft","ERC20TemplateEnterprise","dtContract","fixedRateParams","isDatatokenDeployer","allowedConsumer","createFixedRate","fixedRateAddress","baseTokenAddress","owner","marketFeeCollector","baseTokenDecimals","datatokenDecimals","dispenserParams","createDispenser","toAddress","capAvailble","getCap","gte","mint","addMinter","removeMinter","paymentManager","addPaymentManager","removePaymentManager","isPaymentManager","getNFTAddress","isNftOwner","nftPermissions","setPaymentCollector","getPaymentCollector","weiAmount","transferWei","consumer","serviceIndex","providerFees","consumeMarketFeeAddress","consumeMarketFeeToken","startOrder","orderTxId","reuseOrder","orderParams","freParams","freContractParams","getFreOrderParams","buyFromFreAndOrder","dispenserContract","buyFromDispenserAndOrder","setData","permissions","getERC721Address","datatokenAddress","publishMarketFeeAddress","publishMarketFeeToken","publishMarketFeeAmount","getPublishingMarketFee","setPublishingMarketFee","publishingMarketFee","exchangeContract","swapMarketFee","marketFeeAddress","NftFactory","nftData","getCurrentNFTTemplateCount","getNFTTemplate","deployERC721Contract","transferable","_trxReceipt$events$NF","NFTCreated","_trxReceipt$events$NF2","getCurrentNFTCount","getCurrentTokenCount","getCurrentTemplateCount","getTokenTemplate","erc20List","erc721List","templateAddress","add721TokenTemplate","disable721TokenTemplate","reactivate721TokenTemplate","addTokenTemplate","getCurrentTokenTemplateCount","disableTokenTemplate","reactivateTokenTemplate","orders","startMultipleTokenOrder","nftCreateData","dtParams","ercCreateData","getErcCreationParams","createNftWithErc20","fixedData","getFreCreationParams","createNftWithErc20WithFixedRate","createNftWithErc20WithDispenser","strings","addresses","uints","bytess","fixedPriceAddress","VeOcean","veOceanABI","userAddress","unlockTime","getToken","create_lock","fromUserAddress","deposit_for","increase_amount","increase_unlock_time","withdraw","locked","locked__end","totalSupply","VeFeeDistributor","veFeeABI","claim","claim_many","VeFeeEstimate","estimateClaim","veOcean","voting_escrow","VeAllocate","veAllocateABI","setAllocation","setBatchAllocation","getTotalAllocation","getveAllocation","DfRewards","dfRewardsABI","rewards","claimable","claimFor","userAddresses","amounts","i","allocate","DfStrategyV1","dfStrategyV1ABI","tokenAddresses","claimables","rewardsFormated","push","claimMultiple","Aquarius","aquariusURL","did","signal","path","json","txid","tries","ddo","event","valid","jsonResponse","JSON","stringify","hash","proof","validatorAddress","publicKey","errors","statusText","query","Provider","endpoints","getEndpointURL","servicesEndpoints","serviceName","providerEndpoint","serviceEndpoints","urlPath","consumerAddress","providerEndpoints","getEndpoints","getServiceEndpoints","nonce","accountId","password","consumerMessage","soliditySha3","t","utf8ToHex","currentProvider","isMetaMask","personal","text","serviceId","withChecksum","checksum","files","results","file","_this$getEndpointURL","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","assets","algorithm","providerData","datasets","compute","transferTxId","downloadUrl","Date","now","consumeUrl","signProviderRequest","dataset","additionalDatasets","output","computeStartUrl","signatureMessage","documentId","signature","payload","Object","environment","jobId","computeStopUrl","getNonce","noZeroX","computeStatusUrl","computeResultUrl","resultUrl","computeDeleteUrl","params","providerAddresses","input","zeroXTransformer","zeroOutput","inputMatch","regexp","conversorName","ProviderInstance"],"mappings":"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"}