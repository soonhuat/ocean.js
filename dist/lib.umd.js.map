{"version":3,"file":"lib.umd.js","sources":["../src/utils/Constants.ts","../src/utils/ContractUtils.ts","../src/utils/DatatokenName.ts","../src/utils/Logger.ts","../src/utils/General.ts","../src/utils/minAbi.ts","../src/utils/TokenUtils.ts","../src/config/ConfigHelper.ts","../src/contracts/SmartContract.ts","../src/contracts/SmartContractWithAddress.ts","../src/contracts/Dispenser.ts","../src/contracts/FixedRateExchange.ts","../src/contracts/Router.ts","../src/contracts/NFT.ts","../src/contracts/Datatoken.ts","../src/contracts/NFTFactory.ts","../src/contracts/ve/VeOcean.ts","../src/contracts/ve/VeFeeDistributor.ts","../src/contracts/ve/VeFeeEstimate.ts","../src/contracts/ve/VeAllocate.ts","../src/contracts/df/DfRewards.ts","../src/contracts/df/DfStrategyV1.ts","../src/services/Aquarius.ts","../src/services/Provider.ts","../src/config/Config.ts","../src/utils/FetchHelper.ts","../src/utils/DdoHelpers.ts","../src/utils/SignatureUtils.ts"],"sourcesContent":["export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\nexport const MAX_UINT_256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\nexport const FEE_HISTORY_NOT_SUPPORTED =\n  'Returned error: Method eth_feeHistory not supported.'\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { Config } from '../config'\nimport { minAbi, GASLIMIT_DEFAULT, LoggerInstance, FEE_HISTORY_NOT_SUPPORTED } from '.'\nimport { TransactionReceipt } from 'web3-core'\n\nexport function setContractDefaults(contract: Contract, config: Config): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  return contract\n}\n\nexport async function getFairGasPrice(\n  web3: Web3,\n  gasFeeMultiplier: number\n): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  if (gasFeeMultiplier)\n    return x\n      .multipliedBy(gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, token)\n  let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n  if (decimals === '0') {\n    decimals = 18\n  }\n\n  const amountFormatted = new BigNumber(amount).div(\n    new BigNumber(10).exponentiatedBy(decimals)\n  )\n\n  BigNumber.config({ EXPONENTIAL_AT: 50 })\n  return amountFormatted.toString()\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, token)\n  let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n  if (decimals === '0') {\n    decimals = 18\n  }\n  BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n  const amountFormatted = new BigNumber(amount).times(\n    new BigNumber(10).exponentiatedBy(decimals)\n  )\n  return amountFormatted.toFixed(0)\n}\n\n/**\n * Estimates the gas used when a function would be executed on chain\n * @param {string} from account that calls the function\n * @param {Function} functionToEstimateGas function that we need to estimate the gas\n * @param {...any[]} args arguments of the function\n * @return {Promise<number>} gas cost of the function\n */\nexport async function calculateEstimatedGas(\n  from: string,\n  functionToEstimateGas: Function,\n  ...args: any[]\n): Promise<number> {\n  const estimatedGas = await functionToEstimateGas\n    .apply(null, args)\n    .estimateGas({ from }, (err, estGas) => (err ? GASLIMIT_DEFAULT : estGas))\n  return estimatedGas\n}\n\n/**\n * Send the transation on chain\n * @param {string} from account that calls the function\n * @param {any} estGas estimated gas for the transaction\n * @param {Web3} web3 web3 objcet\n * @param {Function} functionToSend function that we need to send\n * @param {...any[]} args arguments of the function\n * @return {Promise<any>} transaction receipt\n */\nexport async function sendTx(\n  from: string,\n  estGas: number,\n  web3: Web3,\n  gasFeeMultiplier: number,\n  functionToSend: Function,\n  ...args: any[]\n): Promise<TransactionReceipt> {\n  const sendTxValue: Record<string, any> = {\n    from,\n    gas: estGas + 1\n  }\n  try {\n    const feeHistory = await web3.eth.getFeeHistory(1, 'latest', [75])\n    if (feeHistory && feeHistory?.baseFeePerGas?.[0] && feeHistory?.reward?.[0]?.[0]) {\n      let aggressiveFee = new BigNumber(feeHistory?.reward?.[0]?.[0])\n      if (gasFeeMultiplier > 1) {\n        aggressiveFee = aggressiveFee.multipliedBy(gasFeeMultiplier)\n      }\n\n      sendTxValue.maxPriorityFeePerGas = aggressiveFee\n        .integerValue(BigNumber.ROUND_DOWN)\n        .toString(10)\n\n      sendTxValue.maxFeePerGas = aggressiveFee\n        .plus(new BigNumber(feeHistory?.baseFeePerGas?.[0]).multipliedBy(2))\n        .integerValue(BigNumber.ROUND_DOWN)\n        .toString(10)\n    } else {\n      sendTxValue.gasPrice = await getFairGasPrice(web3, gasFeeMultiplier)\n    }\n  } catch (err) {\n    err?.message === FEE_HISTORY_NOT_SUPPORTED &&\n      LoggerInstance.log(\n        'Not able to use EIP 1559, getFeeHistory method not suported by network.'\n      )\n    sendTxValue.gasPrice = await getFairGasPrice(web3, gasFeeMultiplier)\n  }\n\n  const trxReceipt = await functionToSend.apply(null, args).send(sendTxValue)\n  return trxReceipt\n}\n","import wordListDefault from './data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","import Decimal from 'decimal.js'\nimport Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport {\n  amountToUnits,\n  calculateEstimatedGas,\n  unitsToAmount,\n  minAbi,\n  sendTx,\n  LoggerInstance\n} from '.'\nimport { Config } from '../config'\nimport { ReceiptOrEstimate } from '../@types'\n\n/**\n * Approve spender to spent amount tokens\n * @param {Web3} web3\n * @param {Config} config\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 Datatokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {boolean} estimateGas  if true, returns the estimate gas cost for calling the method\n */\nexport async function approve<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  tokenDecimals?: number,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowance(web3, tokenAddress, account, spender)\n    if (new Decimal(currentAllowence).greaterThanOrEqualTo(new Decimal(amount))) {\n      return <ReceiptOrEstimate<G>>new Decimal(currentAllowence).toNumber()\n    }\n  }\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount, tokenDecimals)\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amountFormatted\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  const trxReceipt = await sendTx(\n    account,\n    estGas + 1,\n    web3,\n    config?.gasFeeMultiplier,\n    tokenContract.methods.approve,\n    spender,\n    amountFormatted\n  )\n  return <ReceiptOrEstimate<G>>trxReceipt\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {Web3} web3\n * @param {Config} config\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 tokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {boolean} estimateGas  if true, returns the estimate gas cost for calling the method\n */\nexport async function approveWei<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowanceWei(web3, tokenAddress, account, spender)\n    if (new BigNumber(currentAllowence).gt(new BigNumber(amount))) {\n      return <ReceiptOrEstimate<G>>new Decimal(currentAllowence).toNumber()\n    }\n  }\n  let result = null\n\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amount\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  try {\n    result = await sendTx(\n      account,\n      estGas + 1,\n      web3,\n      config?.gasFeeMultiplier,\n      tokenContract.methods.approve,\n      spender,\n      amount\n    )\n  } catch (e) {\n    LoggerInstance.error(\n      `ERROR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Moves amount tokens from the callerâ€™s account to recipient.\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} recipient\n * @param {String} amount amount of ERC20 Datatokens (not as wei)\n * @param {String} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function transfer<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  recipient: string,\n  amount: string,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount)\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.transfer,\n    recipient,\n    amountFormatted\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  const trxReceipt = await sendTx(\n    account,\n    estGas + 1,\n    web3,\n    config?.gasFeeMultiplier,\n    tokenContract.methods.transfer,\n    recipient,\n    amountFormatted\n  )\n  return <ReceiptOrEstimate<G>>trxReceipt\n}\n\n/**\n * Get Allowance for any Datatoken\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get balance for any Datatoken\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} account\n * @param {String} spender\n */\nexport async function allowanceWei(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.allowance(account, spender).call()\n}\n\n/**\n * Get decimals for any Datatoken\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @return {Promise<number>} Number of decimals of the token\n */\nexport async function decimals(web3: Web3, tokenAddress: string): Promise<number> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.decimals().call()\n}\n","// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport { Config } from '.'\nimport { LoggerInstance } from '../utils'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'http://127.0.0.1:8030',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://127.0.0.1:5000',\n    providerUri: 'http://172.15.0.4:8030'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 5,\n    network: 'goerli',\n    nodeUri: 'https://goerli.infura.io/v3',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://goerli.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.mainnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    providerUri: 'https://v4.provider.polygon.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN',\n    gasFeeMultiplier: 1.6\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1287,\n    network: 'moonbase',\n    nodeUri: 'https://rpc.api.moonbase.moonbeam.network',\n    providerUri: 'https://v4.provider.moonbase.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonbase.oceanprotocol.com',\n    explorerUri: 'https://moonbase.moonscan.io/',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    providerUri: 'https://v4.provider.mumbai.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    providerUri: 'https://v4.provider.bsc.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    providerUri: 'https://v4.provider.energyweb.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    providerUri: 'https://v4.provider.moonriver.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      const {\n        FixedPrice,\n        Dispenser,\n        ERC721Factory,\n        OPFCommunityFeeCollector,\n        Ocean,\n        chainId,\n        startBlock,\n        veAllocate,\n        veOCEAN,\n        veDelegation,\n        veFeeDistributor,\n        veDelegationProxy,\n        DFRewards,\n        DFStrategyV1,\n        veFeeEstimate\n      } = customAddresses[network]\n      configAddresses = {\n        nftFactoryAddress: ERC721Factory,\n        opfCommunityFeeCollector: OPFCommunityFeeCollector,\n        fixedRateExchangeAddress: FixedPrice,\n        dispenserAddress: Dispenser,\n        oceanTokenAddress: Ocean,\n        chainId,\n        startBlock,\n        veAllocate,\n        veOCEAN,\n        veDelegation,\n        veFeeDistributor,\n        veDelegationProxy,\n        DFRewards,\n        DFStrategyV1,\n        veFeeEstimate,\n        ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock,\n          veAllocate,\n          veOCEAN,\n          veDelegation,\n          veFeeDistributor,\n          veDelegationProxy,\n          DFRewards,\n          DFStrategyV1,\n          veFeeEstimate\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          nftFactoryAddress: ERC721Factory,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId,\n          startBlock,\n          veAllocate,\n          veOCEAN,\n          veDelegation,\n          veFeeDistributor,\n          veDelegationProxy,\n          DFRewards,\n          DFStrategyV1,\n          veFeeEstimate,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n\n    if (!config) {\n      LoggerInstance.error(`No config found for given network '${network}'`)\n      return null\n    }\n\n    const contractAddressesConfig = this.getAddressesFromEnv(config.network)\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import Web3 from 'web3'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils'\nimport { Config, ConfigHelper } from '../config'\nimport {\n  amountToUnits,\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount\n} from '../utils'\n\nexport abstract class SmartContract {\n  public web3: Web3\n  public config: Config\n  public abi: AbiItem | AbiItem[]\n\n  abstract getDefaultAbi(): AbiItem | AbiItem[]\n\n  /**\n   * Instantiate the smart contract.\n   * @param {Web3} web3\n   * @param {string | number} network Network id or name\n   * @param {Config} config Configutation of the smart contract\n   * @param {AbiItem | AbiItem[]} abi ABI of the smart contract\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[]\n  ) {\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.abi = abi || (this.getDefaultAbi() as AbiItem[])\n  }\n\n  protected async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  protected async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  protected async getFairGasPrice(): Promise<string> {\n    return getFairGasPrice(this.web3, this.config?.gasFeeMultiplier)\n  }\n\n  protected getContract(\n    address: string,\n    account?: string,\n    abi?: AbiItem | AbiItem[]\n  ): Contract {\n    const contract = new this.web3.eth.Contract(abi || this.abi, address, {\n      from: account\n    })\n    return setContractDefaults(contract, this.config)\n  }\n}\n","import Web3 from 'web3'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils'\nimport { Config } from '../config'\nimport { SmartContract } from './SmartContract'\n\nexport abstract class SmartContractWithAddress extends SmartContract {\n  public address: string\n  public contract: Contract\n\n  /**\n   * Instantiate the smart contract.\n   * @param {string} address Address of the smart contract\n   * @param {Web3} web3\n   * @param {string | number} network Network id or name\n   * @param {Config} config Configutation of the smart contract\n   * @param {AbiItem | AbiItem[]} abi ABI of the smart contract\n   */\n  constructor(\n    address: string,\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[]\n  ) {\n    super(web3, network, config, abi)\n    this.address = address\n    this.contract = this.getContract(this.address)\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport Decimal from 'decimal.js'\nimport DispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport { calculateEstimatedGas, sendTx } from '../utils'\nimport { Datatoken } from './Datatoken'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\nimport { DispenserToken, ReceiptOrEstimate } from '../@types'\n\nexport class Dispenser extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return DispenserAbi.abi as AbiItem[]\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    const status: DispenserToken = await this.contract.methods.status(dtAdress).call()\n    if (!status) {\n      throw new Error(`Np dispenser found for the given datatoken address`)\n    }\n    status.maxTokens = this.web3.utils.fromWei(status.maxTokens)\n    status.maxBalance = this.web3.utils.fromWei(status.maxBalance)\n    status.balance = this.web3.utils.fromWei(status.balance)\n    return status\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async create<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Call createFixedRate contract method\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async activate<G extends boolean = false>(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.activate,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.activate,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async deactivate<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.deactivate,\n      dtAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deactivate,\n      dtAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async setAllowedSwapper<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async dispense<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async ownerWithdraw<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.ownerWithdraw,\n      dtAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.ownerWithdraw,\n      dtAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import FixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { AbiItem } from 'web3-utils/types'\nimport { calculateEstimatedGas, sendTx, ZERO_ADDRESS } from '../utils'\nimport { PriceAndFees, FeesInfo, FixedPriceExchange, ReceiptOrEstimate } from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\nexport class FixedRateExchange extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return FixedRateExchangeAbi.abi as AbiItem[]\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.contract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async buyDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0',\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const maxBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      maxBaseTokenAmount,\n      +exchange.btDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sell datatokenAmount while expecting at least minBaseTokenAmount\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async sellDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0',\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const minBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      minBaseTokenAmount,\n      +exchange.btDecimals\n    )\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.contract.methods.getNumberOfExchanges().call()\n    return numExchanges\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setRate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newRate: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setRate,\n      exchangeId,\n      this.web3.utils.toWei(newRate)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setRate,\n      exchangeId,\n      this.web3.utils.toWei(newRate)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sets a new allowedSwapper\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setAllowedSwapper<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async activate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async deactivate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.contract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDatatokenSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.contract.methods.getDTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.datatoken, dtSupply, +exchange.dtDecimals)\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBasetokenSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.contract.methods.getBTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.baseToken, btSupply, +exchange.btDecimals)\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.contract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenDatatokensOut - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenDatatokensOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const outDT = await this.contract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(\n          fixedRateExchange.datatoken,\n          datatokenAmount,\n          +fixedRateExchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.baseTokenAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      marketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.marketFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      oceanFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.oceanFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      consumeMarketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.consumeMarketFeeAmount,\n        +fixedRateExchange.btDecimals\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBasetokensOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const amount = await this.contract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(\n          exchange.datatoken,\n          datatokenAmount,\n          +exchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(exchange.baseToken, amount[0], +exchange.btDecimals)\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const exchange: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    exchange.dtDecimals = exchange.dtDecimals.toString()\n    exchange.btDecimals = exchange.btDecimals.toString()\n    exchange.dtBalance = await this.unitsToAmount(\n      exchange.datatoken,\n      exchange.dtBalance,\n      +exchange.dtDecimals\n    )\n    exchange.btBalance = await this.unitsToAmount(\n      exchange.baseToken,\n      exchange.btBalance,\n      +exchange.btDecimals\n    )\n    exchange.dtSupply = await this.unitsToAmount(\n      exchange.datatoken,\n      exchange.dtSupply,\n      +exchange.dtDecimals\n    )\n    exchange.btSupply = await this.unitsToAmount(\n      exchange.baseToken,\n      exchange.btSupply,\n      +exchange.btDecimals\n    )\n    exchange.fixedRate = this.web3.utils.fromWei(exchange.fixedRate)\n    exchange.exchangeId = exchangeId\n    return exchange\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const feesInfo: FeesInfo = await this.contract.methods.getFeesInfo(exchangeId).call()\n    feesInfo.opcFee = this.web3.utils.fromWei(feesInfo.opcFee.toString())\n    feesInfo.marketFee = this.web3.utils.fromWei(feesInfo.marketFee.toString())\n\n    const exchange = await this.getExchange(exchangeId)\n    feesInfo.marketFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      feesInfo.marketFeeAvailable,\n      +exchange.btDecimals\n    )\n    feesInfo.oceanFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      feesInfo.oceanFeeAvailable,\n      +exchange.btDecimals\n    )\n\n    feesInfo.exchangeId = exchangeId\n    return feesInfo\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.contract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const active = await this.contract.methods.isActive(exchangeId).call()\n    return active\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async activateMint<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      true\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      true\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async deactivateMint<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      false\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      false\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to Datatoken.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectBasetokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectBT,\n      exchangeId,\n      amountWei\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectBT,\n      exchangeId,\n      amountWei\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to Datatoken.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectDT,\n      exchangeId,\n      amountWei\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectDT,\n      exchangeId,\n      amountWei\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectMarketFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectMarketFee,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectMarketFee,\n      exchangeId\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectOceanFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectOceanFee,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectOceanFee,\n      exchangeId\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    const address = await this.contract.methods.opcCollector().call()\n    return address\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  public async getRouter(): Promise<string> {\n    const address = await this.contract.methods.router().call()\n    return address\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    const address = await (await this.getExchange(exchangeId)).exchangeOwner\n    return address\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async updateMarketFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateMarketFee,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateMarketFee,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async updateMarketFeeCollector<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport FactoryRouter from '@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json'\nimport { calculateEstimatedGas, sendTx } from '../utils'\nimport { Operation, ReceiptOrEstimate } from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\n/**\n * Provides an interface for FactoryRouter contract\n */\nexport class Router extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return FactoryRouter.abi as AbiItem[]\n  }\n\n  /**\n   * buyDatatokenBatch\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<ReceiptOrEstimate>} Transaction receipt\n   */\n  public async buyDatatokenBatch<G extends boolean = false>(\n    address: string,\n    operations: Operation[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.buyDTBatch,\n      operations\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.buyDTBatch,\n      operations\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Check if a token is on approved tokens list, if true opfFee is lower in pools with that token/DT\n   * @return {Promise<boolean>} true if is on the list.\n   */\n  public async isApprovedToken(address: string): Promise<boolean> {\n    return await this.contract.methods.isApprovedToken(address).call()\n  }\n\n  /** Check if an address is a Fixed Rate contract.\n   * @return {Promise<boolean>} true if is a Fixed Rate contract\n   */\n  public async isFixedPrice(address: string): Promise<boolean> {\n    return await this.contract.methods.isFixedRateContract(address).call()\n  }\n\n  /** Get Router Owner\n   * @return {Promise<string>} Router Owner address\n   */\n  public async getOwner(): Promise<string> {\n    return await this.contract.methods.routerOwner().call()\n  }\n\n  /** Get NFT Factory address\n   * @return {Promise<string>} NFT Factory address\n   */\n  public async getNFTFactory(): Promise<string> {\n    return await this.contract.methods.factory().call()\n  }\n\n  /**\n   * Adds a token to the list of tokens with reduced fees\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addApprovedToken<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addApprovedToken,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addApprovedToken,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes a token if exists from the list of tokens with reduced fees\n   * @param {String} address\n   * @param {String} tokenAddress address to remove\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeApprovedToken<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeApprovedToken,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeApprovedToken,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Adds an address to the list of fixed rate contracts\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addFixedRateContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addFixedRateContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addFixedRateContract,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes an address from the list of fixed rate contracts\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeFixedRateContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeFixedRateContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeFixedRateContract,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Adds an address to the list of dispensers\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addDispenserContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addDispenserContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addDispenserContract,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes an address from the list of dispensers\n   * @param {String} address\n   * @param {String} tokenAddress address Contract to be removed\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeDispenserContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeDispenserContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeDispenserContract,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get OPF Fee per token\n   * @return {Promise<number>} OPC fee for a specific baseToken\n   */\n  public async getOPCFee(baseToken: string): Promise<number> {\n    return await this.contract.methods.getOPCFee(baseToken).call()\n  }\n\n  /** Get Current OPF Fee\n   * @return {Promise<number>} OPF fee\n   */\n  public async getCurrentOPCFee(): Promise<number> {\n    return await this.contract.methods.swapOceanFee().call()\n  }\n\n  /**\n   * Updates OP Community Fees\n   * @param {String} address\n   * @param {number} newSwapOceanFee Amount charged for swapping with ocean approved tokens\n   * @param {number} newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\n   * @param {number} newConsumeFee Amount charged from consumeFees\n   * @param {number} newProviderFee Amount charged for providerFees\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async updateOPCFee<G extends boolean = false>(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport ERC721Template from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport { generateDtName, calculateEstimatedGas, sendTx } from '../utils'\nimport {\n  MetadataProof,\n  MetadataAndTokenURI,\n  NftRoles,\n  ReceiptOrEstimate\n} from '../@types'\nimport { SmartContract } from './SmartContract'\n\nexport class Nft extends SmartContract {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC721Template.abi as AbiItem[]\n  }\n\n  /**\n   * Create new ERC20 Datatoken - only user with DatatokenDeployer permission can succeed\n   * @param {String} nftAddress NFT address\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the Datatoken\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 Datatoken address\n   */\n  public async createDatatoken<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    estimateGas?: G\n  ): Promise<G extends false ? string : number> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = this.getContract(nftAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n    if (estimateGas) return <G extends false ? string : number>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n\n    return trxReceipt?.events?.TokenCreated?.returnValues?.[0]\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addManager<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addManager,\n      manager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addManager,\n      manager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeManager<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeManager,\n      manager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeManager,\n      manager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add DatatokenDeployer permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} datatokenDeployer User adress which is going to have DatatokenDeployer permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addDatatokenDeployer<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    datatokenDeployer: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addToCreateERC20List,\n      datatokenDeployer\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addToCreateERC20List,\n      datatokenDeployer\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove DatatokenDeployer permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} datatokenDeployer Address of the user to be revoked DatatokenDeployer Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeDatatokenDeployer<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    datatokenDeployer: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === datatokenDeployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor DatatokenDeployer`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFromCreateERC20List,\n      datatokenDeployer\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFromCreateERC20List,\n      datatokenDeployer\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addMetadataUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addToMetadataList,\n      metadataUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addToMetadataList,\n      metadataUpdater\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeMetadataUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFromMetadataList,\n      metadataUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFromMetadataList,\n      metadataUpdater\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addStoreUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addTo725StoreList,\n      storeUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addTo725StoreList,\n      storeUpdater\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeStoreUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFrom725StoreList,\n      storeUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFrom725StoreList,\n      storeUpdater\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * This function allows to remove all ROLES at NFT level: Managers, DatatokenDeployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at Datatoken level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async cleanPermissions<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.cleanPermissions\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.cleanPermissions\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on NFT and Datatoken level.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async transferNft<G extends boolean = false>(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await calculateEstimatedGas(\n      nftOwner,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      nftOwner,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on NFT and Datatoken level.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async safeTransferNft<G extends boolean = false>(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await calculateEstimatedGas(\n      nftOwner,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      nftOwner,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates or update Metadata cached by Aquarius. Also, updates the METADATA_DECRYPTOR key\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadata<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadataAndTokenURI<G extends boolean = false>(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const estGas = await calculateEstimatedGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      metadataUpdater,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadataState<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress NFT contract address\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setTokenURI<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    data: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setTokenURI,\n      '1',\n      data\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setTokenURI,\n      '1',\n      data\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress NFT contract address\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address user adress\n   * @return {Promise<NftRoles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<NftRoles> {\n    const nftContract = this.getContract(nftAddress)\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress NFT contract address\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = this.getContract(nftAddress)\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users DatatokenDeployer role\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address user adress\n   * @return {Promise<boolean>}\n   */\n  public async isDatatokenDeployer(\n    nftAddress: string,\n    address: string\n  ): Promise<boolean> {\n    const nftContract = this.getContract(nftAddress)\n    const isDatatokenDeployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isDatatokenDeployer\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param key Key of the data to be stored into 725Y standard\n   * @param value Data to be stored into 725Y standard\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async setData(\n    nftAddress: string,\n    address: string,\n    key: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getNftPermissions(nftAddress, address)).store !== true) {\n      throw new Error(`User is not ERC20 store updater`)\n    }\n\n    const nftContract = this.getContract(nftAddress)\n\n    const keyHash = this.web3.utils.keccak256(key)\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    return trxReceipt\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress NFT contract address\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const keyHash = this.web3.utils.keccak256(key)\n    const data = await nftContract.methods.getData(keyHash).call()\n    return data ? this.web3.utils.hexToAscii(data) : null\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress NFT contract address\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport ERC20Template from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport ERC20TemplateEnterprise from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport { amountToUnits, sendTx, calculateEstimatedGas, ZERO_ADDRESS } from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees,\n  PublishingMarketFee,\n  DispenserParams,\n  OrderParams,\n  DatatokenRoles,\n  ReceiptOrEstimate\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../config'\nimport { SmartContract } from './SmartContract'\n\nexport class Datatoken extends SmartContract {\n  public abiEnterprise: AbiItem | AbiItem[]\n  public nft: Nft\n\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC20Template.abi as AbiItem[]\n  }\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[],\n    abiEnterprise?: AbiItem | AbiItem[]\n  ) {\n    super(web3, network, config, abi)\n    this.abiEnterprise = abiEnterprise || (ERC20TemplateEnterprise.abi as AbiItem[])\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async approve<G extends boolean = false>(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async createFixedRate<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n\n    const withMint = fixedRateParams.withMint ? 1 : 0\n\n    // should check DatatokenDeployer role using NFT level ..\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async createDispenser<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n\n    const dtContract = this.getContract(dtAddress)\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    if (!dispenserParams.withMint) dispenserParams.withMint = false\n\n    // should check DatatokenDeployer role using NFT level ..\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async mint<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.getPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await calculateEstimatedGas(\n        address,\n        dtContract.methods.mint,\n        toAddress || address,\n        this.web3.utils.toWei(amount)\n      )\n      if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n      const trxReceipt = await sendTx(\n        address,\n        estGas + 1,\n        this.web3,\n        this.config?.gasFeeMultiplier,\n        dtContract.methods.mint,\n        toAddress || address,\n        this.web3.utils.toWei(amount)\n      )\n      return <ReceiptOrEstimate<G>>trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Add Minter for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async addMinter<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.addMinter,\n      minter\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.addMinter,\n      minter\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.removeMinter,\n      minter\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.removeMinter,\n      minter\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async addPaymentManager<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.addPaymentManager,\n      paymentManager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.addPaymentManager,\n      paymentManager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removePaymentManager<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.removePaymentManager,\n      paymentManager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.removePaymentManager,\n      paymentManager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setPaymentCollector<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    const isPaymentManager = (await this.getPermissions(dtAddress, address))\n      .paymentManager\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isDatatokenDeployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isDatatokenDeployer) {\n      throw new Error(`Caller is not Fee Manager, owner or Datatoken Deployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setPaymentCollector,\n      paymentCollector\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setPaymentCollector,\n      paymentCollector\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async transferWei<G extends boolean = false>(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.transfer,\n      toAddress,\n      amount\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.transfer,\n      toAddress,\n      amount\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<ReceiptOrEstimate>} string\n   */\n  public async startOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: ZERO_ADDRESS,\n        consumeMarketFeeToken: ZERO_ADDRESS,\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Reuse Order: called by payer or consumer having a valid order, but with expired provider access.\n   * Pays the provider fee again, but it will not require a new datatoken payment\n   * Requires previous approval of provider fee.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @return {Promise<ReceiptOrEstimate>} string\n   */\n  public async reuseOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.reuseOrder,\n      orderTxId,\n      providerFees\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.reuseOrder,\n      orderTxId,\n      providerFees\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async buyFromFreAndOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress, null, this.abiEnterprise)\n\n    const freContractParams = await this.getFreOrderParams(freParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.buyFromFreAndOrder,\n      orderParams,\n      freContractParams\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.buyFromFreAndOrder,\n      orderParams,\n      freContractParams\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async buyFromDispenserAndOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress, null, this.abiEnterprise)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(dtAddress)) into NFT 725 Store\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async setData<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    value: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n\n    const dtContract = this.getContract(dtAddress)\n\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setData,\n      valueHex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setData,\n      valueHex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Clean Datatoken level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 Datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async cleanPermissions<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.cleanPermissions\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.cleanPermissions\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Returns ERC20 Datatoken user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<DatatokenRoles>}\n   */\n  public async getPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<DatatokenRoles> {\n    const dtContract = this.getContract(dtAddress)\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isDatatokenDeployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = this.getContract(dtAddress)\n    const isDatatokenDeployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isDatatokenDeployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = this.getContract(datatokenAddress, address)\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n\n  /**\n   * @dev setPublishingMarketFee\n   *      Only publishMarketFeeAddress can call it\n   *      This function allows to set the fee required by the publisherMarket\n   * @param {string} datatokenAddress Datatoken adress\n   * @param {string} publishMarketFeeAddress  new publish Market Fee Address\n   * @param {string} publishMarketFeeToken new publish Market Fee Token\n   * @param {string} publishMarketFeeAmount new fee amount\n   * @param {String} address user adress\n   */\n  public async setPublishingMarketFee<G extends boolean = false>(\n    datatokenAddress: string,\n    publishMarketFeeAddress: string,\n    publishMarketFeeToken: string,\n    publishMarketFeeAmount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(datatokenAddress, address)\n    const mktFeeAddress = (await dtContract.methods.getPublishingMarketFee().call())[0]\n    if (mktFeeAddress !== address) {\n      throw new Error(`Caller is not the Publishing Market Fee Address`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev getPublishingMarketFee\n   *      Get publishingMarket Fee\n   *      This function allows to get the current fee set by the publishing market\n   * @param {String} datatokenAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<PublishingMarketFee>} Current fee set by the publishing market\n   */\n  public async getPublishingMarketFee(\n    datatokenAddress: string,\n    address: string\n  ): Promise<PublishingMarketFee> {\n    const dtContract = this.getContract(datatokenAddress, address)\n\n    const publishingMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const returnValues = {\n      publishMarketFeeAddress: publishingMarketFee[0],\n      publishMarketFeeToken: publishingMarketFee[1],\n      publishMarketFeeAmount: publishingMarketFee[2]\n    }\n    return returnValues\n  }\n\n  private async getFreOrderParams(freParams: FreOrderParams): Promise<any> {\n    return {\n      exchangeContract: freParams.exchangeContract,\n      exchangeId: freParams.exchangeId,\n      maxBaseTokenAmount: await amountToUnits(\n        this.web3,\n        freParams.baseTokenAddress,\n        freParams.maxBaseTokenAmount,\n        freParams.baseTokenDecimals\n      ),\n      swapMarketFee: await amountToUnits(\n        this.web3,\n        freParams.baseTokenAddress,\n        freParams.swapMarketFee,\n        freParams.baseTokenDecimals\n      ),\n\n      marketFeeAddress: freParams.marketFeeAddress\n    }\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport ERC721Factory from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport { generateDtName, calculateEstimatedGas, ZERO_ADDRESS, sendTx } from '../utils'\nimport {\n  FreCreationParams,\n  DatatokenCreateParams,\n  DispenserCreationParams,\n  NftCreateData,\n  Template,\n  TokenOrder,\n  ReceiptOrEstimate\n} from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC721Factory.abi as AbiItem[]\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT<G extends boolean = false>(\n    address: string,\n    nftData: NftCreateData,\n    estimateGas?: G\n  ): Promise<G extends false ? string : number> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n    if (estimateGas) return <G extends false ? string : number>estGas\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n    return trxReceipt?.events?.NFTCreated?.returnValues?.[0]\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const nftCount = await this.contract.methods.getCurrentNFTCount().call()\n    return nftCount\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const tokenCount = await this.contract.methods.getCurrentTokenCount().call()\n    return tokenCount\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const owner = await this.contract.methods.owner().call()\n    return owner\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.contract.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of Datatoken Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.contract.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.contract.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken (ERC20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.contract.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if Datatoken is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.contract.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.contract.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Add a new NFT token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.add721TokenTemplate,\n      templateAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.add721TokenTemplate,\n      templateAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async disableNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.disable721TokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.disable721TokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async reactivateNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add a new NFT token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addTokenTemplate,\n      templateAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addTokenTemplate,\n      templateAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async disableTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.disableTokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.disableTokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async reactivateTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ Datatoken contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - ERC20 Datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async startMultipleTokenOrder<G extends boolean = false>(\n    address: string,\n    orders: TokenOrder[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.startMultipleTokenOrder,\n      orders\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.startMultipleTokenOrder,\n      orders\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatoken\n   *      Creates a new NFT, then a Datatoken,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for Datatoken creation\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n\n  public async createNftWithDatatoken<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatokenWithFixedRate\n   *      Creates a new NFT, then a Datatoken, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param dtParams input data for Datatoken Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftWithDatatokenWithFixedRate<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    freParams: FreCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n    const fixedData = this.getFreCreationParams(freParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatokenWithDispenser\n   *      Creates a new NFT, then a Datatoken, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param dtParams input data for Datatoken Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftWithDatatokenWithDispenser<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    dispenserParams: DispenserCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  private getErcCreationParams(dtParams: DatatokenCreateParams): any {\n    let name: string, symbol: string\n    // Generate name & symbol if not present\n    if (!dtParams.name || !dtParams.symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n    return {\n      templateIndex: dtParams.templateIndex,\n      strings: [dtParams.name || name, dtParams.symbol || symbol],\n      addresses: [\n        dtParams.minter,\n        dtParams.paymentCollector,\n        dtParams.mpFeeAddress,\n        dtParams.feeToken\n      ],\n      uints: [Web3.utils.toWei(dtParams.cap), Web3.utils.toWei(dtParams.feeAmount)],\n      bytess: []\n    }\n  }\n\n  private getFreCreationParams(freParams: FreCreationParams): any {\n    if (!freParams.allowedConsumer) freParams.allowedConsumer = ZERO_ADDRESS\n    const withMint = freParams.withMint ? 1 : 0\n\n    return {\n      fixedPriceAddress: freParams.fixedRateAddress,\n      addresses: [\n        freParams.baseTokenAddress,\n        freParams.owner,\n        freParams.marketFeeCollector,\n        freParams.allowedConsumer\n      ],\n      uints: [\n        freParams.baseTokenDecimals,\n        freParams.datatokenDecimals,\n        Web3.utils.toWei(freParams.fixedRate),\n        Web3.utils.toWei(freParams.marketFee),\n        withMint\n      ]\n    }\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veOceanABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veOCEAN.vy/veOCEAN.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeOcean extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veOceanABI.abi as AbiItem[]\n  }\n\n  /**\n   * Deposit `amount` tokens for `userAddress` and lock until `unlockTime`\n   * @param {String} userAddress user address\n   * @param {String} amount Amount of tokens to be locked\n   * @param {Number} unlockTime Timestamp for unlock\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async lockTokens<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    unlockTime: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.create_lock,\n      amountFormatted,\n      unlockTime\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.create_lock,\n      amountFormatted,\n      unlockTime\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deposit `amount` tokens for `toAddress` and add to the existing lock\n   * Anyone (even a smart contract) can deposit for someone else, but cannot extend their locktime and deposit for a brand new user\n   * @param {String} fromUserAddress user address that sends the tx\n   * @param {String} toAddress user address to deposit for\n   * @param {String} amount Amount of tokens to be locked\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async depositFor<G extends boolean = false>(\n    fromUserAddress: string,\n    toAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.deposit_for,\n      toAddress,\n      amountFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deposit_for,\n      toAddress,\n      amountFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deposit `amount` additional tokens for `userAddress` without modifying the unlock time\n   * @param {String} userAddress user address that sends the tx\n   * @param {String} amount Amount of tokens to be locked\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async increaseAmount<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.increase_amount,\n      amountFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.increase_amount,\n      amountFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Extend the unlock time for `userAddress` to `unlockTime`\n   * @param {String} userAddress user address that sends the tx\n   * @param {Number} unlockTime Timestamp for new unlock time\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async increaseUnlockTime<G extends boolean = false>(\n    userAddress: string,\n    unlockTime: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.increase_unlock_time,\n      unlockTime\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.increase_unlock_time,\n      unlockTime\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Withdraw all tokens for `userAddress`\n   * @param {String} userAddress user address that sends the tx\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async withdraw<G extends boolean = false>(\n    userAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.withdraw\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.withdraw\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get voting power for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async getVotingPower(userAddress: string): Promise<number> {\n    const balance = await this.contract.methods.balanceOf(userAddress).call()\n    return balance\n  }\n\n  /** Get locked balance\n   * @param {String} userAddress user address\n   * @return {Promise<string>}\n   */\n  public async getLockedAmount(userAddress: string): Promise<string> {\n    const balance = await this.contract.methods.locked(userAddress).call()\n    const balanceFormated = await this.unitsToAmount(\n      await this.getToken(),\n      balance.amount\n    )\n\n    return balanceFormated\n  }\n\n  /** Get untilLock for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async lockEnd(userAddress: string): Promise<number> {\n    const untilLock = await this.contract.methods.locked__end(userAddress).call()\n    return untilLock\n  }\n\n  /** Get total supply\n   * @return {Promise<number>}\n   */\n  public async totalSupply(): Promise<string> {\n    const supplyFormated = await this.unitsToAmount(\n      await this.getToken(),\n      await this.contract.methods.totalSupply().call()\n    )\n    return supplyFormated\n  }\n\n  /** Get token\n   * @return {Promise<string>}\n   */\n  public async getToken(): Promise<string> {\n    const tokenAddress = await this.contract.methods.token().call()\n    return tokenAddress\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veFeeABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veFeeDistributor.vy/veFeeDistributor.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeFeeDistributor extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veFeeABI.abi as AbiItem[]\n  }\n\n  /**\n   * Claim fees for `userAddress`\n   * Each call to claim look at a maximum of 50 user veOCEAN points.\n         For accounts with many veOCEAN related actions, this function\n         may need to be called more than once to claim all available\n         fees. In the `Claimed` event that fires, if `claim_epoch` is\n         less than `max_epoch`, the account may claim again\n   * @param {String} userAddress user address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claim<G extends boolean = false>(\n    userAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(userAddress, this.contract.methods.claim)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claim\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Make multiple fee claims in a single call\n    Used to claim for many accounts at once, or to make\n         multiple claims for the same address when that address\n         has significant veOCEAN history\n   * @param {String} fromUserAddress user address that sends the tx\n   * @param {String} addresses array of addresses to claim\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimMany<G extends boolean = false>(\n    fromUserAddress: string,\n    addresses: string[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claim_many,\n      addresses\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 20000,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claim_many,\n      addresses\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veFeeEstimate from '@oceanprotocol/contracts/artifacts/contracts/ve/veFeeEstimate.vy/veFeeEstimate.json'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { VeOcean } from './VeOcean'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeFeeEstimate extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veFeeEstimate.abi as AbiItem[]\n  }\n\n  /**\n   * estimateClaim\n   * @param {String} userAddress user address\n   * @return {Promise<string>}\n   */\n  public async estimateClaim(userAddress: string): Promise<string> {\n    const amount = await this.contract.methods.estimateClaim(userAddress).call()\n    const veOcean = new VeOcean(\n      await this.contract.methods.voting_escrow().call(),\n      this.web3\n    )\n    const amountFormated = await this.unitsToAmount(await veOcean.getToken(), amount)\n    return amountFormated\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veAllocateABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veAllocate.sol/veAllocate.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeAllocate extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veAllocateABI.abi as AbiItem[]\n  }\n\n  /**\n   * set a specific percentage of veOcean to a specific nft\n   * Maximum allocated percentage is 10000, so 1% is specified as 100\n   * @param {String} userAddress user address\n   * @param {String} amount Percentage used\n   * @param {String} nft NFT address to allocate to\n   * @param {String} chainId chainId of NFT\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setAllocation<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    nft: string,\n    chainId: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.setAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * set specific percetage of veOcean to multiple nfts\n   * Maximum allocated percentage is 10000, so 1% is specified as 100\n   * @param {String} userAddress user address\n   * @param {String[]} amount Array of percentages used\n   * @param {String[]} nft Array of NFT addresses\n   * @param {String[]} chainId Array of chainIds\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setBatchAllocation<G extends boolean = false>(\n    userAddress: string,\n    amount: string[],\n    nft: string[],\n    chainId: number[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.setBatchAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setBatchAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get totalAllocation for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async getTotalAllocation(userAddress: string): Promise<number> {\n    const allocation = await this.contract.methods.getTotalAllocation(userAddress).call()\n    return allocation\n  }\n\n  /** Get getveAllocation for address, nft, chainId\n   * @param {String} userAddress user address\n   * @param {String} nft NFT address to allocate to\n   * @param {String} chainId chainId of NFT\n   * @return {Promise<number>}\n   */\n  public async getVeAllocation(\n    userAddress: string,\n    nft: string,\n    chainId: string\n  ): Promise<number> {\n    const allocation = await this.contract.methods\n      .getveAllocation(userAddress, nft, chainId)\n      .call()\n    return allocation\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport dfRewardsABI from '@oceanprotocol/contracts/artifacts/contracts/df/DFRewards.sol/DFRewards.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n\n/**\n * Provides an interface for DFRewards contract\n */\nexport class DfRewards extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return dfRewardsABI.abi as AbiItem[]\n  }\n\n  /** Get available DF Rewards for a token\n   * @param {String} userAddress user address\n   * @param {String} tokenAddress token address\n   * @return {Promise<string>}\n   */\n  public async getAvailableRewards(\n    userAddress: string,\n    tokenAddress: string\n  ): Promise<string> {\n    const rewards = await this.contract.methods\n      .claimable(userAddress, tokenAddress)\n      .call()\n    const rewardsFormated = await this.unitsToAmount(tokenAddress, rewards)\n\n    return rewardsFormated\n  }\n\n  /**\n   * claim rewards for any address\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String} userAddress user address to claim\n   * @param {String} tokenAddress token address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddress: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claimFor,\n      userAddress,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claimFor,\n      userAddress,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * allocate rewards to address.  An approve must exist before calling this function.\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String[]} userAddresses array of users that will receive rewards\n   * @param {String[]} amounts array of amounts\n   * @param {String} tokenAddress token address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async allocateRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddresses: string[],\n    amounts: string[],\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    for (let i = 0; i < amounts.length; i++) {\n      amounts[i] = await this.amountToUnits(tokenAddress, amounts[i])\n    }\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.allocate,\n      userAddresses,\n      amounts,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.allocate,\n      userAddresses,\n      amounts,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport dfStrategyV1ABI from '@oceanprotocol/contracts/artifacts/contracts/df/DFStrategyV1.sol/DFStrategyV1.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n\n/**\n * Provides an interface for dfStrategyV1 contract\n */\nexport class DfStrategyV1 extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return dfStrategyV1ABI.abi as AbiItem[]\n  }\n\n  /** Get available DF Rewards for multiple tokens\n   * @param {String} userAddress user address\n   * @param {String} tokenAddresses array of tokens\n   * @return {Promise<string[]>}\n   */\n  public async getMultipleAvailableRewards(\n    userAddress: string,\n    tokenAddresses: string[]\n  ): Promise<string[]> {\n    const rewards = await this.contract.methods\n      .claimables(userAddress, tokenAddresses)\n      .call()\n    const rewardsFormated: string[] = []\n    for (let i = 0; i < rewards.length; i++) {\n      rewardsFormated.push(await this.unitsToAmount(tokenAddresses[i], rewards[i]))\n    }\n    return rewardsFormated\n  }\n\n  /**\n   * claim multiple token rewards for any address\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String} userAddress user address to claim\n   * @param {String} tokenAddresses array of tokens\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimMultipleRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddress: string,\n    tokenAddresses: string[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claimMultiple,\n      userAddress,\n      tokenAddresses\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claimMultiple,\n      userAddress,\n      tokenAddresses\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import fetch from 'cross-fetch'\nimport { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types'\n\nexport interface SearchQuery {\n  from?: number\n  size?: number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query: any\n  sort?: { [jsonPath: string]: string }\n  aggs?: any\n}\n\nexport class Aquarius {\n  public aquariusURL: string\n\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: { 'Content-Type': 'application/octet-stream' },\n        signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param {string} did DID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async getAssetMetadata(did: string, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/metadata/' + did\n\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error(\n          'getAssetMetadata failed: ' + response.status + response.statusText\n        )\n      }\n    } catch (error) {\n      LoggerInstance.error('Error getting metadata: ', error)\n      throw new Error('Error getting metadata: ' + error)\n    }\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param  {SearchQuery} query Query to filter the DDOs.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async querySearch(query: SearchQuery, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/query'\n\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(query),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error('querySearch failed: ' + response.status + response.statusText)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error querying metadata: ', error)\n      throw new Error('Error querying metadata: ' + error)\n    }\n  }\n}\n","import Web3 from 'web3'\nimport fetch from 'cross-fetch'\nimport { LoggerInstance } from '../utils'\nimport {\n  Arweave,\n  FileInfo,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize,\n  ProviderComputeInitializeResults,\n  ServiceEndpoint,\n  UrlFile,\n  UserCustomParameters\n} from '../@types'\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await this.getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  public async signProviderRequest(\n    web3: Web3,\n    accountId: string,\n    message: string,\n    password?: string\n  ): Promise<string> {\n    const consumerMessage = web3.utils.soliditySha3({\n      t: 'bytes',\n      v: web3.utils.utf8ToHex(message)\n    })\n    const isMetaMask =\n      web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n    if (isMetaMask)\n      return await web3.eth.personal.sign(consumerMessage, accountId, password)\n    else return await web3.eth.sign(consumerMessage, accountId)\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'encrypt')\n      ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: { 'Content-Type': 'application/octet-stream' },\n        signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {string} did did\n   * @param {number} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {boolean} withChecksum if true, will return checksum of files content\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: string,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did, serviceId, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {string} url or did\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {boolean} withChecksum if true, will return checksum of files content\n   * @param {AbortSignal} signal abort signal\n   * @param {any} headers headers key value pairs associated with the asset GET request\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async getFileInfo(\n    file: UrlFile | Arweave,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal,\n    headers?: any\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { ...file, headers, checksum: withChecksum }\n    console.log('Provider getFileInfo withChecksum, ', withChecksum)\n    console.log('Provider getFileInfo headers, ', headers)\n    console.log('Provider getFileInfo args, ', args)\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Initialize a compute request.\n   * @param {ComputeAsset} assets\n   * @param {ComputeAlgorithmber} algorithm\n   * @param {string} computeEnv\n   * @param {number} validUntil\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {string} accountId\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderComputeInitialize>} ProviderComputeInitialize data\n   */\n  public async initializeCompute(\n    assets: ComputeAsset[],\n    algorithm: ComputeAlgorithm,\n    computeEnv: string,\n    validUntil: number,\n    providerUri: string,\n    accountId: string,\n    signal?: AbortSignal\n  ): Promise<ProviderComputeInitializeResults> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const providerData = {\n      datasets: assets,\n      algorithm,\n      compute: { env: computeEnv, validUntil },\n      consumerAddress: accountId\n    }\n    const initializeUrl = this.getEndpointURL(serviceEndpoints, 'initializeCompute')\n      ? this.getEndpointURL(serviceEndpoints, 'initializeCompute').urlPath\n      : null\n    if (!initializeUrl) return null\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'POST',\n        body: JSON.stringify(providerData),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('ComputeJob cannot be initialized')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.signProviderRequest(web3, accountId, did + nonce)\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Compute start failed: ',\n        response.status,\n        response.statusText,\n        await response.json()\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${this.noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = this.noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${this.noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @return {Promise<string>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    if (!computeResultUrl) return null\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${this.noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.documentId = this.noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && params.providerAddress) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n\n  private noZeroX(input: string): string {\n    return this.zeroXTransformer(input, false)\n  }\n\n  private zeroXTransformer(input = '', zeroOutput: boolean): string {\n    const { valid, output } = this.inputMatch(\n      input,\n      /^(?:0x)*([a-f0-9]+)$/i,\n      'zeroXTransformer'\n    )\n    return (zeroOutput && valid ? '0x' : '') + output\n  }\n\n  // Shared functions\n  private inputMatch(\n    input: string,\n    regexp: RegExp,\n    conversorName: string\n  ): { valid: boolean; output: string } {\n    if (typeof input !== 'string') {\n      LoggerInstance.debug('Not input string:')\n      LoggerInstance.debug(input)\n      throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n    }\n    const match = input.match(regexp)\n    if (!match) {\n      LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n      return { valid: false, output: input }\n    }\n    return { valid: true, output: match[1] }\n  }\n\n  private async getData(url: string): Promise<Response> {\n    return fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-type': 'application/json'\n      }\n    })\n  }\n}\n\nexport const ProviderInstance = new Provider()\n","import { AbiItem } from 'web3-utils/types'\nimport { LogLevel } from '../utils'\n\nexport class Config {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public nftFactoryAddress?: string\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, goerli, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  gasFeeMultiplier: number\n\n  veAllocate?: string\n  veOCEAN?: string\n  veDelegation?: string\n  veFeeDistributor?: string\n  veDelegationProxy?: string\n  DFRewards?: string\n  DFStrategyV1?: string\n  veFeeEstimate?: string\n}\n","import fetch from 'cross-fetch'\nimport { DownloadResponse } from '../@types'\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const headResponse = await fetch(url, { method: 'HEAD' })\n  const contentHeader = headResponse.headers.get('content-disposition')\n  const fileName = contentHeader.split('=')[1]\n  const xhr = new XMLHttpRequest()\n  xhr.responseType = 'blob'\n  xhr.open('GET', url)\n  xhr.onload = () => {\n    const blobURL = window.URL.createObjectURL(xhr.response)\n    const a = document.createElement('a')\n    a.href = blobURL\n    a.setAttribute('download', fileName)\n    document.body.appendChild(a)\n    a.click()\n    a.remove()\n    window.URL.revokeObjectURL(blobURL)\n  }\n  xhr.send(null)\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\n\nexport function generateDid(nftAddress: string, chainId: number): string {\n  nftAddress = Web3.utils.toChecksumAddress(nftAddress)\n  const checksum = sha256(nftAddress + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  return sha256(data).toString()\n}\n","import Web3 from 'web3'\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n"],"names":["ZERO_ADDRESS","GASLIMIT_DEFAULT","FEE_HISTORY_NOT_SUPPORTED","sendTx","from","estGas","web3","gasFeeMultiplier","functionToSend","apply","send","sendTxValue","gas","eth","getFeeHistory","feeHistory","baseFeePerGas","_feeHistory$baseFeePe","reward","_feeHistory$reward","_feeHistory$reward$","getFairGasPrice","gasPrice","aggressiveFee","BigNumber","_feeHistory$reward2","_feeHistory$reward2$","multipliedBy","maxPriorityFeePerGas","integerValue","ROUND_DOWN","toString","maxFeePerGas","plus","_feeHistory$baseFeePe2","err","message","LoggerInstance","log","calculateEstimatedGas","functionToEstimateGas","estimateGas","amountToUnits","token","amount","tokenDecimals","decimals","config","EXPONENTIAL_AT","times","exponentiatedBy","toFixed","tokenContract","Contract","minAbi","methods","call","unitsToAmount","amountFormatted","div","getGasPrice","x","setContractDefaults","contract","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","LogLevel","sleep","ms","Promise","resolve","setTimeout","Logger","logLevel","Error","this","setLevel","bypass","dispatch","Infinity","debug","Verbose","Log","warn","Warn","error","verb","level","console","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","allowanceWei","tokenAddress","account","spender","allowance","trxReceipt","configHelperNetworksBase","chainId","network","metadataCacheUri","nodeUri","providerUri","subgraphUri","explorerUri","oceanTokenAddress","oceanTokenSymbol","fixedRateExchangeAddress","dispenserAddress","startBlock","configHelperNetworks","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","nftFactoryAddress","ERC721Factory","opfCommunityFeeCollector","OPFCommunityFeeCollector","FixedPrice","Dispenser","Ocean","veAllocate","veOCEAN","veDelegation","veFeeDistributor","veDelegationProxy","DFRewards","DFStrategyV1","veFeeEstimate","process","env","AQUARIUS_URI","DefaultContractsAddresses","getConfig","infuraProjectId","filterBy","find","SmartContract","abi","getDefaultAbi","_this6$config","getContract","address","SmartContractWithAddress","_this","DispenserAbi","status","dtAdress","_this2","maxTokens","utils","fromWei","maxBalance","balance","create","dtAddress","allowedSwapper","_this4","toWei","_this4$config","activate","_this6","deactivate","_this8","_this8$config","setAllowedSwapper","newAllowedSwapper","_this10","_this10$config","dispense","destination","_this12","_this12$config","ownerWithdraw","_this14","_this14$config","isDispensable","datatoken","active","Decimal","greaterThanOrEqualTo","String","greaterThan","isMinter","FixedRateExchange","FixedRateExchangeAbi","generateExchangeId","baseToken","buyDatatokens","exchangeId","datatokenAmount","maxBaseTokenAmount","consumeMarketAddress","consumeMarketFee","getExchange","exchange","consumeMarketFeeFormatted","dtDecimals","dtAmountFormatted","btDecimals","maxBtFormatted","buyDT","sellDatatokens","minBaseTokenAmount","minBtFormatted","sellDT","getNumberOfExchanges","setRate","newRate","toggleExchangeState","_this16","_this16$config","getRate","_this18","weiRate","getDatatokenSupply","_this20","getDTSupply","dtSupply","getBasetokenSupply","_this22","getBTSupply","btSupply","getAllowedSwapper","calcBaseInGivenDatatokensOut","_this26","fixedRateExchange","_this25$contract$meth","calcBaseInGivenOutDT","_calcBaseInGivenOutDT","outDT","baseTokenAmount","marketFeeAmount","oceanFeeAmount","consumeMarketFeeAmount","getAmountBasetokensOut","_this28","_this27$contract$meth","calcBaseOutGivenInDT","_calcBaseOutGivenInDT","_this30","dtBalance","btBalance","fixedRate","getFeesInfo","_this32","feesInfo","opcFee","marketFee","marketFeeAvailable","oceanFeeAvailable","getExchanges","isActive","activateMint","_this38","withMint","toggleMintState","_this38$config","deactivateMint","_this40","_this40$config","collectBasetokens","_this42","fixedrate","amountWei","collectBT","_this42$config","collectDatatokens","_this44","collectDT","_this44$config","collectMarketFee","_this46","_this46$config","collectOceanFee","_this48","_this48$config","getOPCCollector","opcCollector","getRouter","router","getExchangeOwner","_this53$getExchange","exchangeOwner","updateMarketFee","newMarketFee","_this56","_this56$config","updateMarketFeeCollector","newMarketFeeCollector","_this58","_this58$config","Router","FactoryRouter","buyDatatokenBatch","operations","buyDTBatch","_this2$config","isApprovedToken","isFixedPrice","isFixedRateContract","getOwner","routerOwner","getNFTFactory","factory","addApprovedToken","_this11$getOwner","removeApprovedToken","_this13$getOwner","addFixedRateContract","_this15$getOwner","removeFixedRateContract","_this17$getOwner","_this18$config","addDispenserContract","_this19$getOwner","_this20$config","removeDispenserContract","_this21$getOwner","_this22$config","getOPCFee","getCurrentOPCFee","swapOceanFee","updateOPCFee","newSwapOceanFee","newSwapNonOceanFee","newConsumeFee","newProviderFee","_this27$getOwner","_this28$config","Nft","ERC721Template","createDatatoken","nftAddress","minter","paymentCollector","mpFeeAddress","feeToken","feeAmount","cap","templateIndex","getNftPermissions","_this$getNftPermissio","deployERC20","nftContract","createERC20","events","_trxReceipt$events","TokenCreated","_trxReceipt$events$To","returnValues","_trxReceipt$events$To2","addManager","manager","getNftOwner","_this3$getNftOwner","removeManager","_this5$getNftOwner","addDatatokenDeployer","datatokenDeployer","_this7$getNftPermissi","addToCreateERC20List","removeDatatokenDeployer","_temp","_this9$getNftPermissi2","removeFromCreateERC20List","_this9$getNftPermissi","addMetadataUpdater","metadataUpdater","_this11$getNftPermiss","addToMetadataList","removeMetadataUpdater","_temp3","_this13$getNftPermiss2","updateMetadata","removeFromMetadataList","_this13$getNftPermiss","addStoreUpdater","storeUpdater","_this15$getNftPermiss","addTo725StoreList","removeStoreUpdater","_temp5","_this17$getNftPermiss2","store","removeFrom725StoreList","_this17$getNftPermiss","cleanPermissions","_this19$getNftOwner","transferNft","nftOwner","nftReceiver","tokenId","_this21$getNftOwner","tokenIdentifier","transferFrom","safeTransferNft","_this24","_this23$getNftOwner","safeTransferFrom","_this24$config","setMetadata","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","data","metadataHash","metadataProofs","_this25$getNftPermiss","setMetaData","_this26$config","setMetadataAndTokenURI","metadataAndTokenURI","_this27$getNftPermiss","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetadataState","_this29$getNftPermiss","setMetaDataState","_this30$config","setTokenURI","_this32$config","ownerOf","getPermissions","getMetadata","getMetaData","isDatatokenDeployer","isERC20Deployer","setData","key","value","_this41$getNftPermiss","keyHash","keccak256","valueHex","asciiToHex","setNewData","getData","hexToAscii","getTokenURI","id","tokenURI","Datatoken","abiEnterprise","nft","ERC20TemplateEnterprise","ERC20Template","_proto","approve","dtContract","_this3","_this3$config","createFixedRate","fixedRateParams","_this5","allowedConsumer","fixedRateAddress","baseTokenAddress","owner","marketFeeCollector","baseTokenDecimals","datatokenDecimals","_this5$config","createDispenser","dispenserParams","_this7","_this7$config","mint","toAddress","_this9","_this8$getPermissions","getCap","capAvailble","gte","_this9$config","addMinter","_this11","_this10$isDatatokenDe","_this11$config","removeMinter","_this13","_this12$isDatatokenDe","_this13$config","addPaymentManager","paymentManager","_this15","_this14$isDatatokenDe","_this15$config","removePaymentManager","_this17","_this16$isDatatokenDe","_this17$config","setPaymentCollector","_this19","nftPermissions","isPaymentManager","isNftOwner","_this19$config","_this18$nft$getNftOwn","_this18$getPermission","getNFTAddress","getPaymentCollector","transfer","weiAmount","transferWei","_this25","_this25$config","startOrder","consumer","serviceIndex","providerFees","_this27","consumeMarketFeeAddress","consumeMarketFeeToken","_this27$config","reuseOrder","orderTxId","_this29","_this29$config","buyFromFreAndOrder","orderParams","freParams","_this31","getFreOrderParams","freContractParams","_this31$config","buyFromDispenserAndOrder","dispenserContract","_this33","_this33$config","_this35","_this35$config","_this37","_this36$nft2","_this36$nft$getNftOwn","_this37$config","permissions","_this41","getDecimals","getERC721Address","datatokenAddress","_this49","balanceOf","setPublishingMarketFee","publishMarketFeeAddress","publishMarketFeeToken","publishMarketFeeAmount","_this51","getPublishingMarketFee","_dtContract$methods$g","_this51$config","publishingMarketFee","exchangeContract","_this55","swapMarketFee","marketFeeAddress","NftFactory","createNFT","nftData","getCurrentNFTTemplateCount","_nftData$templateInde2","getNFTTemplate","_this$getNFTTemplate","deployERC721Contract","transferable","NFTCreated","_trxReceipt$events$NF","_trxReceipt$events$NF2","getCurrentNFTCount","getCurrentTokenCount","getCurrentTokenTemplateCount","getCurrentTemplateCount","index","getTokenTemplate","checkDatatoken","erc20List","checkNFT","erc721List","addNFTTemplate","templateAddress","add721TokenTemplate","disableNFTTemplate","_this23$getOwner","disable721TokenTemplate","reactivateNFTTemplate","_this25$getOwner","reactivate721TokenTemplate","addTokenTemplate","disableTokenTemplate","_this29$getOwner","_this29$getTokenTempl","reactivateTokenTemplate","_this31$getOwner","_this31$getTokenTempl","startMultipleTokenOrder","orders","_this34","_this34$config","createNftWithDatatoken","nftCreateData","dtParams","ercCreateData","_this36","getErcCreationParams","createNftWithErc20","_this36$config","createNftWithDatatokenWithFixedRate","fixedData","getFreCreationParams","createNftWithErc20WithFixedRate","createNftWithDatatokenWithDispenser","Web3","createNftWithErc20WithDispenser","strings","addresses","uints","bytess","fixedPriceAddress","VeOcean","veOceanABI","lockTokens","userAddress","unlockTime","getToken","create_lock","depositFor","fromUserAddress","deposit_for","increaseAmount","increase_amount","increaseUnlockTime","increase_unlock_time","withdraw","getVotingPower","getLockedAmount","locked","lockEnd","locked__end","totalSupply","VeFeeDistributor","veFeeABI","claim","claimMany","claim_many","VeFeeEstimate","estimateClaim","voting_escrow","veOcean","VeAllocate","veAllocateABI","setAllocation","setBatchAllocation","getTotalAllocation","getVeAllocation","getveAllocation","v","_settle","pact","state","bind","e","DfRewards","dfRewardsABI","getAvailableRewards","claimable","rewards","claimRewards","claimFor","allocateRewards","userAddresses","amounts","allocate","i","DfStrategyV1","dfStrategyV1ABI","getMultipleAvailableRewards","tokenAddresses","claimables","rewardsFormated","push","_push","claimMultipleRewards","claimMultiple","o","result","Aquarius","aquariusURL","did","signal","path","fetch","method","headers","response","ok","json","waitForAqua","txid","tries","ddo","event","validate","jsonResponse","valid","body","JSON","stringify","hash","proof","validatorAddress","publicKey","r","s","errors","getAssetMetadata","statusText","querySearch","query","then","Provider","getEndpoints","endpoints","getEndpointURL","servicesEndpoints","serviceName","getServiceEndpoints","providerEndpoint","serviceEndpoints","urlPath","getNonce","consumerAddress","providerEndpoints","nonce","signProviderRequest","accountId","password","consumerMessage","soliditySha3","t","utf8ToHex","currentProvider","isMetaMask","personal","sign","encrypt","text","checkDidFiles","serviceId","withChecksum","args","checksum","files","results","getFileInfo","file","getComputeEnvironments","_this12$getEndpointUR","initialize","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","initializeCompute","assets","algorithm","providerData","datasets","compute","getDownloadUrl","transferTxId","downloadUrl","Date","now","signature","consumeUrl","computeStart","dataset","additionalDatasets","output","computeStartUrl","signatureMessage","documentId","payload","Object","environment","_error","params","computeStop","jobId","computeStopUrl","noZeroX","computeStatus","computeStatusUrl","url","getComputeResultUrl","computeResultUrl","resultUrl","computeDelete","computeDeleteUrl","isValidProvider","providerAddress","input","zeroXTransformer","zeroOutput","inputMatch","regexp","conversorName","match","ProviderInstance","web3Provider","datatokensABI","fixedRateExchangeAddressABI","dispenserABI","sideStakingAddress","verbose","authMessage","authTokenExpiration","parityUri","threshold","force","currentAllowence","toNumber","gt","filename","get","split","pop","arrayBuffer","headResponse","fileName","xhr","XMLHttpRequest","responseType","open","onload","blobURL","window","URL","createObjectURL","a","document","createElement","href","setAttribute","appendChild","click","remove","revokeObjectURL","toChecksumAddress","sha256","signedMessage","substr","slice","recipient"],"mappings":"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"}