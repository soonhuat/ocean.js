{"version":3,"file":"lib.js","sources":["../src/utils/Constants.ts","../src/utils/ContractUtils.ts","../src/utils/DatatokenName.ts","../src/utils/FetchHelper.ts","../src/utils/Logger.ts","../src/utils/General.ts","../src/utils/minAbi.ts","../src/utils/TokenUtils.ts","../src/config/ConfigHelper.ts","../src/contracts/SmartContract.ts","../src/contracts/SmartContractWithAddress.ts","../src/contracts/Dispenser.ts","../src/contracts/FixedRateExchange.ts","../src/contracts/Router.ts","../src/contracts/NFT.ts","../src/contracts/Datatoken.ts","../src/contracts/NFTFactory.ts","../src/contracts/ve/VeOcean.ts","../src/contracts/ve/VeFeeDistributor.ts","../src/contracts/ve/VeFeeEstimate.ts","../src/contracts/ve/VeAllocate.ts","../src/contracts/df/DfRewards.ts","../src/contracts/df/DfStrategyV1.ts","../src/services/Aquarius.ts","../src/services/Provider.ts","../src/config/Config.ts","../src/utils/DdoHelpers.ts","../src/utils/SignatureUtils.ts"],"sourcesContent":["export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\nexport const GASLIMIT_DEFAULT = 1000000\nexport const MAX_UINT_256 =\n  '115792089237316195423570985008687907853269984665640564039457584007913129639934'\nexport const FEE_HISTORY_NOT_SUPPORTED =\n  'Returned error: Method eth_feeHistory not supported.'\n","import Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport { Contract } from 'web3-eth-contract'\nimport { Config } from '../config'\nimport { minAbi, GASLIMIT_DEFAULT, LoggerInstance, FEE_HISTORY_NOT_SUPPORTED } from '.'\nimport { TransactionReceipt } from 'web3-core'\n\nconst MIN_GAS_FEE_POLYGON = 30000000000 // minimum recommended 30 gwei polygon main and mumbai fees\nconst POLYGON_NETWORK_ID = 137\nconst MUMBAI_NETWORK_ID = 80001\n\nexport function setContractDefaults(contract: Contract, config: Config): Contract {\n  if (config) {\n    if (config.transactionBlockTimeout)\n      contract.transactionBlockTimeout = config.transactionBlockTimeout\n    if (config.transactionConfirmationBlocks)\n      contract.transactionConfirmationBlocks = config.transactionConfirmationBlocks\n    if (config.transactionPollingTimeout)\n      contract.transactionPollingTimeout = config.transactionPollingTimeout\n  }\n  return contract\n}\n\nexport async function getFairGasPrice(\n  web3: Web3,\n  gasFeeMultiplier: number\n): Promise<string> {\n  const x = new BigNumber(await web3.eth.getGasPrice())\n  if (gasFeeMultiplier)\n    return x\n      .multipliedBy(gasFeeMultiplier)\n      .integerValue(BigNumber.ROUND_DOWN)\n      .toString(10)\n  else return x.toString(10)\n}\n\nexport async function unitsToAmount(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, token)\n  let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n  if (decimals === '0') {\n    decimals = 18\n  }\n\n  const amountFormatted = new BigNumber(amount).div(\n    new BigNumber(10).exponentiatedBy(decimals)\n  )\n\n  BigNumber.config({ EXPONENTIAL_AT: 50 })\n  return amountFormatted.toString()\n}\n\nexport async function amountToUnits(\n  web3: Web3,\n  token: string,\n  amount: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, token)\n  let decimals = tokenDecimals || (await tokenContract.methods.decimals().call())\n  if (decimals === '0') {\n    decimals = 18\n  }\n  BigNumber.config({ EXPONENTIAL_AT: 50 })\n\n  const amountFormatted = new BigNumber(amount).times(\n    new BigNumber(10).exponentiatedBy(decimals)\n  )\n  return amountFormatted.toFixed(0)\n}\n\n/**\n * Estimates the gas used when a function would be executed on chain\n * @param {string} from account that calls the function\n * @param {Function} functionToEstimateGas function that we need to estimate the gas\n * @param {...any[]} args arguments of the function\n * @return {Promise<number>} gas cost of the function\n */\nexport async function calculateEstimatedGas(\n  from: string,\n  functionToEstimateGas: Function,\n  ...args: any[]\n): Promise<number> {\n  const estimatedGas = await functionToEstimateGas\n    .apply(null, args)\n    .estimateGas({ from }, (err, estGas) => (err ? GASLIMIT_DEFAULT : estGas))\n  return estimatedGas\n}\n\n/**\n * Send the transation on chain\n * @param {string} from account that calls the function\n * @param {any} estGas estimated gas for the transaction\n * @param {Web3} web3 web3 objcet\n * @param {Function} functionToSend function that we need to send\n * @param {...any[]} args arguments of the function\n * @return {Promise<any>} transaction receipt\n */\nexport async function sendTx(\n  from: string,\n  estGas: number,\n  web3: Web3,\n  gasFeeMultiplier: number,\n  functionToSend: Function,\n  ...args: any[]\n): Promise<TransactionReceipt> {\n  const sendTxValue: Record<string, any> = {\n    from,\n    gas: estGas + 1\n  }\n  const networkId = await web3.eth.getChainId()\n  try {\n    const feeHistory = await web3.eth.getFeeHistory(1, 'latest', [75])\n    if (feeHistory && feeHistory?.baseFeePerGas?.[0] && feeHistory?.reward?.[0]?.[0]) {\n      let aggressiveFee = new BigNumber(feeHistory?.reward?.[0]?.[0])\n      if (gasFeeMultiplier > 1) {\n        aggressiveFee = aggressiveFee.multipliedBy(gasFeeMultiplier)\n      }\n\n      sendTxValue.maxPriorityFeePerGas = aggressiveFee\n        .integerValue(BigNumber.ROUND_DOWN)\n        .toString(10)\n\n      sendTxValue.maxFeePerGas = aggressiveFee\n        .plus(new BigNumber(feeHistory?.baseFeePerGas?.[0]).multipliedBy(2))\n        .integerValue(BigNumber.ROUND_DOWN)\n        .toString(10)\n\n      // if network is polygon and mumbai and fees is lower than the 30 gwei trashold, sets MIN_GAS_FEE_POLYGON\n      sendTxValue.maxPriorityFeePerGas =\n        (networkId === MUMBAI_NETWORK_ID || networkId === POLYGON_NETWORK_ID) &&\n        new BigNumber(sendTxValue.maxPriorityFeePerGas).lte(\n          new BigNumber(MIN_GAS_FEE_POLYGON)\n        )\n          ? new BigNumber(MIN_GAS_FEE_POLYGON)\n              .integerValue(BigNumber.ROUND_DOWN)\n              .toString(10)\n          : sendTxValue.maxPriorityFeePerGas\n\n      sendTxValue.maxFeePerGas =\n        (networkId === MUMBAI_NETWORK_ID || networkId === POLYGON_NETWORK_ID) &&\n        new BigNumber(sendTxValue.maxFeePerGas).lte(new BigNumber(MIN_GAS_FEE_POLYGON))\n          ? new BigNumber(MIN_GAS_FEE_POLYGON)\n              .integerValue(BigNumber.ROUND_DOWN)\n              .toString(10)\n          : sendTxValue.maxFeePerGas\n    } else {\n      sendTxValue.gasPrice = await getFairGasPrice(web3, gasFeeMultiplier)\n    }\n  } catch (err) {\n    err?.message === FEE_HISTORY_NOT_SUPPORTED &&\n      LoggerInstance.log(\n        'Not able to use EIP 1559, getFeeHistory method not suported by network.'\n      )\n    sendTxValue.gasPrice = await getFairGasPrice(web3, gasFeeMultiplier)\n  }\n\n  const trxReceipt = await functionToSend.apply(null, args).send(sendTxValue)\n  return trxReceipt\n}\n","import wordListDefault from './data/words.json'\n\n/**\n * Generate new datatoken name & symbol from a word list\n * @return {<{ name: String; symbol: String }>} datatoken name & symbol. Produces e.g. \"Endemic Jellyfish Token\" & \"ENDJEL-45\"\n */\nexport function generateDtName(wordList?: { nouns: string[]; adjectives: string[] }): {\n  name: string\n  symbol: string\n} {\n  const list = wordList || wordListDefault\n  const random1 = Math.floor(Math.random() * list.adjectives.length)\n  const random2 = Math.floor(Math.random() * list.nouns.length)\n  const indexNumber = Math.floor(Math.random() * 100)\n\n  // Capitalized adjective & noun\n  const adjective = list.adjectives[random1].replace(/^\\w/, (c) => c.toUpperCase())\n  const noun = list.nouns[random2].replace(/^\\w/, (c) => c.toUpperCase())\n\n  const name = `${adjective} ${noun} Token`\n  // use first 3 letters of name, uppercase it, and add random number\n  const symbol = `${(\n    adjective.substring(0, 3) + noun.substring(0, 3)\n  ).toUpperCase()}-${indexNumber}`\n\n  return { name, symbol }\n}\n","import fetch from 'cross-fetch'\nimport { DownloadResponse } from '../@types'\n\nexport async function downloadFileBrowser(url: string): Promise<void> {\n  const headResponse = await fetch(url, { method: 'HEAD' })\n  const contentHeader = headResponse.headers.get('content-disposition')\n  const fileName = contentHeader?.split('=')[1] ? contentHeader?.split('=')[1] : 'file'\n  const xhr = new XMLHttpRequest()\n  xhr.responseType = 'blob'\n  xhr.open('GET', url)\n  xhr.onload = () => {\n    const blobURL = window.URL.createObjectURL(xhr.response)\n    const a = document.createElement('a')\n    a.href = blobURL\n    a.setAttribute('download', fileName)\n    document.body.appendChild(a)\n    a.click()\n    a.remove()\n    window.URL.revokeObjectURL(blobURL)\n  }\n  xhr.send(null)\n}\n\nexport async function downloadFile(\n  url: string,\n  index?: number\n): Promise<DownloadResponse> {\n  const response = await fetch(url)\n  if (!response.ok) {\n    throw new Error('Response error.')\n  }\n  let filename: string\n  try {\n    filename = response.headers\n      .get('content-disposition')\n      .match(/attachment;filename=(.+)/)[1]\n  } catch {\n    try {\n      filename = url.split('/').pop()\n    } catch {\n      filename = `file${index}`\n    }\n  }\n\n  return { data: await response.arrayBuffer(), filename }\n}\n","/* eslint-disable no-unused-vars */\nexport enum LogLevel {\n  None = -1,\n  Error = 0,\n  Warn = 1,\n  Log = 2,\n  Verbose = 3\n}\n/* eslint-enable no-unused-vars */\n\nexport class Logger {\n  constructor(private logLevel: LogLevel = LogLevel.Error) {}\n\n  public setLevel(logLevel: LogLevel): void {\n    this.logLevel = logLevel\n  }\n\n  public bypass(...args: any[]): void {\n    this.dispatch('log', -Infinity as any, ...args)\n  }\n\n  public debug(...args: any[]): void {\n    this.dispatch('debug', LogLevel.Verbose, ...args)\n  }\n\n  public log(...args: any[]): void {\n    this.dispatch('log', LogLevel.Log, ...args)\n  }\n\n  public warn(...args: any[]): void {\n    this.dispatch('warn', LogLevel.Warn, ...args)\n  }\n\n  public error(...args: any[]): void {\n    this.dispatch('error', LogLevel.Error, ...args)\n  }\n\n  private dispatch(verb: string, level: LogLevel, ...args: any[]) {\n    if (this.logLevel >= level) {\n      console[verb](...args)\n    }\n  }\n}\n\nexport const LoggerInstance = new Logger()\n","/**\n * Simple blocking sleep function\n */\nexport async function sleep(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n","import { AbiItem } from 'web3-utils/types'\n\nexport const minAbi = [\n  {\n    constant: true,\n    inputs: [],\n    name: 'name',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_spender',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'approve',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'totalSupply',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_from',\n        type: 'address'\n      },\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transferFrom',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'decimals',\n    outputs: [\n      {\n        name: '',\n        type: 'uint8'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      }\n    ],\n    name: 'balanceOf',\n    outputs: [\n      {\n        name: 'balance',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [],\n    name: 'symbol',\n    outputs: [\n      {\n        name: '',\n        type: 'string'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_to',\n        type: 'address'\n      },\n      {\n        name: '_value',\n        type: 'uint256'\n      }\n    ],\n    name: 'transfer',\n    outputs: [\n      {\n        name: '',\n        type: 'bool'\n      }\n    ],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        name: '_owner',\n        type: 'address'\n      },\n      {\n        name: '_spender',\n        type: 'address'\n      }\n    ],\n    name: 'allowance',\n    outputs: [\n      {\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    payable: true,\n    stateMutability: 'payable',\n    type: 'fallback'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'owner',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'spender',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Approval',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        name: 'from',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        name: 'to',\n        type: 'address'\n      },\n      {\n        indexed: false,\n        name: 'value',\n        type: 'uint256'\n      }\n    ],\n    name: 'Transfer',\n    type: 'event'\n  }\n] as AbiItem[]\n","import Decimal from 'decimal.js'\nimport Web3 from 'web3'\nimport BigNumber from 'bignumber.js'\nimport {\n  amountToUnits,\n  calculateEstimatedGas,\n  unitsToAmount,\n  minAbi,\n  sendTx,\n  LoggerInstance\n} from '.'\nimport { Config } from '../config'\nimport { ReceiptOrEstimate } from '../@types'\n\n/**\n * Approve spender to spent amount tokens\n * @param {Web3} web3\n * @param {Config} config\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 Datatokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {number} tokenDecimals optional number of decimals of the token\n * @param {boolean} estimateGas  if true, returns the estimate gas cost for calling the method\n */\nexport async function approve<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  tokenDecimals?: number,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowance(web3, tokenAddress, account, spender)\n    if (new Decimal(currentAllowence).greaterThanOrEqualTo(new Decimal(amount))) {\n      return <ReceiptOrEstimate<G>>new Decimal(currentAllowence).toNumber()\n    }\n  }\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount, tokenDecimals)\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amountFormatted\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  const trxReceipt = await sendTx(\n    account,\n    estGas + 1,\n    web3,\n    config?.gasFeeMultiplier,\n    tokenContract.methods.approve,\n    spender,\n    amountFormatted\n  )\n  return <ReceiptOrEstimate<G>>trxReceipt\n}\n\n/**\n * Approve spender to spent amount tokens\n * @param {Web3} web3\n * @param {Config} config\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} spender\n * @param {String} amount amount of ERC20 tokens (always expressed as wei)\n * @param {boolean} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n * @param {boolean} estimateGas  if true, returns the estimate gas cost for calling the method\n */\nexport async function approveWei<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  spender: string,\n  amount: string,\n  force = false,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  if (!force) {\n    const currentAllowence = await allowanceWei(web3, tokenAddress, account, spender)\n    if (new BigNumber(currentAllowence).gt(new BigNumber(amount))) {\n      return <ReceiptOrEstimate<G>>new Decimal(currentAllowence).toNumber()\n    }\n  }\n  let result = null\n\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.approve,\n    spender,\n    amount\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  try {\n    result = await sendTx(\n      account,\n      estGas + 1,\n      web3,\n      config?.gasFeeMultiplier,\n      tokenContract.methods.approve,\n      spender,\n      amount\n    )\n  } catch (e) {\n    LoggerInstance.error(\n      `ERROR: Failed to approve spender to spend tokens : ${e.message}`\n    )\n  }\n  return result\n}\n\n/**\n * Moves amount tokens from the callerâ€™s account to recipient.\n * @param {String} account\n * @param {String} tokenAddress\n * @param {String} recipient\n * @param {String} amount amount of ERC20 Datatokens (not as wei)\n * @param {String} force  if true, will overwrite any previous allowence. Else, will check if allowence is enough and will not send a transaction if it's not needed\n */\nexport async function transfer<G extends boolean = false>(\n  web3: Web3,\n  config: Config,\n  account: string,\n  tokenAddress: string,\n  recipient: string,\n  amount: string,\n  estimateGas?: G\n): Promise<ReceiptOrEstimate<G>> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n\n  const amountFormatted = await amountToUnits(web3, tokenAddress, amount)\n  const estGas = await calculateEstimatedGas(\n    account,\n    tokenContract.methods.transfer,\n    recipient,\n    amountFormatted\n  )\n  if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n  const trxReceipt = await sendTx(\n    account,\n    estGas + 1,\n    web3,\n    config?.gasFeeMultiplier,\n    tokenContract.methods.transfer,\n    recipient,\n    amountFormatted\n  )\n  return <ReceiptOrEstimate<G>>trxReceipt\n}\n\n/**\n * Get Allowance for any Datatoken\n * @param {Web3} web3\n * @param {String } tokenAdress\n * @param {String} account\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n */\nexport async function allowance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.allowance(account, spender).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get balance for any Datatoken\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} owner\n * @param {String} spender\n * @param {number} tokenDecimals optional number of decimals of the token\n */\nexport async function balance(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  tokenDecimals?: number\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  const trxReceipt = await tokenContract.methods.balanceOf(account).call()\n\n  return await unitsToAmount(web3, tokenAddress, trxReceipt, tokenDecimals)\n}\n\n/**\n * Get Allowance for any erc20\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @param {String} account\n * @param {String} spender\n */\nexport async function allowanceWei(\n  web3: Web3,\n  tokenAddress: string,\n  account: string,\n  spender: string\n): Promise<string> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.allowance(account, spender).call()\n}\n\n/**\n * Get decimals for any Datatoken\n * @param {Web3} web3\n * @param {String} tokenAdress\n * @return {Promise<number>} Number of decimals of the token\n */\nexport async function decimals(web3: Web3, tokenAddress: string): Promise<number> {\n  const tokenContract = new web3.eth.Contract(minAbi, tokenAddress)\n  return await tokenContract.methods.decimals().call()\n}\n","// eslint-disable-next-line import/no-named-default\n// import { default as DefaultContractsAddresses } from '@oceanprotocol/contracts/addresses/address.json'\nimport { Config } from '.'\nimport { LoggerInstance } from '../utils'\n// eslint-disable-next-line import/no-named-default\nimport { default as DefaultContractsAddresses } from '../../address.json'\n\nconst configHelperNetworksBase: Config = {\n  chainId: null,\n  network: 'unknown',\n  metadataCacheUri: 'https://v4.aquarius.oceanprotocol.com',\n  nodeUri: 'http://127.0.0.1:8545',\n  providerUri: 'https://v4.provider.oceanprotocol.com',\n  subgraphUri: null,\n  explorerUri: null,\n  oceanTokenAddress: null,\n  oceanTokenSymbol: 'OCEAN',\n  fixedRateExchangeAddress: null,\n  dispenserAddress: null,\n  startBlock: 0,\n  transactionBlockTimeout: 50,\n  transactionConfirmationBlocks: 1,\n  transactionPollingTimeout: 750,\n  gasFeeMultiplier: 1\n}\n\nexport const configHelperNetworks: Config[] = [\n  {\n    ...configHelperNetworksBase\n  },\n  {\n    // barge\n    ...configHelperNetworksBase,\n    chainId: 8996,\n    network: 'development',\n    metadataCacheUri: 'http://172.15.0.5:5000', // use http://127.0.0.1:5000/ if running on macOS\n    providerUri: 'http://172.15.0.4:8030', // use http://127.0.0.1:8030/ if running on macOS\n    subgraphUri: 'https://172.15.0.15:8000' // use http://127.0.0.1:9000/ if running on macOS\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 5,\n    network: 'goerli',\n    nodeUri: 'https://goerli.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://goerli.etherscan.io',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1,\n    network: 'mainnet',\n    nodeUri: 'https://mainnet.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.mainnet.oceanprotocol.com',\n    explorerUri: 'https://etherscan.io',\n    startBlock: 11105459,\n    transactionBlockTimeout: 150,\n    transactionConfirmationBlocks: 5,\n    transactionPollingTimeout: 1750,\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 137,\n    network: 'polygon',\n    nodeUri: 'https://polygon-mainnet.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.polygon.oceanprotocol.com',\n    explorerUri: 'https://polygonscan.com',\n    oceanTokenSymbol: 'mOCEAN',\n    gasFeeMultiplier: 1.6\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 2021000,\n    network: 'gaiaxtestnet',\n    nodeUri: 'https://rpc.gaiaxtestnet.oceanprotocol.com',\n    providerUri: 'https://v4.provider.gaiaxtestnet.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.gaiaxtestnet.oceanprotocol.com',\n    explorerUri: 'https://blockscout.gaiaxtestnet.oceanprotocol.com'\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 80001,\n    network: 'mumbai',\n    nodeUri: 'https://polygon-mumbai.infura.io/v3',\n    subgraphUri: 'https://v4.subgraph.mumbai.oceanprotocol.com',\n    explorerUri: 'https://mumbai.polygonscan.com',\n    gasFeeMultiplier: 1.1\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 56,\n    network: 'bsc',\n    nodeUri: 'https://bsc-dataseed.binance.org',\n    subgraphUri: 'https://v4.subgraph.bsc.oceanprotocol.com',\n    explorerUri: 'https://bscscan.com/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 246,\n    network: 'energyweb',\n    nodeUri: 'https://rpc.energyweb.org',\n    subgraphUri: 'https://v4.subgraph.energyweb.oceanprotocol.com',\n    explorerUri: 'https://explorer.energyweb.org',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 1285,\n    network: 'moonriver',\n    nodeUri: 'https://moonriver.api.onfinality.io/public',\n    subgraphUri: 'https://v4.subgraph.moonriver.oceanprotocol.com',\n    explorerUri: 'https://moonriver.moonscan.io/',\n    gasFeeMultiplier: 1.05\n  },\n  {\n    ...configHelperNetworksBase,\n    chainId: 81001,\n    network: 'polygonedge',\n    nodeUri: 'https://rpc-edgenet.polygon.technology',\n    providerUri: 'https://v4.provider.goerli.oceanprotocol.com',\n    subgraphUri: 'https://v4.subgraph.goerli.oceanprotocol.com',\n    explorerUri: 'https://explorer-edgenet.polygon.technology/',\n    gasFeeMultiplier: 1.05\n  }\n]\n\nexport class ConfigHelper {\n  /* Load contract addresses from env ADDRESS_FILE (generated by ocean-contracts) */\n  public getAddressesFromEnv(network: string, customAddresses?: any): Partial<Config> {\n    // use the defaults first\n    let configAddresses: Partial<Config>\n\n    // load from custom addresses structure\n    if (customAddresses) {\n      const {\n        FixedPrice,\n        Dispenser,\n        ERC721Factory,\n        OPFCommunityFeeCollector,\n        Ocean,\n        chainId,\n        startBlock,\n        veAllocate,\n        veOCEAN,\n        veDelegation,\n        veFeeDistributor,\n        veDelegationProxy,\n        DFRewards,\n        DFStrategyV1,\n        veFeeEstimate\n      } = customAddresses[network]\n      configAddresses = {\n        nftFactoryAddress: ERC721Factory,\n        opfCommunityFeeCollector: OPFCommunityFeeCollector,\n        fixedRateExchangeAddress: FixedPrice,\n        dispenserAddress: Dispenser,\n        oceanTokenAddress: Ocean,\n        chainId,\n        startBlock,\n        veAllocate,\n        veOCEAN,\n        veDelegation,\n        veFeeDistributor,\n        veDelegationProxy,\n        DFRewards,\n        DFStrategyV1,\n        veFeeEstimate,\n        ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n      }\n    } else {\n      // no custom addresses structure was passed, trying to load default\n      if (DefaultContractsAddresses[network]) {\n        const {\n          FixedPrice,\n          Dispenser,\n          OPFCommunityFeeCollector,\n          ERC721Factory,\n          Ocean,\n          chainId,\n          startBlock,\n          veAllocate,\n          veOCEAN,\n          veDelegation,\n          veFeeDistributor,\n          veDelegationProxy,\n          DFRewards,\n          DFStrategyV1,\n          veFeeEstimate\n        } = DefaultContractsAddresses[network]\n        configAddresses = {\n          nftFactoryAddress: ERC721Factory,\n          opfCommunityFeeCollector: OPFCommunityFeeCollector,\n          fixedRateExchangeAddress: FixedPrice,\n          dispenserAddress: Dispenser,\n          oceanTokenAddress: Ocean,\n          chainId,\n          startBlock,\n          veAllocate,\n          veOCEAN,\n          veDelegation,\n          veFeeDistributor,\n          veDelegationProxy,\n          DFRewards,\n          DFStrategyV1,\n          veFeeEstimate,\n          ...(process.env.AQUARIUS_URI && { metadataCacheUri: process.env.AQUARIUS_URI })\n        }\n      }\n    }\n    return configAddresses\n  }\n\n  public getConfig(network: string | number, infuraProjectId?: string): Config {\n    const filterBy = typeof network === 'string' ? 'network' : 'chainId'\n    let config = configHelperNetworks.find((c) => c[filterBy] === network)\n\n    if (!config) {\n      LoggerInstance.error(\n        `No config found for given network '${network}' filter by '${filterBy}'`\n      )\n      return null\n    }\n\n    LoggerInstance.debug(\n      `getConfig getAddressesFromEnv after filter by '${filterBy}' to network'${config?.network}'`\n    )\n    const contractAddressesConfig = this.getAddressesFromEnv(config.network)\n    config = { ...config, ...contractAddressesConfig }\n\n    const nodeUri = infuraProjectId\n      ? `${config.nodeUri}/${infuraProjectId}`\n      : config.nodeUri\n\n    return { ...config, nodeUri }\n  }\n}\n","import Web3 from 'web3'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils'\nimport { Config, ConfigHelper } from '../config'\nimport {\n  amountToUnits,\n  getFairGasPrice,\n  setContractDefaults,\n  unitsToAmount\n} from '../utils'\n\nexport abstract class SmartContract {\n  public web3: Web3\n  public config: Config\n  public abi: AbiItem | AbiItem[]\n\n  abstract getDefaultAbi(): AbiItem | AbiItem[]\n\n  /**\n   * Instantiate the smart contract.\n   * @param {Web3} web3\n   * @param {string | number} network Network id or name\n   * @param {Config} config Configutation of the smart contract\n   * @param {AbiItem | AbiItem[]} abi ABI of the smart contract\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[]\n  ) {\n    this.web3 = web3\n    this.config = config || new ConfigHelper().getConfig(network || 'unknown')\n    this.abi = abi || (this.getDefaultAbi() as AbiItem[])\n  }\n\n  protected async amountToUnits(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return amountToUnits(this.web3, token, amount, tokenDecimals)\n  }\n\n  protected async unitsToAmount(\n    token: string,\n    amount: string,\n    tokenDecimals?: number\n  ): Promise<string> {\n    return unitsToAmount(this.web3, token, amount, tokenDecimals)\n  }\n\n  protected async getFairGasPrice(): Promise<string> {\n    return getFairGasPrice(this.web3, this.config?.gasFeeMultiplier)\n  }\n\n  protected getContract(\n    address: string,\n    account?: string,\n    abi?: AbiItem | AbiItem[]\n  ): Contract {\n    const contract = new this.web3.eth.Contract(abi || this.abi, address, {\n      from: account\n    })\n    return setContractDefaults(contract, this.config)\n  }\n}\n","import Web3 from 'web3'\nimport { Contract } from 'web3-eth-contract'\nimport { AbiItem } from 'web3-utils'\nimport { Config } from '../config'\nimport { SmartContract } from './SmartContract'\n\nexport abstract class SmartContractWithAddress extends SmartContract {\n  public address: string\n  public contract: Contract\n\n  /**\n   * Instantiate the smart contract.\n   * @param {string} address Address of the smart contract\n   * @param {Web3} web3\n   * @param {string | number} network Network id or name\n   * @param {Config} config Configutation of the smart contract\n   * @param {AbiItem | AbiItem[]} abi ABI of the smart contract\n   */\n  constructor(\n    address: string,\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[]\n  ) {\n    super(web3, network, config, abi)\n    this.address = address\n    this.contract = this.getContract(this.address)\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport Decimal from 'decimal.js'\nimport DispenserAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/dispenser/Dispenser.sol/Dispenser.json'\nimport { calculateEstimatedGas, sendTx } from '../utils'\nimport { Datatoken } from './Datatoken'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\nimport { DispenserToken, ReceiptOrEstimate } from '../@types'\n\nexport class Dispenser extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return DispenserAbi.abi as AbiItem[]\n  }\n\n  /**\n   * Get information about a datatoken dispenser\n   * @param {String} dtAddress\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async status(dtAdress: string): Promise<DispenserToken> {\n    const status: DispenserToken = await this.contract.methods.status(dtAdress).call()\n    if (!status) {\n      throw new Error(`Np dispenser found for the given datatoken address`)\n    }\n    status.maxTokens = this.web3.utils.fromWei(status.maxTokens)\n    status.maxBalance = this.web3.utils.fromWei(status.maxBalance)\n    status.balance = this.web3.utils.fromWei(status.balance)\n    return status\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Owner address\n   * @param {String} maxTokens max tokens to dispense\n   * @param {String} maxBalance max balance of requester\n   * @param {String} allowedSwapper  only account that can ask tokens. set address(0) if not required\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async create<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    maxTokens: string,\n    maxBalance: string,\n    allowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Call createFixedRate contract method\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.create,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance),\n      address,\n      allowedSwapper\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Activates a new dispener.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {Number} maxTokens max amount of tokens to dispense\n   * @param {Number} maxBalance max balance of user. If user balance is >, then dispense will be rejected\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async activate<G extends boolean = false>(\n    dtAddress: string,\n    maxTokens: string,\n    maxBalance: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.activate,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.activate,\n      dtAddress,\n      this.web3.utils.toWei(maxTokens),\n      this.web3.utils.toWei(maxBalance)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate an existing dispenser.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async deactivate<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.deactivate,\n      dtAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deactivate,\n      dtAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sets a new allowedSwapper.\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the datatoken)\n   * @param {String} newAllowedSwapper refers to the new allowedSwapper\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async setAllowedSwapper<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    newAllowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllowedSwapper,\n      dtAddress,\n      newAllowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Dispense datatokens to caller.\n   * The dispenser must be active, hold enough DT (or be able to mint more)\n   * and respect maxTokens/maxBalance requirements\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address\n   * @param {String} amount amount of datatokens required.\n   * @param {String} destination who will receive the tokens\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async dispense<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    amount: string = '1',\n    destination: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.dispense,\n      dtAddress,\n      this.web3.utils.toWei(amount),\n      destination\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Withdraw all tokens from the dispenser\n   * @param {String} dtAddress refers to datatoken address.\n   * @param {String} address User address (must be owner of the dispenser)\n   * @return {Promise<ReceiptOrEstimate>} TransactionReceipt\n   */\n  public async ownerWithdraw<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.ownerWithdraw,\n      dtAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.ownerWithdraw,\n      dtAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Check if tokens can be dispensed\n   * @param {String} dtAddress\n   * @param {String} address User address that will receive datatokens\n   * @param {String} amount amount of datatokens required.\n   * @return {Promise<Boolean>}\n   */\n  public async isDispensable(\n    dtAddress: string,\n    datatoken: Datatoken,\n    address: string,\n    amount: string = '1'\n  ): Promise<Boolean> {\n    const status = await this.status(dtAddress)\n    if (!status) return false\n    // check active\n    if (status.active === false) return false\n    // check maxBalance\n    const userBalance = new Decimal(await datatoken.balance(dtAddress, address))\n    if (userBalance.greaterThanOrEqualTo(status.maxBalance)) return false\n    // check maxAmount\n    if (new Decimal(String(amount)).greaterThan(status.maxTokens)) return false\n    // check dispenser balance\n    const contractBalance = new Decimal(status.balance)\n    if (contractBalance.greaterThanOrEqualTo(amount) || status.isMinter === true)\n      return true\n    return false\n  }\n}\n","import FixedRateExchangeAbi from '@oceanprotocol/contracts/artifacts/contracts/pools/fixedRate/FixedRateExchange.sol/FixedRateExchange.json'\nimport { AbiItem } from 'web3-utils/types'\nimport { calculateEstimatedGas, sendTx, ZERO_ADDRESS } from '../utils'\nimport { PriceAndFees, FeesInfo, FixedPriceExchange, ReceiptOrEstimate } from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\nexport class FixedRateExchange extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return FixedRateExchangeAbi.abi as AbiItem[]\n  }\n\n  /**\n   * Creates unique exchange identifier.\n   * @param {String} baseToken baseToken contract address\n   * @param {String} datatoken Datatoken contract address\n   * @return {Promise<string>} exchangeId\n   */\n  public async generateExchangeId(baseToken: string, datatoken: string): Promise<string> {\n    const exchangeId = await this.contract.methods\n      .generateExchangeId(baseToken, datatoken)\n      .call()\n    return exchangeId\n  }\n\n  /**\n   * Atomic swap\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} maxBaseTokenAmount max amount of baseToken we want to pay for datatokenAmount\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async buyDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    maxBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0',\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const maxBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      maxBaseTokenAmount,\n      +exchange.btDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.buyDT,\n      exchangeId,\n      dtAmountFormatted,\n      maxBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sell datatokenAmount while expecting at least minBaseTokenAmount\n   * @param {String} exchangeId ExchangeId\n   * @param {String} datatokenAmount Amount of datatokens\n   * @param {String} minBaseTokenAmount min amount of baseToken we want to receive back\n   * @param {String} address User address\n   * @param {String} consumeMarketAddress consumeMarketAddress\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async sellDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    datatokenAmount: string,\n    minBaseTokenAmount: string,\n    consumeMarketAddress: string = ZERO_ADDRESS,\n    consumeMarketFee: string = '0',\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    const consumeMarketFeeFormatted = this.web3.utils.toWei(consumeMarketFee)\n    const dtAmountFormatted = await this.amountToUnits(\n      exchange.datatoken,\n      datatokenAmount,\n      +exchange.dtDecimals\n    )\n    const minBtFormatted = await this.amountToUnits(\n      exchange.baseToken,\n      minBaseTokenAmount,\n      +exchange.btDecimals\n    )\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.sellDT,\n      exchangeId,\n      dtAmountFormatted,\n      minBtFormatted,\n      consumeMarketAddress,\n      consumeMarketFeeFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Gets total number of exchanges\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @return {Promise<Number>} no of available exchanges\n   */\n  public async getNumberOfExchanges(): Promise<number> {\n    const numExchanges = await this.contract.methods.getNumberOfExchanges().call()\n    return numExchanges\n  }\n\n  /**\n   * Set new rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newRate New rate\n   * @param {String} address User account\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setRate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newRate: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setRate,\n      exchangeId,\n      this.web3.utils.toWei(newRate)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setRate,\n      exchangeId,\n      this.web3.utils.toWei(newRate)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Sets a new allowedSwapper\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newAllowedSwapper newAllowedSwapper (set address zero if we want to remove allowed swapper)\n   * @param {String} address User account\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setAllowedSwapper<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newAllowedSwapper: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllowedSwapper,\n      exchangeId,\n      newAllowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Activate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async activate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === true) return null\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate an exchange\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async deactivate<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.active === false) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleExchangeState,\n      exchangeId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get Rate\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} Rate (converted from wei)\n   */\n  public async getRate(exchangeId: string): Promise<string> {\n    const weiRate = await this.contract.methods.getRate(exchangeId).call()\n    const rate = await this.web3.utils.fromWei(weiRate)\n    return rate\n  }\n\n  /**\n   * Get Datatoken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>}  dt supply formatted\n   */\n  public async getDatatokenSupply(exchangeId: string): Promise<string> {\n    const dtSupply = await this.contract.methods.getDTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.datatoken, dtSupply, +exchange.dtDecimals)\n  }\n\n  /**\n   * Get BaseToken Supply in the exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} dt supply formatted\n   */\n  public async getBasetokenSupply(exchangeId: string): Promise<string> {\n    const btSupply = await this.contract.methods.getBTSupply(exchangeId).call()\n    const exchange = await this.getExchange(exchangeId)\n    return await this.unitsToAmount(exchange.baseToken, btSupply, +exchange.btDecimals)\n  }\n\n  /**\n   * Get Allower Swapper (if set this is the only account which can use this exchange, else is set at address(0))\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<string>} address of allowedSwapper\n   */\n  public async getAllowedSwapper(exchangeId: string): Promise<string> {\n    return await this.contract.methods.getAllowedSwapper(exchangeId).call()\n  }\n\n  /**\n   * calcBaseInGivenDatatokensOut - Calculates how many base tokens are needed to get specified amount of datatokens\n   * @param {String} exchangeId ExchangeId\n   * @param {string} datatokenAmount Amount of datatokens user wants to buy\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<PriceAndFees>} how many base tokens are needed and fees\n   */\n  public async calcBaseInGivenDatatokensOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<PriceAndFees> {\n    const fixedRateExchange = await this.getExchange(exchangeId)\n    const outDT = await this.contract.methods\n      .calcBaseInGivenOutDT(\n        exchangeId,\n        await this.amountToUnits(\n          fixedRateExchange.datatoken,\n          datatokenAmount,\n          +fixedRateExchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    const priceAndFees = {\n      baseTokenAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.baseTokenAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      marketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.marketFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      oceanFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.oceanFeeAmount,\n        +fixedRateExchange.btDecimals\n      ),\n      consumeMarketFeeAmount: await this.unitsToAmount(\n        fixedRateExchange.baseToken,\n        outDT.consumeMarketFeeAmount,\n        +fixedRateExchange.btDecimals\n      )\n    } as PriceAndFees\n    return priceAndFees\n  }\n\n  /**\n   * getBTOut - returns amount in baseToken that user will receive for datatokenAmount sold\n   * @param {String} exchangeId ExchangeId\n   * @param {Number} datatokenAmount Amount of datatokens\n   * @param {String} consumeMarketFee consumeMarketFee in fraction\n   * @return {Promise<string>} Amount of baseTokens user will receive\n   */\n  public async getAmountBasetokensOut(\n    exchangeId: string,\n    datatokenAmount: string,\n    consumeMarketFee: string = '0'\n  ): Promise<string> {\n    const exchange = await this.getExchange(exchangeId)\n    const amount = await this.contract.methods\n      .calcBaseOutGivenInDT(\n        exchangeId,\n        await this.amountToUnits(\n          exchange.datatoken,\n          datatokenAmount,\n          +exchange.dtDecimals\n        ),\n        this.web3.utils.toWei(consumeMarketFee)\n      )\n      .call()\n\n    return await this.unitsToAmount(exchange.baseToken, amount[0], +exchange.btDecimals)\n  }\n\n  /**\n   * Get exchange details\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getExchange(exchangeId: string): Promise<FixedPriceExchange> {\n    const exchange: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    exchange.dtDecimals = exchange.dtDecimals.toString()\n    exchange.btDecimals = exchange.btDecimals.toString()\n    exchange.dtBalance = await this.unitsToAmount(\n      exchange.datatoken,\n      exchange.dtBalance,\n      +exchange.dtDecimals\n    )\n    exchange.btBalance = await this.unitsToAmount(\n      exchange.baseToken,\n      exchange.btBalance,\n      +exchange.btDecimals\n    )\n    exchange.dtSupply = await this.unitsToAmount(\n      exchange.datatoken,\n      exchange.dtSupply,\n      +exchange.dtDecimals\n    )\n    exchange.btSupply = await this.unitsToAmount(\n      exchange.baseToken,\n      exchange.btSupply,\n      +exchange.btDecimals\n    )\n    exchange.fixedRate = this.web3.utils.fromWei(exchange.fixedRate)\n    exchange.exchangeId = exchangeId\n    return exchange\n  }\n\n  /**\n   * Get fee details for an exchange\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<FixedPricedExchange>} Exchange details\n   */\n  public async getFeesInfo(exchangeId: string): Promise<FeesInfo> {\n    const feesInfo: FeesInfo = await this.contract.methods.getFeesInfo(exchangeId).call()\n    feesInfo.opcFee = this.web3.utils.fromWei(feesInfo.opcFee.toString())\n    feesInfo.marketFee = this.web3.utils.fromWei(feesInfo.marketFee.toString())\n\n    const exchange = await this.getExchange(exchangeId)\n    feesInfo.marketFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      feesInfo.marketFeeAvailable,\n      +exchange.btDecimals\n    )\n    feesInfo.oceanFeeAvailable = await this.unitsToAmount(\n      exchange.baseToken,\n      feesInfo.oceanFeeAvailable,\n      +exchange.btDecimals\n    )\n\n    feesInfo.exchangeId = exchangeId\n    return feesInfo\n  }\n\n  /**\n   * Get all exchanges\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<String[]>} Exchanges list\n   */\n  public async getExchanges(): Promise<string[]> {\n    return await this.contract.methods.getExchanges().call()\n  }\n\n  /**\n   * Check if an exchange is active\n   * @param {String} exchangeId ExchangeId\n   * @return {Promise<Boolean>} Result\n   */\n  public async isActive(exchangeId: string): Promise<boolean> {\n    const active = await this.contract.methods.isActive(exchangeId).call()\n    return active\n  }\n\n  /**\n   * Activate minting option for fixed rate contract\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async activateMint<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === true) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      true\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      true\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deactivate minting for fixed rate\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async deactivateMint<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n    if (exchange.withMint === false) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      false\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.toggleMintState,\n      exchangeId,\n      false\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect BaseTokens in the contract (anyone can call this, funds are sent to Datatoken.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectBasetokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.baseToken,\n      amount,\n      +fixedrate.btDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectBT,\n      exchangeId,\n      amountWei\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectBT,\n      exchangeId,\n      amountWei\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect datatokens in the contract (anyone can call this, funds are sent to Datatoken.paymentCollector)\n   * @param {String} address User address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} amount amount to be collected\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectDatatokens<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const fixedrate: FixedPriceExchange = await this.contract.methods\n      .getExchange(exchangeId)\n      .call()\n    const amountWei = await this.amountToUnits(\n      fixedrate.datatoken,\n      amount,\n      +fixedrate.dtDecimals\n    )\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectDT,\n      exchangeId,\n      amountWei\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectDT,\n      exchangeId,\n      amountWei\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect market fee and send it to marketFeeCollector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectMarketFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectMarketFee,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectMarketFee,\n      exchangeId\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Collect ocean fee and send it to OPF collector (anyone can call it)\n   * @param {String} exchangeId ExchangeId\n   * @param {String} address User address\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async collectOceanFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const exchange = await this.getExchange(exchangeId)\n    if (!exchange) return null\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.collectOceanFee,\n      exchangeId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.collectOceanFee,\n      exchangeId\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Get OPF Collector of fixed rate contract\n   * @return {String}\n   */\n  async getOPCCollector(): Promise<string> {\n    const address = await this.contract.methods.opcCollector().call()\n    return address\n  }\n\n  /**\n   * Get Router address set in fixed rate contract\n   * @return {String}\n   */\n  public async getRouter(): Promise<string> {\n    const address = await this.contract.methods.router().call()\n    return address\n  }\n\n  /**\n   * Get Exchange Owner given an exchangeId\n   * @param {String} exchangeId ExchangeId\n   * @return {String} return exchange owner\n   */\n  async getExchangeOwner(exchangeId: string): Promise<string> {\n    const address = await (await this.getExchange(exchangeId)).exchangeOwner\n    return address\n  }\n\n  /**\n   * Set new market fee, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFee New market fee\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async updateMarketFee<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newMarketFee: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateMarketFee,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateMarketFee,\n      exchangeId,\n      this.web3.utils.toWei(newMarketFee)\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Set new market fee collector, only market fee collector can update it\n   * @param {String} address user address\n   * @param {String} exchangeId ExchangeId\n   * @param {String} newMarketFeeCollector New market fee collector\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async updateMarketFeeCollector<G extends boolean = false>(\n    address: string,\n    exchangeId: string,\n    newMarketFeeCollector: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateMarketFeeCollector,\n      exchangeId,\n      newMarketFeeCollector\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport FactoryRouter from '@oceanprotocol/contracts/artifacts/contracts/pools/FactoryRouter.sol/FactoryRouter.json'\nimport { calculateEstimatedGas, sendTx } from '../utils'\nimport { Operation, ReceiptOrEstimate } from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\n/**\n * Provides an interface for FactoryRouter contract\n */\nexport class Router extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return FactoryRouter.abi as AbiItem[]\n  }\n\n  /**\n   * buyDatatokenBatch\n   * @param {String} address\n   * @param {Operation} operations Operations objects array\n   * @return {Promise<ReceiptOrEstimate>} Transaction receipt\n   */\n  public async buyDatatokenBatch<G extends boolean = false>(\n    address: string,\n    operations: Operation[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.buyDTBatch,\n      operations\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.buyDTBatch,\n      operations\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Check if a token is on approved tokens list, if true opfFee is lower in pools with that token/DT\n   * @return {Promise<boolean>} true if is on the list.\n   */\n  public async isApprovedToken(address: string): Promise<boolean> {\n    return await this.contract.methods.isApprovedToken(address).call()\n  }\n\n  /** Check if an address is a Fixed Rate contract.\n   * @return {Promise<boolean>} true if is a Fixed Rate contract\n   */\n  public async isFixedPrice(address: string): Promise<boolean> {\n    return await this.contract.methods.isFixedRateContract(address).call()\n  }\n\n  /** Get Router Owner\n   * @return {Promise<string>} Router Owner address\n   */\n  public async getOwner(): Promise<string> {\n    return await this.contract.methods.routerOwner().call()\n  }\n\n  /** Get NFT Factory address\n   * @return {Promise<string>} NFT Factory address\n   */\n  public async getNFTFactory(): Promise<string> {\n    return await this.contract.methods.factory().call()\n  }\n\n  /**\n   * Adds a token to the list of tokens with reduced fees\n   * @param {String} address caller address\n   * @param {String} tokenAddress token address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addApprovedToken<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addApprovedToken,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addApprovedToken,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes a token if exists from the list of tokens with reduced fees\n   * @param {String} address\n   * @param {String} tokenAddress address to remove\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeApprovedToken<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeApprovedToken,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeApprovedToken,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Adds an address to the list of fixed rate contracts\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addFixedRateContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addFixedRateContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addFixedRateContract,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes an address from the list of fixed rate contracts\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeFixedRateContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeFixedRateContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeFixedRateContract,\n      tokenAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Adds an address to the list of dispensers\n   * @param {String} address\n   * @param {String} tokenAddress contract address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addDispenserContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addDispenserContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addDispenserContract,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes an address from the list of dispensers\n   * @param {String} address\n   * @param {String} tokenAddress address Contract to be removed\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async removeDispenserContract<G extends boolean = false>(\n    address: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.removeDispenserContract,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.removeDispenserContract,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get OPF Fee per token\n   * @return {Promise<number>} OPC fee for a specific baseToken\n   */\n  public async getOPCFee(baseToken: string): Promise<number> {\n    return await this.contract.methods.getOPCFee(baseToken).call()\n  }\n\n  /** Get Current OPF Fee\n   * @return {Promise<number>} OPF fee\n   */\n  public async getCurrentOPCFee(): Promise<number> {\n    return await this.contract.methods.swapOceanFee().call()\n  }\n\n  /**\n   * Updates OP Community Fees\n   * @param {String} address\n   * @param {number} newSwapOceanFee Amount charged for swapping with ocean approved tokens\n   * @param {number} newSwapNonOceanFee Amount charged for swapping with non ocean approved tokens\n   * @param {number} newConsumeFee Amount charged from consumeFees\n   * @param {number} newProviderFee Amount charged for providerFees\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async updateOPCFee<G extends boolean = false>(\n    address: string,\n    newSwapOceanFee: number,\n    newSwapNonOceanFee: number,\n    newConsumeFee: number,\n    newProviderFee: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Router Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.updateOPCFee,\n      newSwapOceanFee,\n      newSwapNonOceanFee,\n      newConsumeFee,\n      newProviderFee\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport ERC721Template from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC721Template.sol/ERC721Template.json'\nimport { generateDtName, calculateEstimatedGas, sendTx } from '../utils'\nimport {\n  MetadataProof,\n  MetadataAndTokenURI,\n  NftRoles,\n  ReceiptOrEstimate\n} from '../@types'\nimport { SmartContract } from './SmartContract'\n\nexport class Nft extends SmartContract {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC721Template.abi as AbiItem[]\n  }\n\n  /**\n   * Create new ERC20 Datatoken - only user with DatatokenDeployer permission can succeed\n   * @param {String} nftAddress NFT address\n   * @param {String} address User address\n   * @param {String} minter User set as initial minter for the Datatoken\n   * @param {String} paymentCollector initial paymentCollector for this DT\n   * @param {String} mpFeeAddress Consume marketplace fee address\n   * @param {String} feeToken address of the token marketplace wants to add fee on top\n   * @param {String} feeAmount amount of feeToken to be transferred to mpFeeAddress on top, will be converted to WEI\n   * @param {String} cap Maximum cap (Number) - will be converted to wei\n   * @param {String} name Token name\n   * @param {String} symbol Token symbol\n   * @param {Number} templateIndex NFT template index\n   * @return {Promise<string>} ERC20 Datatoken address\n   */\n  public async createDatatoken<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    minter: string,\n    paymentCollector: string,\n    mpFeeAddress: string,\n    feeToken: string,\n    feeAmount: string,\n    cap: string,\n    name?: string,\n    symbol?: string,\n    templateIndex?: number,\n    estimateGas?: G\n  ): Promise<G extends false ? string : number> {\n    if ((await this.getNftPermissions(nftAddress, address)).deployERC20 !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n    if (!templateIndex) templateIndex = 1\n\n    // Generate name & symbol if not present\n    if (!name || !symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n\n    // Create 721contract object\n    const nftContract = this.getContract(nftAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n    if (estimateGas) return <G extends false ? string : number>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.createERC20,\n      templateIndex,\n      [name, symbol],\n      [minter, paymentCollector, mpFeeAddress, feeToken],\n      [this.web3.utils.toWei(cap), this.web3.utils.toWei(feeAmount)],\n      []\n    )\n\n    return trxReceipt?.events?.TokenCreated?.returnValues?.[0]\n  }\n\n  /**\n   * Add Manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be assing manager\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addManager<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addManager,\n      manager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addManager,\n      manager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Removes a specific manager for NFT Contract (only NFT Owner can succeed)\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @param {String} manager User adress which is going to be removed as manager\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeManager<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    manager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeManager,\n      manager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeManager,\n      manager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add DatatokenDeployer permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} datatokenDeployer User adress which is going to have DatatokenDeployer permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addDatatokenDeployer<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    datatokenDeployer: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    // Estimate gas for addToCreateERC20List method\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addToCreateERC20List,\n      datatokenDeployer\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addToCreateERC20List,\n      datatokenDeployer\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove DatatokenDeployer permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} datatokenDeployer Address of the user to be revoked DatatokenDeployer Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeDatatokenDeployer<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    datatokenDeployer: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address === datatokenDeployer &&\n        (await this.getNftPermissions(nftAddress, address)).deployERC20 !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor DatatokenDeployer`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFromCreateERC20List,\n      datatokenDeployer\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFromCreateERC20List,\n      datatokenDeployer\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater User adress which is going to have Metadata Updater permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addMetadataUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addToMetadataList,\n      metadataUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addToMetadataList,\n      metadataUpdater\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove Metadata Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} metadataUpdater Address of the user to be revoked Metadata updater Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeMetadataUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== metadataUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).updateMetadata !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor Metadata Updater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFromMetadataList,\n      metadataUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFromMetadataList,\n      metadataUpdater\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater User adress which is going to have Store Updater permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async addStoreUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftPermissions(nftAddress, address)).manager !== true) {\n      throw new Error(`Caller is not Manager`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.addTo725StoreList,\n      storeUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.addTo725StoreList,\n      storeUpdater\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Remove Store Updater permission - only Manager can succeed\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Manager adress\n   * @param {String} storeUpdater Address of the user to be revoked Store Updater Permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removeStoreUpdater<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    storeUpdater: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (\n      (await this.getNftPermissions(nftAddress, address)).manager !== true ||\n      (address !== storeUpdater &&\n        (await this.getNftPermissions(nftAddress, address)).store !== true)\n    ) {\n      throw new Error(`Caller is not Manager nor storeUpdater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.removeFrom725StoreList,\n      storeUpdater\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.removeFrom725StoreList,\n      storeUpdater\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * This function allows to remove all ROLES at NFT level: Managers, DatatokenDeployer, MetadataUpdater, StoreUpdater\n   * Even NFT Owner has to readd himself as Manager\n   * Permissions at Datatoken level stay.\n   * Only NFT Owner  can call it.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address NFT Owner adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async cleanPermissions<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== address) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.cleanPermissions\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.cleanPermissions\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Transfers the NFT\n   * will clean all permissions both on NFT and Datatoken level.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async transferNft<G extends boolean = false>(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await calculateEstimatedGas(\n      nftOwner,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      nftOwner,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.transferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * safeTransferNFT Used for transferring the NFT, can be used by an approved relayer\n   * will clean all permissions both on NFT and Datatoken level.\n   * @param {String} nftAddress NFT contract address\n   * @param {String} nftOwner Current NFT Owner adress\n   * @param {String} nftReceiver User which will receive the NFT, will also be set as Manager\n   * @param {Number} tokenId The id of the token to be transfered\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async safeTransferNft<G extends boolean = false>(\n    nftAddress: string,\n    nftOwner: string,\n    nftReceiver: string,\n    tokenId?: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if ((await this.getNftOwner(nftAddress)) !== nftOwner) {\n      throw new Error(`Caller is not NFT Owner`)\n    }\n\n    const tokenIdentifier = tokenId || 1\n\n    const estGas = await calculateEstimatedGas(\n      nftOwner,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      nftOwner,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.safeTransferFrom,\n      nftOwner,\n      nftReceiver,\n      tokenIdentifier\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates or update Metadata cached by Aquarius. Also, updates the METADATA_DECRYPTOR key\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @param {String} address Caller address NFT Owner adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadata<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    metadataDecryptorUrl: string,\n    metadataDecryptorAddress: string,\n    flags: string,\n    data: string,\n    metadataHash: string,\n    metadataProofs?: MetadataProof[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n    if (!metadataProofs) metadataProofs = []\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaData,\n      metadataState,\n      metadataDecryptorUrl,\n      metadataDecryptorAddress,\n      flags,\n      data,\n      metadataHash,\n      metadataProofs\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   *  Helper function to improve UX sets both MetaData & TokenURI in one tx\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address\n   * @param {MetadataAndTokenURI} metadataAndTokenURI metaDataAndTokenURI object\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadataAndTokenURI<G extends boolean = false>(\n    nftAddress: string,\n    metadataUpdater: string,\n    metadataAndTokenURI: MetadataAndTokenURI,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n    if (!(await this.getNftPermissions(nftAddress, metadataUpdater)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n    const sanitizedMetadataAndTokenURI = {\n      ...metadataAndTokenURI,\n      metadataProofs: metadataAndTokenURI.metadataProofs || []\n    }\n    const estGas = await calculateEstimatedGas(\n      metadataUpdater,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      metadataUpdater,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaDataAndTokenURI,\n      sanitizedMetadataAndTokenURI\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * setMetadataState Used for updating the metadata State\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address Caller address => metadata updater\n   * @param {Number} metadataState new metadata state\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setMetadataState<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    metadataState: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    if (!(await this.getNftPermissions(nftAddress, address)).updateMetadata) {\n      throw new Error(`Caller is not Metadata updater`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setMetaDataState,\n      metadataState\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** set TokenURI on an nft\n   * @param nftAddress NFT contract address\n   * @param address user adress\n   * @param data input data for TokenURI\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async setTokenURI<G extends boolean = false>(\n    nftAddress: string,\n    address: string,\n    data: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const nftContract = this.getContract(nftAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setTokenURI,\n      '1',\n      data\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setTokenURI,\n      '1',\n      data\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get Owner\n   * @param {String} nftAddress NFT contract address\n   * @return {Promise<string>} string\n   */\n  public async getNftOwner(nftAddress: string): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const trxReceipt = await nftContract.methods.ownerOf(1).call()\n    return trxReceipt\n  }\n\n  /** Get users NFT Permissions\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address user adress\n   * @return {Promise<NftRoles>}\n   */\n  public async getNftPermissions(nftAddress: string, address: string): Promise<NftRoles> {\n    const nftContract = this.getContract(nftAddress)\n    const roles = await nftContract.methods.getPermissions(address).call()\n    return roles\n  }\n\n  /** Get users Metadata, return Metadata details\n   * @param {String} nftAddress NFT contract address\n   * @return {Promise<Objecta>}\n   */\n  public async getMetadata(nftAddress: string): Promise<Object> {\n    const nftContract = this.getContract(nftAddress)\n    return await nftContract.methods.getMetaData().call()\n  }\n\n  /** Get users DatatokenDeployer role\n   * @param {String} nftAddress NFT contract address\n   * @param {String} address user adress\n   * @return {Promise<boolean>}\n   */\n  public async isDatatokenDeployer(\n    nftAddress: string,\n    address: string\n  ): Promise<boolean> {\n    const nftContract = this.getContract(nftAddress)\n    const isDatatokenDeployer = await nftContract.methods.isERC20Deployer(address).call()\n    return isDatatokenDeployer\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\n   * only ERC20Deployer can succeed\n   * @param nftAddress erc721 contract adress\n   * @param address user adress\n   * @param key Key of the data to be stored into 725Y standard\n   * @param value Data to be stored into 725Y standard\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async setData(\n    nftAddress: string,\n    address: string,\n    key: string,\n    value: string\n  ): Promise<TransactionReceipt> {\n    if ((await this.getNftPermissions(nftAddress, address)).store !== true) {\n      throw new Error(`User is not ERC20 store updater`)\n    }\n\n    const nftContract = this.getContract(nftAddress)\n\n    const keyHash = this.web3.utils.keccak256(key)\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      nftContract.methods.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      nftContract.methods.setNewData,\n      keyHash,\n      valueHex\n    )\n\n    return trxReceipt\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress NFT contract address\n   * @param {String} key the key which value to retrieve\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getData(nftAddress: string, key: string): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const keyHash = this.web3.utils.keccak256(key)\n    const data = await nftContract.methods.getData(keyHash).call()\n    return data ? this.web3.utils.hexToAscii(data) : null\n  }\n\n  /** Gets data at a given `key`\n   * @param {String} nftAddress NFT contract address\n   * @param {String} id\n   * @return {Promise<string>} The data stored at the key\n   */\n  public async getTokenURI(nftAddress: string, id: number): Promise<string> {\n    const nftContract = this.getContract(nftAddress)\n    const data = await nftContract.methods.tokenURI(id).call()\n    return data\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { TransactionReceipt } from 'web3-eth'\nimport Decimal from 'decimal.js'\nimport ERC20Template from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20Template.sol/ERC20Template.json'\nimport ERC20TemplateEnterprise from '@oceanprotocol/contracts/artifacts/contracts/templates/ERC20TemplateEnterprise.sol/ERC20TemplateEnterprise.json'\nimport { amountToUnits, sendTx, calculateEstimatedGas, ZERO_ADDRESS } from '../utils'\nimport {\n  ConsumeMarketFee,\n  FreOrderParams,\n  FreCreationParams,\n  ProviderFees,\n  PublishingMarketFee,\n  DispenserParams,\n  OrderParams,\n  DatatokenRoles,\n  ReceiptOrEstimate\n} from '../@types'\nimport { Nft } from './NFT'\nimport { Config } from '../config'\nimport { SmartContract } from './SmartContract'\n\nexport class Datatoken extends SmartContract {\n  public abiEnterprise: AbiItem | AbiItem[]\n  public nft: Nft\n\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC20Template.abi as AbiItem[]\n  }\n\n  /**\n   * Instantiate ERC20 Datatokens\n   * @param {AbiItem | AbiItem[]} datatokensAbi\n   * @param {Web3} web3\n   */\n  constructor(\n    web3: Web3,\n    network?: string | number,\n    config?: Config,\n    abi?: AbiItem | AbiItem[],\n    abiEnterprise?: AbiItem | AbiItem[]\n  ) {\n    super(web3, network, config, abi)\n    this.abiEnterprise = abiEnterprise || (ERC20TemplateEnterprise.abi as AbiItem[])\n    this.nft = new Nft(this.web3)\n  }\n\n  /**\n   * Approve\n   * @param {String} dtAddress Datatoken address\n   * @param {String} spender Spender address\n   * @param {string} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async approve<G extends boolean = false>(\n    dtAddress: string,\n    spender: string,\n    amount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.approve,\n      spender,\n      this.web3.utils.toWei(amount)\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates a new FixedRateExchange setup.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} fixedPriceAddress\n   * @param {FixedRateParams} fixedRateParams\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async createFixedRate<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    fixedRateParams: FreCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n    if (!fixedRateParams.allowedConsumer) fixedRateParams.allowedConsumer = ZERO_ADDRESS\n\n    const withMint = fixedRateParams.withMint === false ? 0 : 1\n\n    // should check DatatokenDeployer role using NFT level ..\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.createFixedRate,\n      fixedRateParams.fixedRateAddress,\n      [\n        fixedRateParams.baseTokenAddress,\n        fixedRateParams.owner,\n        fixedRateParams.marketFeeCollector,\n        fixedRateParams.allowedConsumer\n      ],\n      [\n        fixedRateParams.baseTokenDecimals,\n        fixedRateParams.datatokenDecimals,\n        fixedRateParams.fixedRate,\n        fixedRateParams.marketFee,\n        withMint\n      ]\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Creates a new Dispenser\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Caller address\n   * @param {String} dispenserAddress ispenser contract address\n   * @param {String} dispenserParams\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async createDispenser<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    dispenserAddress: string,\n    dispenserParams: DispenserParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n\n    const dtContract = this.getContract(dtAddress)\n\n    if (!dispenserParams.allowedSwapper) dispenserParams.allowedSwapper = ZERO_ADDRESS\n\n    dispenserParams.withMint = dispenserParams.withMint !== false\n\n    // should check DatatokenDeployer role using NFT level ..\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.createDispenser,\n      dispenserAddress,\n      dispenserParams.maxTokens,\n      dispenserParams.maxBalance,\n      dispenserParams.withMint,\n      dispenserParams.allowedSwapper\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Mint\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address Minter address\n   * @param {String} amount Number of datatokens, as number. Will be converted to wei\n   * @param {String} toAddress only if toAddress is different from the minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async mint<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    amount: string,\n    toAddress?: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.getPermissions(dtAddress, address)).minter !== true) {\n      throw new Error(`Caller is not Minter`)\n    }\n\n    const capAvailble = await this.getCap(dtAddress)\n    if (new Decimal(capAvailble).gte(amount)) {\n      const estGas = await calculateEstimatedGas(\n        address,\n        dtContract.methods.mint,\n        toAddress || address,\n        this.web3.utils.toWei(amount)\n      )\n      if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n      const trxReceipt = await sendTx(\n        address,\n        estGas + 1,\n        this.web3,\n        this.config?.gasFeeMultiplier,\n        dtContract.methods.mint,\n        toAddress || address,\n        this.web3.utils.toWei(amount)\n      )\n      return <ReceiptOrEstimate<G>>trxReceipt\n    } else {\n      throw new Error(`Mint amount exceeds cap available`)\n    }\n  }\n\n  /**\n   * Add Minter for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which is going to be a Minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async addMinter<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n    // Estimate gas cost for addMinter method\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.addMinter,\n      minter\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.addMinter,\n      minter\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Revoke Minter permission for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} minter User which will be removed from Minter permission\n   * @param {Contract} contractInstance optional contract instance\n   * @return {Promise<any>}\n   */\n  public async removeMinter<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    minter: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.removeMinter,\n      minter\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.removeMinter,\n      minter\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add addPaymentManager (can set who's going to collect fee when consuming orders)\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which is going to be a Minter\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async addPaymentManager<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.addPaymentManager,\n      paymentManager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.addPaymentManager,\n      paymentManager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Revoke paymentManager permission for an ERC20 Datatoken\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} paymentManager User which will be removed from paymentManager permission\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async removePaymentManager<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentManager: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    if ((await this.isDatatokenDeployer(dtAddress, address)) !== true) {\n      throw new Error(`Caller is not DatatokenDeployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.removePaymentManager,\n      paymentManager\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.removePaymentManager,\n      paymentManager\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * This function allows to set a new PaymentCollector (receives DT when consuming)\n   * If not set the paymentCollector is the NFT Owner\n   * only NFT owner can call\n   * @param dtAddress datatoken address\n   * @param address Caller address\n   * @param paymentCollector User to be set as new payment collector\n   * @return {Promise<ReceiptOrEstimate>} trxReceipt\n   */\n  public async setPaymentCollector<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    paymentCollector: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    const isPaymentManager = (await this.getPermissions(dtAddress, address))\n      .paymentManager\n    const nftAddress = !isPaymentManager && (await this.getNFTAddress(dtAddress))\n    const isNftOwner = nftAddress && (await this.nft.getNftOwner(nftAddress)) === address\n    const nftPermissions =\n      nftAddress && !isNftOwner && (await this.nft.getNftPermissions(nftAddress, address))\n    const isDatatokenDeployer = nftPermissions?.deployERC20\n    if (!isPaymentManager && !isNftOwner && !isDatatokenDeployer) {\n      throw new Error(`Caller is not Fee Manager, owner or Datatoken Deployer`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setPaymentCollector,\n      paymentCollector\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setPaymentCollector,\n      paymentCollector\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** getPaymentCollector - It returns the current paymentCollector\n   * @param dtAddress datatoken address\n   * @return {Promise<string>}\n   */\n  public async getPaymentCollector(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const paymentCollector = await dtContract.methods.getPaymentCollector().call()\n    return paymentCollector\n  }\n\n  /**\n   * Transfer as number from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. To be converted to wei.\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async transfer(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string\n  ): Promise<TransactionReceipt> {\n    const weiAmount = this.web3.utils.toWei(amount)\n    return this.transferWei(dtAddress, toAddress, weiAmount, address)\n  }\n\n  /**\n   * Transfer in wei from address to toAddress\n   * @param {String} dtAddress Datatoken address\n   * @param {String} toAddress Receiver address\n   * @param {String} amount Number of datatokens, as number. Expressed as wei\n   * @param {String} address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async transferWei<G extends boolean = false>(\n    dtAddress: string,\n    toAddress: string,\n    amount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.transfer,\n      toAddress,\n      amount\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.transfer,\n      toAddress,\n      amount\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Start Order: called by payer or consumer prior ordering a service consume on a marketplace.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} consumer Consumer Address\n   * @param {Number} serviceIndex  Service index in the metadata\n   * @param {providerFees} providerFees provider fees\n   * @param {consumeMarketFee} ConsumeMarketFee consume market fees\n   * @return {Promise<ReceiptOrEstimate>} string\n   */\n  public async startOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    consumer: string,\n    serviceIndex: number,\n    providerFees: ProviderFees,\n    consumeMarketFee?: ConsumeMarketFee,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n    if (!consumeMarketFee) {\n      consumeMarketFee = {\n        consumeMarketFeeAddress: ZERO_ADDRESS,\n        consumeMarketFeeToken: ZERO_ADDRESS,\n        consumeMarketFeeAmount: '0'\n      }\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.startOrder,\n      consumer,\n      serviceIndex,\n      providerFees,\n      consumeMarketFee\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Reuse Order: called by payer or consumer having a valid order, but with expired provider access.\n   * Pays the provider fee again, but it will not require a new datatoken payment\n   * Requires previous approval of provider fee.\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {String} orderTxId previous valid order\n   * @param {providerFees} providerFees provider fees\n   * @return {Promise<ReceiptOrEstimate>} string\n   */\n  public async reuseOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderTxId: string,\n    providerFees: ProviderFees,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.reuseOrder,\n      orderTxId,\n      providerFees\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.reuseOrder,\n      orderTxId,\n      providerFees\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Buys 1 DT from the FRE and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams Consumer Address\n   * @param {FreParams} freParams Amount of tokens that is going to be transfered\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async buyFromFreAndOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    freParams: FreOrderParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress, null, this.abiEnterprise)\n\n    const freContractParams = await this.getFreOrderParams(freParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.buyFromFreAndOrder,\n      orderParams,\n      freContractParams\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.buyFromFreAndOrder,\n      orderParams,\n      freContractParams\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Gets DT from dispenser and then startsOrder, while burning that DT\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address which calls\n   * @param {OrderParams} orderParams\n   * @param {String} dispenserContract\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async buyFromDispenserAndOrder<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    orderParams: OrderParams,\n    dispenserContract: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(dtAddress, null, this.abiEnterprise)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.buyFromDispenserAndOrder,\n      orderParams,\n      dispenserContract\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** setData\n   * This function allows to store data with a preset key (keccak256(dtAddress)) into NFT 725 Store\n   * only DatatokenDeployer can succeed\n   * @param {String} dtAddress Datatoken address\n   * @param {String} address User address\n   * @param {String} value Data to be stored into 725Y standard\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async setData<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    value: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (!(await this.isDatatokenDeployer(dtAddress, address))) {\n      throw new Error(`User is not Datatoken Deployer`)\n    }\n\n    const dtContract = this.getContract(dtAddress)\n\n    const valueHex = this.web3.utils.asciiToHex(value)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setData,\n      valueHex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setData,\n      valueHex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Clean Datatoken level Permissions (minters, paymentManager and reset the paymentCollector) for an ERC20 Datatoken\n   * Only NFT Owner (at 721 level) can call it.\n   * @param dtAddress Datatoken address where we want to clean permissions\n   * @param address User adress\n   * @return {Promise<ReceiptOrEstimate>} transactionId\n   */\n  public async cleanPermissions<G extends boolean = false>(\n    dtAddress: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.nft.getNftOwner(await this.getNFTAddress(dtAddress))) !== address) {\n      throw new Error('Caller is NOT Nft Owner')\n    }\n    const dtContract = this.getContract(dtAddress)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.cleanPermissions\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.cleanPermissions\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Returns ERC20 Datatoken user's permissions for a datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<DatatokenRoles>}\n   */\n  public async getPermissions(\n    dtAddress: string,\n    address: string\n  ): Promise<DatatokenRoles> {\n    const dtContract = this.getContract(dtAddress)\n    const roles = await dtContract.methods.permissions(address).call()\n    return roles\n  }\n\n  /** Returns the Datatoken capital\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<string>}\n   */\n  public async getCap(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const cap = await dtContract.methods.cap().call()\n    return this.web3.utils.fromWei(cap)\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getDecimals(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const decimals = await dtContract.methods.decimals().call()\n    return decimals\n  }\n\n  /** It returns the token symbol\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getSymbol(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const symbol = await dtContract.methods.symbol().call()\n    return symbol\n  }\n\n  /** It returns the name of the token\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getName(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const name = await dtContract.methods.name().call()\n    return name\n  }\n\n  /** It returns the token decimals, how many supported decimal points\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<number>}\n   */\n  public async getNFTAddress(dtAddress: string): Promise<string> {\n    const dtContract = this.getContract(dtAddress)\n    const nftAddress = await dtContract.methods.getERC721Address().call()\n    return nftAddress\n  }\n\n  /**  Returns true if address has deployERC20 role\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} dtAddress Datatoken adress\n   * @return {Promise<boolean>}\n   */\n  public async isDatatokenDeployer(dtAddress: string, address: string): Promise<boolean> {\n    const dtContract = this.getContract(dtAddress)\n    const isDatatokenDeployer = await dtContract.methods.isERC20Deployer(address).call()\n    return isDatatokenDeployer\n  }\n\n  /**\n   * Get Address Balance for datatoken\n   * @param {String} dtAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<String>} balance  Number of datatokens. Will be converted from wei\n   */\n  public async balance(datatokenAddress: string, address: string): Promise<string> {\n    const dtContract = this.getContract(datatokenAddress, address)\n    const balance = await dtContract.methods.balanceOf(address).call()\n    return this.web3.utils.fromWei(balance)\n  }\n\n  /**\n   * @dev setPublishingMarketFee\n   *      Only publishMarketFeeAddress can call it\n   *      This function allows to set the fee required by the publisherMarket\n   * @param {string} datatokenAddress Datatoken adress\n   * @param {string} publishMarketFeeAddress  new publish Market Fee Address\n   * @param {string} publishMarketFeeToken new publish Market Fee Token\n   * @param {string} publishMarketFeeAmount new fee amount\n   * @param {String} address user adress\n   */\n  public async setPublishingMarketFee<G extends boolean = false>(\n    datatokenAddress: string,\n    publishMarketFeeAddress: string,\n    publishMarketFeeToken: string,\n    publishMarketFeeAmount: string,\n    address: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const dtContract = this.getContract(datatokenAddress, address)\n    const mktFeeAddress = (await dtContract.methods.getPublishingMarketFee().call())[0]\n    if (mktFeeAddress !== address) {\n      throw new Error(`Caller is not the Publishing Market Fee Address`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      dtContract.methods.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      dtContract.methods.setPublishingMarketFee,\n      publishMarketFeeAddress,\n      publishMarketFeeToken,\n      publishMarketFeeAmount\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev getPublishingMarketFee\n   *      Get publishingMarket Fee\n   *      This function allows to get the current fee set by the publishing market\n   * @param {String} datatokenAddress Datatoken adress\n   * @param {String} address user adress\n   * @return {Promise<PublishingMarketFee>} Current fee set by the publishing market\n   */\n  public async getPublishingMarketFee(\n    datatokenAddress: string,\n    address: string\n  ): Promise<PublishingMarketFee> {\n    const dtContract = this.getContract(datatokenAddress, address)\n\n    const publishingMarketFee = await dtContract.methods.getPublishingMarketFee().call()\n    const returnValues = {\n      publishMarketFeeAddress: publishingMarketFee[0],\n      publishMarketFeeToken: publishingMarketFee[1],\n      publishMarketFeeAmount: publishingMarketFee[2]\n    }\n    return returnValues\n  }\n\n  private async getFreOrderParams(freParams: FreOrderParams): Promise<any> {\n    return {\n      exchangeContract: freParams.exchangeContract,\n      exchangeId: freParams.exchangeId,\n      maxBaseTokenAmount: await amountToUnits(\n        this.web3,\n        freParams.baseTokenAddress,\n        freParams.maxBaseTokenAmount,\n        freParams.baseTokenDecimals\n      ),\n      swapMarketFee: await amountToUnits(\n        this.web3,\n        freParams.baseTokenAddress,\n        freParams.swapMarketFee,\n        freParams.baseTokenDecimals\n      ),\n\n      marketFeeAddress: freParams.marketFeeAddress\n    }\n  }\n}\n","import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport ERC721Factory from '@oceanprotocol/contracts/artifacts/contracts/ERC721Factory.sol/ERC721Factory.json'\nimport { generateDtName, calculateEstimatedGas, ZERO_ADDRESS, sendTx } from '../utils'\nimport {\n  FreCreationParams,\n  DatatokenCreateParams,\n  DispenserCreationParams,\n  NftCreateData,\n  Template,\n  TokenOrder,\n  ReceiptOrEstimate\n} from '../@types'\nimport { SmartContractWithAddress } from './SmartContractWithAddress'\n\n/**\n * Provides an interface for NFT Factory contract\n */\nexport class NftFactory extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return ERC721Factory.abi as AbiItem[]\n  }\n\n  /**\n   * Create new NFT\n   * @param {String} address\n   * @param {NFTCreateData} nftData\n   * @return {Promise<string>} NFT datatoken address\n   */\n  public async createNFT<G extends boolean = false>(\n    address: string,\n    nftData: NftCreateData,\n    estimateGas?: G\n  ): Promise<G extends false ? string : number> {\n    if (!nftData.templateIndex) nftData.templateIndex = 1\n\n    if (!nftData.name || !nftData.symbol) {\n      const { name, symbol } = generateDtName()\n      nftData.name = name\n      nftData.symbol = symbol\n    }\n    if (nftData.templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (nftData.templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getNFTTemplate(nftData.templateIndex)).isActive === false) {\n      throw new Error(`Template is not active`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n    if (estimateGas) return <G extends false ? string : number>estGas\n\n    // Invoke createToken function of the contract\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deployERC721Contract,\n      nftData.name,\n      nftData.symbol,\n      nftData.templateIndex,\n      ZERO_ADDRESS,\n      ZERO_ADDRESS,\n      nftData.tokenURI,\n      nftData.transferable,\n      nftData.owner\n    )\n    return trxReceipt?.events?.NFTCreated?.returnValues?.[0]\n  }\n\n  /** Get Current NFT Count (NFT created)\n   * @return {Promise<number>} Number of NFT created from this factory\n   */\n  public async getCurrentNFTCount(): Promise<number> {\n    const nftCount = await this.contract.methods.getCurrentNFTCount().call()\n    return nftCount\n  }\n\n  /** Get Current Datatoken Count\n   * @return {Promise<number>} Number of DTs created from this factory\n   */\n  public async getCurrentTokenCount(): Promise<number> {\n    const tokenCount = await this.contract.methods.getCurrentTokenCount().call()\n    return tokenCount\n  }\n\n  /** Get Factory Owner\n   * @return {Promise<string>} Factory Owner address\n   */\n  public async getOwner(): Promise<string> {\n    const owner = await this.contract.methods.owner().call()\n    return owner\n  }\n\n  /** Get Current NFT Template Count\n   * @return {Promise<number>} Number of NFT Template added to this factory\n   */\n  public async getCurrentNFTTemplateCount(): Promise<number> {\n    const count = await this.contract.methods.getCurrentNFTTemplateCount().call()\n    return count\n  }\n\n  /** Get Current Template  Datatoken (ERC20) Count\n   * @return {Promise<number>} Number of Datatoken Template added to this factory\n   */\n  public async getCurrentTokenTemplateCount(): Promise<number> {\n    const count = await this.contract.methods.getCurrentTemplateCount().call()\n    return count\n  }\n\n  /** Get NFT Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} Number of Template added to this factory\n   */\n  public async getNFTTemplate(index: number): Promise<Template> {\n    if (index > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (index === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const template = await this.contract.methods.getNFTTemplate(index).call()\n    return template\n  }\n\n  /** Get Datatoken (ERC20) Template\n   * @param {Number} index Template index\n   * @return {Promise<Template>} DT Template info\n   */\n  public async getTokenTemplate(index: number): Promise<Template> {\n    const template = await this.contract.methods.getTokenTemplate(index).call()\n    return template\n  }\n\n  /** Check if Datatoken is deployed from the factory\n   * @param {String} datatoken Datatoken address we want to check\n   * @return {Promise<Boolean>} return true if deployed from this factory\n   */\n  public async checkDatatoken(datatoken: string): Promise<Boolean> {\n    const isDeployed = await this.contract.methods.erc20List(datatoken).call()\n    return isDeployed\n  }\n\n  /** Check if  NFT is deployed from the factory\n   * @param {String} nftAddress nftAddress address we want to check\n   * @return {Promise<String>} return address(0) if it's not, or the nftAddress if true\n   */\n  public async checkNFT(nftAddress: string): Promise<String> {\n    const confirmAddress = await this.contract.methods.erc721List(nftAddress).call()\n    return confirmAddress\n  }\n\n  /**\n   * Add a new NFT token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be ZERO address`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.add721TokenTemplate,\n      templateAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.add721TokenTemplate,\n      templateAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async disableNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.disable721TokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.disable721TokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async reactivateNFTTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentNFTTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.reactivate721TokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Add a new NFT token template - only factory Owner\n   * @param {String} address\n   * @param {String} templateAddress template address to add\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async addTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateAddress === ZERO_ADDRESS) {\n      throw new Error(`Template cannot be address ZERO`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.addTokenTemplate,\n      templateAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.addTokenTemplate,\n      templateAddress\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Disable token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to disable\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async disableTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === false) {\n      throw new Error(`Template is already disabled`)\n    }\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.disableTokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.disableTokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Reactivate a previously disabled token template - only factory Owner\n   * @param {String} address\n   * @param {Number} templateIndex index of the template we want to reactivate\n   * @return {Promise<ReceiptOrEstimate>} current token template count\n   */\n  public async reactivateTokenTemplate<G extends boolean = false>(\n    address: string,\n    templateIndex: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if ((await this.getOwner()) !== address) {\n      throw new Error(`Caller is not Factory Owner`)\n    }\n    if (templateIndex > (await this.getCurrentTokenTemplateCount())) {\n      throw new Error(`Template index doesnt exist`)\n    }\n\n    if (templateIndex === 0) {\n      throw new Error(`Template index cannot be ZERO`)\n    }\n    if ((await this.getTokenTemplate(templateIndex)).isActive === true) {\n      throw new Error(`Template is already active`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.reactivateTokenTemplate,\n      templateIndex\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev startMultipleTokenOrder\n   *      Used as a proxy to order multiple services\n   *      Users can have inifinite approvals for fees for factory instead of having one approval/ Datatoken contract\n   *      Requires previous approval of all :\n   *          - consumeFeeTokens\n   *          - publishMarketFeeTokens\n   *          - ERC20 Datatokens\n   * @param address Caller address\n   * @param orders an array of struct tokenOrder\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n  public async startMultipleTokenOrder<G extends boolean = false>(\n    address: string,\n    orders: TokenOrder[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    if (orders.length > 50) {\n      throw new Error(`Too many orders`)\n    }\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.startMultipleTokenOrder,\n      orders\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.startMultipleTokenOrder,\n      orders\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatoken\n   *      Creates a new NFT, then a Datatoken,all in one call\n   * @param address Caller address\n   * @param _NftCreateData input data for nft creation\n   * @param _ErcCreateData input data for Datatoken creation\n   * @return {Promise<ReceiptOrEstimate>} transaction receipt\n   */\n\n  public async createNftWithDatatoken<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20,\n      nftCreateData,\n      ercCreateData\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatokenWithFixedRate\n   *      Creates a new NFT, then a Datatoken, then a FixedRateExchange, all in one call\n   *      Use this carefully, because if Fixed Rate creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param dtParams input data for Datatoken Creation\n   * @param freParams input data for FixedRate Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftWithDatatokenWithFixedRate<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    freParams: FreCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n    const fixedData = this.getFreCreationParams(freParams)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20WithFixedRate,\n      nftCreateData,\n      ercCreateData,\n      fixedData\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * @dev createNftWithDatatokenWithDispenser\n   *      Creates a new NFT, then a Datatoken, then a Dispenser, all in one call\n   *      Use this carefully, because if Dispenser creation fails, you are still going to pay a lot of gas\n   * @param address Caller address\n   * @param nftCreateData input data for NFT Creation\n   * @param dtParams input data for Datatoken Creation\n   * @param dispenserParams input data for Dispenser Creation\n   *  @return {Promise<TransactionReceipt>} transaction receipt\n   */\n  public async createNftWithDatatokenWithDispenser<G extends boolean = false>(\n    address: string,\n    nftCreateData: NftCreateData,\n    dtParams: DatatokenCreateParams,\n    dispenserParams: DispenserCreationParams,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const ercCreateData = this.getErcCreationParams(dtParams)\n\n    dispenserParams.maxBalance = Web3.utils.toWei(dispenserParams.maxBalance)\n    dispenserParams.maxTokens = Web3.utils.toWei(dispenserParams.maxTokens)\n\n    const estGas = await calculateEstimatedGas(\n      address,\n      this.contract.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    const trxReceipt = await sendTx(\n      address,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.createNftWithErc20WithDispenser,\n      nftCreateData,\n      ercCreateData,\n      dispenserParams\n    )\n\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  private getErcCreationParams(dtParams: DatatokenCreateParams): any {\n    let name: string, symbol: string\n    // Generate name & symbol if not present\n    if (!dtParams.name || !dtParams.symbol) {\n      ;({ name, symbol } = generateDtName())\n    }\n    return {\n      templateIndex: dtParams.templateIndex,\n      strings: [dtParams.name || name, dtParams.symbol || symbol],\n      addresses: [\n        dtParams.minter,\n        dtParams.paymentCollector,\n        dtParams.mpFeeAddress,\n        dtParams.feeToken\n      ],\n      uints: [Web3.utils.toWei(dtParams.cap), Web3.utils.toWei(dtParams.feeAmount)],\n      bytess: []\n    }\n  }\n\n  private getFreCreationParams(freParams: FreCreationParams): any {\n    if (!freParams.allowedConsumer) freParams.allowedConsumer = ZERO_ADDRESS\n    const withMint = freParams.withMint === false ? 0 : 1\n\n    return {\n      fixedPriceAddress: freParams.fixedRateAddress,\n      addresses: [\n        freParams.baseTokenAddress,\n        freParams.owner,\n        freParams.marketFeeCollector,\n        freParams.allowedConsumer\n      ],\n      uints: [\n        freParams.baseTokenDecimals,\n        freParams.datatokenDecimals,\n        Web3.utils.toWei(freParams.fixedRate),\n        Web3.utils.toWei(freParams.marketFee),\n        withMint\n      ]\n    }\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veOceanABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veOCEAN.vy/veOCEAN.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeOcean extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veOceanABI.abi as AbiItem[]\n  }\n\n  /**\n   * Deposit `amount` tokens for `userAddress` and lock until `unlockTime`\n   * @param {String} userAddress user address\n   * @param {String} amount Amount of tokens to be locked\n   * @param {Number} unlockTime Timestamp for unlock\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async lockTokens<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    unlockTime: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.create_lock,\n      amountFormatted,\n      unlockTime\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.create_lock,\n      amountFormatted,\n      unlockTime\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deposit `amount` tokens for `toAddress` and add to the existing lock\n   * Anyone (even a smart contract) can deposit for someone else, but cannot extend their locktime and deposit for a brand new user\n   * @param {String} fromUserAddress user address that sends the tx\n   * @param {String} toAddress user address to deposit for\n   * @param {String} amount Amount of tokens to be locked\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async depositFor<G extends boolean = false>(\n    fromUserAddress: string,\n    toAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.deposit_for,\n      toAddress,\n      amountFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.deposit_for,\n      toAddress,\n      amountFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Deposit `amount` additional tokens for `userAddress` without modifying the unlock time\n   * @param {String} userAddress user address that sends the tx\n   * @param {String} amount Amount of tokens to be locked\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async increaseAmount<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const amountFormatted = await this.amountToUnits(await this.getToken(), amount)\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.increase_amount,\n      amountFormatted\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.increase_amount,\n      amountFormatted\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Extend the unlock time for `userAddress` to `unlockTime`\n   * @param {String} userAddress user address that sends the tx\n   * @param {Number} unlockTime Timestamp for new unlock time\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async increaseUnlockTime<G extends boolean = false>(\n    userAddress: string,\n    unlockTime: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.increase_unlock_time,\n      unlockTime\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000, // sometimes, it's not enough\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.increase_unlock_time,\n      unlockTime\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Withdraw all tokens for `userAddress`\n   * @param {String} userAddress user address that sends the tx\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async withdraw<G extends boolean = false>(\n    userAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.withdraw\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.withdraw\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get voting power for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async getVotingPower(userAddress: string): Promise<number> {\n    const balance = await this.contract.methods.balanceOf(userAddress).call()\n    return balance\n  }\n\n  /** Get locked balance\n   * @param {String} userAddress user address\n   * @return {Promise<string>}\n   */\n  public async getLockedAmount(userAddress: string): Promise<string> {\n    const balance = await this.contract.methods.locked(userAddress).call()\n    const balanceFormated = await this.unitsToAmount(\n      await this.getToken(),\n      balance.amount\n    )\n\n    return balanceFormated\n  }\n\n  /** Get untilLock for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async lockEnd(userAddress: string): Promise<number> {\n    const untilLock = await this.contract.methods.locked__end(userAddress).call()\n    return untilLock\n  }\n\n  /** Get total supply\n   * @return {Promise<number>}\n   */\n  public async totalSupply(): Promise<string> {\n    const supplyFormated = await this.unitsToAmount(\n      await this.getToken(),\n      await this.contract.methods.totalSupply().call()\n    )\n    return supplyFormated\n  }\n\n  /** Get token\n   * @return {Promise<string>}\n   */\n  public async getToken(): Promise<string> {\n    const tokenAddress = await this.contract.methods.token().call()\n    return tokenAddress\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veFeeABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veFeeDistributor.vy/veFeeDistributor.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeFeeDistributor extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veFeeABI.abi as AbiItem[]\n  }\n\n  /**\n   * Claim fees for `userAddress`\n   * Each call to claim look at a maximum of 50 user veOCEAN points.\n         For accounts with many veOCEAN related actions, this function\n         may need to be called more than once to claim all available\n         fees. In the `Claimed` event that fires, if `claim_epoch` is\n         less than `max_epoch`, the account may claim again\n   * @param {String} userAddress user address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claim<G extends boolean = false>(\n    userAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(userAddress, this.contract.methods.claim)\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 20000,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claim\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * Make multiple fee claims in a single call\n    Used to claim for many accounts at once, or to make\n         multiple claims for the same address when that address\n         has significant veOCEAN history\n   * @param {String} fromUserAddress user address that sends the tx\n   * @param {String} addresses array of addresses to claim\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimMany<G extends boolean = false>(\n    fromUserAddress: string,\n    addresses: string[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claim_many,\n      addresses\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 20000,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claim_many,\n      addresses\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veFeeEstimate from '@oceanprotocol/contracts/artifacts/contracts/ve/veFeeEstimate.vy/veFeeEstimate.json'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { VeOcean } from './VeOcean'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeFeeEstimate extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veFeeEstimate.abi as AbiItem[]\n  }\n\n  /**\n   * estimateClaim\n   * @param {String} userAddress user address\n   * @return {Promise<string>}\n   */\n  public async estimateClaim(userAddress: string): Promise<string> {\n    const amount = await this.contract.methods.estimateClaim(userAddress).call()\n    const veOcean = new VeOcean(\n      await this.contract.methods.voting_escrow().call(),\n      this.web3\n    )\n    const amountFormated = await this.unitsToAmount(await veOcean.getToken(), amount)\n    return amountFormated\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport veAllocateABI from '@oceanprotocol/contracts/artifacts/contracts/ve/veAllocate.sol/veAllocate.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n/**\n * Provides an interface for veOcean contract\n */\nexport class VeAllocate extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return veAllocateABI.abi as AbiItem[]\n  }\n\n  /**\n   * set a specific percentage of veOcean to a specific nft\n   * Maximum allocated percentage is 10000, so 1% is specified as 100\n   * @param {String} userAddress user address\n   * @param {String} amount Percentage used\n   * @param {String} nft NFT address to allocate to\n   * @param {String} chainId chainId of NFT\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setAllocation<G extends boolean = false>(\n    userAddress: string,\n    amount: string,\n    nft: string,\n    chainId: number,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.setAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * set specific percetage of veOcean to multiple nfts\n   * Maximum allocated percentage is 10000, so 1% is specified as 100\n   * @param {String} userAddress user address\n   * @param {String[]} amount Array of percentages used\n   * @param {String[]} nft Array of NFT addresses\n   * @param {String[]} chainId Array of chainIds\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async setBatchAllocation<G extends boolean = false>(\n    userAddress: string,\n    amount: string[],\n    nft: string[],\n    chainId: number[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      userAddress,\n      this.contract.methods.setBatchAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      userAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.setBatchAllocation,\n      amount,\n      nft,\n      chainId\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /** Get totalAllocation for address\n   * @param {String} userAddress user address\n   * @return {Promise<number>}\n   */\n  public async getTotalAllocation(userAddress: string): Promise<number> {\n    const allocation = await this.contract.methods.getTotalAllocation(userAddress).call()\n    return allocation\n  }\n\n  /** Get getveAllocation for address, nft, chainId\n   * @param {String} userAddress user address\n   * @param {String} nft NFT address to allocate to\n   * @param {String} chainId chainId of NFT\n   * @return {Promise<number>}\n   */\n  public async getVeAllocation(\n    userAddress: string,\n    nft: string,\n    chainId: string\n  ): Promise<number> {\n    const allocation = await this.contract.methods\n      .getveAllocation(userAddress, nft, chainId)\n      .call()\n    return allocation\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport dfRewardsABI from '@oceanprotocol/contracts/artifacts/contracts/df/DFRewards.sol/DFRewards.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n\n/**\n * Provides an interface for DFRewards contract\n */\nexport class DfRewards extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return dfRewardsABI.abi as AbiItem[]\n  }\n\n  /** Get available DF Rewards for a token\n   * @param {String} userAddress user address\n   * @param {String} tokenAddress token address\n   * @return {Promise<string>}\n   */\n  public async getAvailableRewards(\n    userAddress: string,\n    tokenAddress: string\n  ): Promise<string> {\n    const rewards = await this.contract.methods\n      .claimable(userAddress, tokenAddress)\n      .call()\n    const rewardsFormated = await this.unitsToAmount(tokenAddress, rewards)\n\n    return rewardsFormated\n  }\n\n  /**\n   * claim rewards for any address\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String} userAddress user address to claim\n   * @param {String} tokenAddress token address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddress: string,\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claimFor,\n      userAddress,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claimFor,\n      userAddress,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n\n  /**\n   * allocate rewards to address.  An approve must exist before calling this function.\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String[]} userAddresses array of users that will receive rewards\n   * @param {String[]} amounts array of amounts\n   * @param {String} tokenAddress token address\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async allocateRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddresses: string[],\n    amounts: string[],\n    tokenAddress: string,\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    for (let i = 0; i < amounts.length; i++) {\n      amounts[i] = await this.amountToUnits(tokenAddress, amounts[i])\n    }\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.allocate,\n      userAddresses,\n      amounts,\n      tokenAddress\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.allocate,\n      userAddresses,\n      amounts,\n      tokenAddress\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import { AbiItem } from 'web3-utils'\nimport dfStrategyV1ABI from '@oceanprotocol/contracts/artifacts/contracts/df/DFStrategyV1.sol/DFStrategyV1.json'\nimport { calculateEstimatedGas, sendTx } from '../../utils'\nimport { SmartContractWithAddress } from '../SmartContractWithAddress'\nimport { ReceiptOrEstimate } from '../../@types'\n\n/**\n * Provides an interface for dfStrategyV1 contract\n */\nexport class DfStrategyV1 extends SmartContractWithAddress {\n  getDefaultAbi(): AbiItem | AbiItem[] {\n    return dfStrategyV1ABI.abi as AbiItem[]\n  }\n\n  /** Get available DF Rewards for multiple tokens\n   * @param {String} userAddress user address\n   * @param {String} tokenAddresses array of tokens\n   * @return {Promise<string[]>}\n   */\n  public async getMultipleAvailableRewards(\n    userAddress: string,\n    tokenAddresses: string[]\n  ): Promise<string[]> {\n    const rewards = await this.contract.methods\n      .claimables(userAddress, tokenAddresses)\n      .call()\n    const rewardsFormated: string[] = []\n    for (let i = 0; i < rewards.length; i++) {\n      rewardsFormated.push(await this.unitsToAmount(tokenAddresses[i], rewards[i]))\n    }\n    return rewardsFormated\n  }\n\n  /**\n   * claim multiple token rewards for any address\n   * @param {String} fromUserAddress user that generates the tx\n   * @param {String} userAddress user address to claim\n   * @param {String} tokenAddresses array of tokens\n   * @return {Promise<ReceiptOrEstimate>}\n   */\n  public async claimMultipleRewards<G extends boolean = false>(\n    fromUserAddress: string,\n    userAddress: string,\n    tokenAddresses: string[],\n    estimateGas?: G\n  ): Promise<ReceiptOrEstimate<G>> {\n    const estGas = await calculateEstimatedGas(\n      fromUserAddress,\n      this.contract.methods.claimMultiple,\n      userAddress,\n      tokenAddresses\n    )\n    if (estimateGas) return <ReceiptOrEstimate<G>>estGas\n\n    // Invoke function of the contract\n    const trxReceipt = await sendTx(\n      fromUserAddress,\n      estGas + 1,\n      this.web3,\n      this.config?.gasFeeMultiplier,\n      this.contract.methods.claimMultiple,\n      userAddress,\n      tokenAddresses\n    )\n    return <ReceiptOrEstimate<G>>trxReceipt\n  }\n}\n","import fetch from 'cross-fetch'\nimport { LoggerInstance, sleep } from '../utils'\nimport { Asset, DDO, ValidateMetadata } from '../@types'\n\nexport interface SearchQuery {\n  from?: number\n  size?: number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  query: any\n  sort?: { [jsonPath: string]: string }\n  aggs?: any\n}\n\nexport class Aquarius {\n  public aquariusURL: string\n\n  /**\n   * Instantiate Aquarius\n   * @param {String} aquariusURL\n   */\n  constructor(aquariusURL: string) {\n    this.aquariusURL = aquariusURL\n  }\n\n  /** Resolves a DID\n   * @param {string} did\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<Asset>} Asset\n   */\n  public async resolve(did: string, signal?: AbortSignal): Promise<Asset> {\n    const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response.ok) {\n        const raw = await response.json()\n        return raw as Asset\n      } else {\n        throw new Error('HTTP request failed with status ' + response.status)\n      }\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed')\n    }\n  }\n\n  /**\n   * Blocks until Aqua will cache the did (or the update for that did) or timeouts\n   \n   * @param {string} did DID of the asset.\n   * @param {string} txid used when the did exists and we expect an update with that txid.\n     * @param {AbortSignal} signal abort signal\n   * @return {Promise<DDO>} DDO of the asset.\n   */\n  public async waitForAqua(\n    did: string,\n    txid?: string,\n    signal?: AbortSignal\n  ): Promise<Asset> {\n    let tries = 0\n    do {\n      try {\n        const path = this.aquariusURL + '/api/aquarius/assets/ddo/' + did\n        const response = await fetch(path, {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n          signal\n        })\n        if (response.ok) {\n          const ddo = await response.json()\n          if (txid) {\n            // check tx\n            if (ddo.event && ddo.event.txid === txid) return ddo as Asset\n          } else return ddo as Asset\n        }\n      } catch (e) {\n        // do nothing\n      }\n      await sleep(1500)\n      tries++\n    } while (tries < 100)\n    return null\n  }\n\n  /**\n   * Validate DDO content\n   * @param {DDO} ddo DID Descriptor Object content.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ValidateMetadata>}.\n   */\n  public async validate(ddo: DDO, signal?: AbortSignal): Promise<ValidateMetadata> {\n    const status: ValidateMetadata = {\n      valid: false\n    }\n    let jsonResponse\n    try {\n      const path = this.aquariusURL + '/api/aquarius/assets/ddo/validate'\n\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(ddo),\n        headers: { 'Content-Type': 'application/octet-stream' },\n        signal\n      })\n\n      jsonResponse = await response.json()\n      if (response.status === 200) {\n        status.valid = true\n        status.hash = jsonResponse.hash\n        status.proof = {\n          validatorAddress: jsonResponse.publicKey,\n          r: jsonResponse.r[0],\n          s: jsonResponse.s[0],\n          v: jsonResponse.v\n        }\n      } else {\n        status.errors = jsonResponse\n        LoggerInstance.error('validate Metadata failed:', response.status, status.errors)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error validating metadata: ', error)\n    }\n    return status\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param {string} did DID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async getAssetMetadata(did: string, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/metadata/' + did\n\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error(\n          'getAssetMetadata failed: ' + response.status + response.statusText\n        )\n      }\n    } catch (error) {\n      LoggerInstance.error('Error getting metadata: ', error)\n      throw new Error('Error getting metadata: ' + error)\n    }\n  }\n\n  /**\n   * Search over the DDOs using a query.\n   * @param  {SearchQuery} query Query to filter the DDOs.\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<QueryResult>}\n   */\n  public async querySearch(query: SearchQuery, signal?: AbortSignal): Promise<any> {\n    const path = this.aquariusURL + '/api/aquarius/assets/query'\n\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(query),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal\n      })\n\n      if (response.ok) {\n        return response.json()\n      } else {\n        throw new Error('querySearch failed: ' + response.status + response.statusText)\n      }\n    } catch (error) {\n      LoggerInstance.error('Error querying metadata: ', error)\n      throw new Error('Error querying metadata: ' + error)\n    }\n  }\n}\n","import Web3 from 'web3'\nimport fetch from 'cross-fetch'\nimport { LoggerInstance } from '../utils'\nimport {\n  Arweave,\n  FileInfo,\n  ComputeJob,\n  ComputeOutput,\n  ComputeAlgorithm,\n  ComputeAsset,\n  ComputeEnvironment,\n  ProviderInitialize,\n  ProviderComputeInitializeResults,\n  ServiceEndpoint,\n  UrlFile,\n  UserCustomParameters,\n  Ipfs,\n  Smartcontract,\n  GraphqlQuery\n} from '../@types'\n\nexport class Provider {\n  /**\n   * Returns the provider endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  async getEndpoints(providerUri: string): Promise<any> {\n    try {\n      const endpoints = await this.getData(providerUri)\n      return await endpoints.json()\n    } catch (e) {\n      LoggerInstance.error('Finding the service endpoints failed:', e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  getEndpointURL(\n    servicesEndpoints: ServiceEndpoint[],\n    serviceName: string\n  ): ServiceEndpoint {\n    if (!servicesEndpoints) return null\n    return servicesEndpoints.find((s) => s.serviceName === serviceName) as ServiceEndpoint\n  }\n\n  /**\n   * Returns the service endpoints that exist in provider.\n   * @param {any} endpoints\n   * @return {Promise<ServiceEndpoint[]>}\n   */\n  public async getServiceEndpoints(providerEndpoint: string, endpoints: any) {\n    const serviceEndpoints: ServiceEndpoint[] = []\n    for (const i in endpoints.serviceEndpoints) {\n      const endpoint: ServiceEndpoint = {\n        serviceName: i,\n        method: endpoints.serviceEndpoints[i][0],\n        urlPath: providerEndpoint + endpoints.serviceEndpoints[i][1]\n      }\n      serviceEndpoints.push(endpoint)\n    }\n    return serviceEndpoints\n  }\n\n  /** Gets current nonce\n   * @param {string} providerUri provider uri address\n   * @param {string} consumerAddress Publisher address\n   * @param {AbortSignal} signal abort signal\n   * @param {string} providerEndpoints Identifier of the asset to be registered in ocean\n   * @param {string} serviceEndpoints document description object (DDO)=\n   * @return {Promise<string>} urlDetails\n   */\n  public async getNonce(\n    providerUri: string,\n    consumerAddress: string,\n    signal?: AbortSignal,\n    providerEndpoints?: any,\n    serviceEndpoints?: ServiceEndpoint[]\n  ): Promise<string> {\n    if (!providerEndpoints) {\n      providerEndpoints = await this.getEndpoints(providerUri)\n    }\n    if (!serviceEndpoints) {\n      serviceEndpoints = await this.getServiceEndpoints(providerUri, providerEndpoints)\n    }\n    const path = this.getEndpointURL(serviceEndpoints, 'nonce')\n      ? this.getEndpointURL(serviceEndpoints, 'nonce').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path + `?userAddress=${consumerAddress}`, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      return (await response.json()).nonce.toString()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  public async signProviderRequest(\n    web3: Web3,\n    accountId: string,\n    message: string,\n    password?: string\n  ): Promise<string> {\n    const consumerMessage = web3.utils.soliditySha3({\n      t: 'bytes',\n      v: web3.utils.utf8ToHex(message)\n    })\n    const isMetaMask =\n      web3 && web3.currentProvider && (web3.currentProvider as any).isMetaMask\n    if (isMetaMask)\n      return await web3.eth.personal.sign(consumerMessage, accountId, password)\n    else return await web3.eth.sign(consumerMessage, accountId)\n  }\n\n  /** Encrypt data using the Provider's own symmetric key\n   * @param {string} data data in json format that needs to be sent , it can either be a DDO or a File array\n   * @param {number} chainId network's id so provider can choose the corresponding web3 object\n   * @param {string} providerUri provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<string>} urlDetails\n   */\n  public async encrypt(\n    data: any,\n    chainId: number,\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path =\n      (this.getEndpointURL(serviceEndpoints, 'encrypt')\n        ? this.getEndpointURL(serviceEndpoints, 'encrypt').urlPath\n        : null) + `?chainId=${chainId}`\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: { 'Content-Type': 'application/octet-stream' },\n        signal\n      })\n      return await response.text()\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get DDO File details (if possible)\n   * @param {UrlFile | Arweave | Ipfs | GraphqlQuery | Smartcontract} file one of the supported file structures\n   * @param {string} serviceId the id of the service for which to check the files\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {boolean} withChecksum if true, will return checksum of files content\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async checkDidFiles(\n    did: string,\n    serviceId: string,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { did, serviceId, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get URL details (if possible)\n   * @param {UrlFile | Arweave | Ipfs | GraphqlQuery | Smartcontract} file one of the supported file structures\n   * @param {string} providerUri uri of the provider that will be used to check the file\n   * @param {boolean} withChecksum if true, will return checksum of files content\n   * @param {AbortSignal} signal abort signal\n   * @param {any} headers headers key value pairs associated with the asset GET request\n   * @return {Promise<FileInfo[]>} urlDetails\n   */\n  public async getFileInfo(\n    file: UrlFile | Arweave | Ipfs | GraphqlQuery | Smartcontract,\n    providerUri: string,\n    withChecksum: boolean = false,\n    signal?: AbortSignal,\n    headers?: any\n  ): Promise<FileInfo[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const args = { ...file, headers, checksum: withChecksum }\n    const files: FileInfo[] = []\n    const path = this.getEndpointURL(serviceEndpoints, 'fileinfo')\n      ? this.getEndpointURL(serviceEndpoints, 'fileinfo').urlPath\n      : null\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'POST',\n        body: JSON.stringify(args),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: FileInfo[] = await response.json()\n      for (const result of results) {\n        files.push(result)\n      }\n      return files\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get Compute Environments\n   * @return {Promise<ComputeEnvironment[]>} urlDetails\n   */\n  public async getComputeEnvironments(\n    providerUri: string,\n    signal?: AbortSignal\n  ): Promise<ComputeEnvironment[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const path = this.getEndpointURL(serviceEndpoints, 'computeEnvironments')?.urlPath\n    if (!path) return null\n    try {\n      const response = await fetch(path, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const envs: ComputeEnvironment[] = await response.json()\n      return envs\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Initialize a service request.\n   * @param {DDO | string} asset\n   * @param {number} serviceIndex\n   * @param {string} serviceType\n   * @param {string} consumerAddress\n   * @param {UserCustomParameters} userCustomParameters\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderInitialize>} ProviderInitialize data\n   */\n  public async initialize(\n    did: string,\n    serviceId: string,\n    fileIndex: number,\n    consumerAddress: string,\n    providerUri: string,\n    signal?: AbortSignal,\n    userCustomParameters?: UserCustomParameters,\n    computeEnv?: string,\n    validUntil?: number\n  ): Promise<ProviderInitialize> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    let initializeUrl = this.getEndpointURL(serviceEndpoints, 'initialize')\n      ? this.getEndpointURL(serviceEndpoints, 'initialize').urlPath\n      : null\n\n    if (!initializeUrl) return null\n    initializeUrl += `?documentId=${did}`\n    initializeUrl += `&serviceId=${serviceId}`\n    initializeUrl += `&fileIndex=${fileIndex}`\n    initializeUrl += `&consumerAddress=${consumerAddress}`\n    if (userCustomParameters)\n      initializeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    if (computeEnv) initializeUrl += '&environment=' + encodeURI(computeEnv)\n    if (validUntil) initializeUrl += '&validUntil=' + validUntil\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results: ProviderInitialize = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('Asset URL not found or not available.')\n    }\n  }\n\n  /** Initialize a compute request.\n   * @param {ComputeAsset} assets\n   * @param {ComputeAlgorithmber} algorithm\n   * @param {string} computeEnv\n   * @param {number} validUntil\n   * @param {string} providerUri Identifier of the asset to be registered in ocean\n   * @param {string} accountId\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ProviderComputeInitialize>} ProviderComputeInitialize data\n   */\n  public async initializeCompute(\n    assets: ComputeAsset[],\n    algorithm: ComputeAlgorithm,\n    computeEnv: string,\n    validUntil: number,\n    providerUri: string,\n    accountId: string,\n    signal?: AbortSignal\n  ): Promise<ProviderComputeInitializeResults> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const providerData = {\n      datasets: assets,\n      algorithm,\n      compute: { env: computeEnv, validUntil },\n      consumerAddress: accountId\n    }\n    const initializeUrl = this.getEndpointURL(serviceEndpoints, 'initializeCompute')\n      ? this.getEndpointURL(serviceEndpoints, 'initializeCompute').urlPath\n      : null\n    if (!initializeUrl) return null\n    try {\n      const response = await fetch(initializeUrl, {\n        method: 'POST',\n        body: JSON.stringify(providerData),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      const results = await response.json()\n      return results\n    } catch (e) {\n      LoggerInstance.error(e)\n      throw new Error('ComputeJob cannot be initialized')\n    }\n  }\n\n  /** Gets fully signed URL for download\n   * @param {string} did\n   * @param {string} accountId\n   * @param {string} serviceId\n   * @param {number} fileIndex\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {UserCustomParameters} userCustomParameters\n   * @return {Promise<string>}\n   */\n  public async getDownloadUrl(\n    did: string,\n    accountId: string,\n    serviceId: string,\n    fileIndex: number,\n    transferTxId: string,\n    providerUri: string,\n    web3: Web3,\n    userCustomParameters?: UserCustomParameters\n  ): Promise<any> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const downloadUrl = this.getEndpointURL(serviceEndpoints, 'download')\n      ? this.getEndpointURL(serviceEndpoints, 'download').urlPath\n      : null\n    if (!downloadUrl) return null\n    const nonce = Date.now()\n    const signature = await this.signProviderRequest(web3, accountId, did + nonce)\n    let consumeUrl = downloadUrl\n    consumeUrl += `?fileIndex=${fileIndex}`\n    consumeUrl += `&documentId=${did}`\n    consumeUrl += `&transferTxId=${transferTxId}`\n    consumeUrl += `&serviceId=${serviceId}`\n    consumeUrl += `&consumerAddress=${accountId}`\n    consumeUrl += `&nonce=${nonce}`\n    consumeUrl += `&signature=${signature}`\n    if (userCustomParameters)\n      consumeUrl += '&userdata=' + encodeURI(JSON.stringify(userCustomParameters))\n    return consumeUrl\n  }\n\n  /** Instruct the provider to start a compute job\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} computeEnv\n   * @param {ComputeAlgorithm} algorithm\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @param {ComputeOutput} output\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStart(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    computeEnv: string,\n    dataset: ComputeAsset,\n    algorithm: ComputeAlgorithm,\n    signal?: AbortSignal,\n    additionalDatasets?: ComputeAsset[],\n    output?: ComputeOutput\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStartUrl = this.getEndpointURL(serviceEndpoints, 'computeStart')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStart').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += dataset.documentId\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.consumerAddress = consumerAddress\n    payload.signature = signature\n    payload.nonce = nonce\n    payload.environment = computeEnv\n    payload.dataset = dataset\n    payload.algorithm = algorithm\n    if (payload.additionalDatasets) payload.additionalDatasets = additionalDatasets\n    if (output) payload.output = output\n    if (!computeStartUrl) return null\n    try {\n      const response = await fetch(computeStartUrl, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Compute start failed: ',\n        response.status,\n        response.statusText,\n        await response.json()\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute start failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Instruct the provider to Stop the execution of a to stop a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStop(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStopUrl = this.getEndpointURL(serviceEndpoints, 'computeStop')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStop').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${this.noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.signature = signature\n    payload.documentId = this.noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    if (jobId) payload.jobId = jobId\n\n    if (!computeStopUrl) return null\n    try {\n      const response = await fetch(computeStopUrl, {\n        method: 'PUT',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error('Compute stop failed:', response.status, response.statusText)\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Compute stop failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get compute status for a specific jobId/documentId/owner.\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {string} did The ID of the asset\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeStatus(\n    providerUri: string,\n    consumerAddress: string,\n    jobId?: string,\n    did?: string,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeStatusUrl = this.getEndpointURL(serviceEndpoints, 'computeStatus')\n      ? this.getEndpointURL(serviceEndpoints, 'computeStatus').urlPath\n      : null\n\n    let url = `?consumerAddress=${consumerAddress}`\n    url += (did && `&documentId=${this.noZeroX(did)}`) || ''\n    url += (jobId && `&jobId=${jobId}`) || ''\n\n    if (!computeStatusUrl) return null\n    try {\n      const response = await fetch(computeStatusUrl + url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Get compute status failed:',\n        response.status,\n        response.statusText\n      )\n      return null\n    } catch (e) {\n      LoggerInstance.error('Get compute status failed')\n      LoggerInstance.error(e)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Get compute result url\n   * @param {string} providerUri The URI of the provider we want to query\n   * @param {Web3} web3 Web3 instance\n   * @param {string} consumerAddress The consumer ethereum address\n   * @param {string} jobId The ID of a compute job.\n   * @param {number} index Result index\n   * @return {Promise<string>}\n   */\n  public async getComputeResultUrl(\n    providerUri: string,\n    web3: Web3,\n    consumerAddress: string,\n    jobId: string,\n    index: number\n  ): Promise<string> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeResultUrl = this.getEndpointURL(serviceEndpoints, 'computeResult')\n      ? this.getEndpointURL(serviceEndpoints, 'computeResult').urlPath\n      : null\n\n    const nonce = Date.now()\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId\n    signatureMessage += index.toString()\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    if (!computeResultUrl) return null\n    let resultUrl = computeResultUrl\n    resultUrl += `?consumerAddress=${consumerAddress}`\n    resultUrl += `&jobId=${jobId}`\n    resultUrl += `&index=${index.toString()}`\n    resultUrl += `&nonce=${nonce}`\n    resultUrl += (signature && `&signature=${signature}`) || ''\n    return resultUrl\n  }\n\n  /** Deletes a compute job.\n   * @param {string} did\n   * @param {string} consumerAddress\n   * @param {string} jobId\n   * @param {string} providerUri\n   * @param {Web3} web3\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<ComputeJob | ComputeJob[]>}\n   */\n  public async computeDelete(\n    did: string,\n    consumerAddress: string,\n    jobId: string,\n    providerUri: string,\n    web3: Web3,\n    signal?: AbortSignal\n  ): Promise<ComputeJob | ComputeJob[]> {\n    const providerEndpoints = await this.getEndpoints(providerUri)\n    const serviceEndpoints = await this.getServiceEndpoints(\n      providerUri,\n      providerEndpoints\n    )\n    const computeDeleteUrl = this.getEndpointURL(serviceEndpoints, 'computeDelete')\n      ? this.getEndpointURL(serviceEndpoints, 'computeDelete').urlPath\n      : null\n\n    const nonce = await this.getNonce(\n      providerUri,\n      consumerAddress,\n      signal,\n      providerEndpoints,\n      serviceEndpoints\n    )\n\n    let signatureMessage = consumerAddress\n    signatureMessage += jobId || ''\n    signatureMessage += (did && `${this.noZeroX(did)}`) || ''\n    signatureMessage += nonce\n    const signature = await this.signProviderRequest(\n      web3,\n      consumerAddress,\n      signatureMessage\n    )\n    const payload = Object()\n    payload.documentId = this.noZeroX(did)\n    payload.consumerAddress = consumerAddress\n    payload.jobId = jobId\n    if (signature) payload.signature = signature\n\n    if (!computeDeleteUrl) return null\n    try {\n      const response = await fetch(computeDeleteUrl, {\n        method: 'DELETE',\n        body: JSON.stringify(payload),\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n\n      if (response?.ok) {\n        const params = await response.json()\n        return params\n      }\n      LoggerInstance.error(\n        'Delete compute job failed:',\n        response.status,\n        response.statusText\n      )\n      LoggerInstance.error('Payload was:', payload)\n      return null\n    } catch (e) {\n      LoggerInstance.error('Delete compute job failed:')\n      LoggerInstance.error(e)\n      LoggerInstance.error('Payload was:', payload)\n      throw new Error('HTTP request failed calling Provider')\n    }\n  }\n\n  /** Check for a valid provider at URL\n   * @param {String} url provider uri address\n   * @param {AbortSignal} signal abort signal\n   * @return {Promise<boolean>} string\n   */\n  public async isValidProvider(url: string, signal?: AbortSignal): Promise<boolean> {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        signal\n      })\n      if (response?.ok) {\n        const params = await response.json()\n        if (params && (params.providerAddress || params.providerAddresses)) return true\n      }\n      return false\n    } catch (error) {\n      LoggerInstance.error(`Error validating provider: ${error.message}`)\n      return false\n    }\n  }\n\n  private noZeroX(input: string): string {\n    return this.zeroXTransformer(input, false)\n  }\n\n  private zeroXTransformer(input = '', zeroOutput: boolean): string {\n    const { valid, output } = this.inputMatch(\n      input,\n      /^(?:0x)*([a-f0-9]+)$/i,\n      'zeroXTransformer'\n    )\n    return (zeroOutput && valid ? '0x' : '') + output\n  }\n\n  // Shared functions\n  private inputMatch(\n    input: string,\n    regexp: RegExp,\n    conversorName: string\n  ): { valid: boolean; output: string } {\n    if (typeof input !== 'string') {\n      LoggerInstance.debug('Not input string:')\n      LoggerInstance.debug(input)\n      throw new Error(`[${conversorName}] Expected string, input type: ${typeof input}`)\n    }\n    const match = input.match(regexp)\n    if (!match) {\n      LoggerInstance.warn(`[${conversorName}] Input transformation failed.`)\n      return { valid: false, output: input }\n    }\n    return { valid: true, output: match[1] }\n  }\n\n  private async getData(url: string): Promise<Response> {\n    return fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-type': 'application/json'\n      }\n    })\n  }\n}\n\nexport const ProviderInstance = new Provider()\n","import { AbiItem } from 'web3-utils/types'\nimport { LogLevel } from '../utils'\n\nexport class Config {\n  /**\n   * Ethereum node URL.\n   * @type {string}\n   */\n  public nodeUri?: string\n\n  /**\n   * Address of Provider.\n   * @type {string}\n   */\n  public providerAddress?: string\n\n  /**\n   * Metadata Store URL.\n   * @type {string}\n   */\n  public metadataCacheUri?: string\n\n  /**\n   * Provider URL.\n   * @type {string}\n   */\n  public providerUri?: string\n\n  /**\n   * Web3 Provider.\n   * @type {any}\n   */\n  public web3Provider?: any\n\n  /**\n   * Ocean Token address\n   * @type {string}\n   */\n  public oceanTokenAddress?: string\n\n  /**\n   * Factory address\n   * @type {string}\n   */\n  public nftFactoryAddress?: string\n\n  /**\n   * datatokens ABI\n   * @type {string}\n   */\n  public datatokensABI?: AbiItem | AbiItem[]\n\n  /**\n   * FixedRateExchangeAddress\n   * @type {string}\n   */\n  public fixedRateExchangeAddress?: string\n\n  /**\n   * FixedRateExchangeAddressABI\n   * @type {any}\n   */\n  public fixedRateExchangeAddressABI?: AbiItem | AbiItem[]\n\n  /**\n   * DispenserAddress\n   * @type {string}\n   */\n  public dispenserAddress?: string\n\n  /**\n   * DispenserABI\n   * @type {any}\n   */\n  public dispenserABI?: AbiItem | AbiItem[]\n\n  /**\n   * OPFCommunityFeeCollector\n   * @type {string}\n   */\n  public opfCommunityFeeCollector?: string\n\n  /**\n   * SideStaking address\n   * @type {string}\n   */\n  public sideStakingAddress?: string\n\n  /**\n   * block number of the deployment\n   * @type {number}\n   */\n  public startBlock?: number\n  /**\n   * Log level.\n   * @type {boolean | LogLevel}\n   */\n  public verbose?: boolean | LogLevel\n\n  /**\n   * Message shown when the user creates its own token.\n   * @type {string}\n   */\n  public authMessage?: string\n\n  /**\n   * Token expiration time in ms.\n   * @type {number}\n   */\n  public authTokenExpiration?: number\n\n  /**\n   * Parity config\n   * @type {string}\n   */\n  public parityUri?: string\n\n  public threshold?: number\n\n  /**\n   * Chain ID\n   * @type {number}\n   */\n  chainId: number\n\n  /**\n   * Network name ex: mainnet, goerli, polygon\n   * @type {string}\n   */\n  network: string\n\n  /**\n   * Url of the relevant subgraph instance ex: https://subgraph.mainnet.oceanprotocol.com\n   * @type {string}\n   */\n  subgraphUri: string\n\n  /**\n   * Url of the  blockchain exporer ex: https://etherscan.io\n   * @type {string}\n   */\n  explorerUri: string\n\n  /**\n   * Ocean toke symbol on the chain, it's used just for convenience to reduce number of calls\n   * @type {string}\n   */\n  oceanTokenSymbol: string\n\n  /**\n   * Specify the transaction Block Timeout\n   * @type {number}\n   */\n  transactionBlockTimeout: number\n\n  /**\n   * Specify the transaction Confirmation Blocks\n   * @type {number}\n   */\n  transactionConfirmationBlocks: number\n\n  /**\n   * Specify the transaction Polling Blocks Timeout\n   * @type {number}\n   */\n  transactionPollingTimeout: number\n\n  /**\n   * Specify the multiplier for the gas fee\n   * @type {number}\n   */\n  gasFeeMultiplier: number\n\n  veAllocate?: string\n  veOCEAN?: string\n  veDelegation?: string\n  veFeeDistributor?: string\n  veDelegationProxy?: string\n  DFRewards?: string\n  DFStrategyV1?: string\n  veFeeEstimate?: string\n}\n","import sha256 from 'crypto-js/sha256'\nimport Web3 from 'web3'\n\nexport function generateDid(nftAddress: string, chainId: number): string {\n  nftAddress = Web3.utils.toChecksumAddress(nftAddress)\n  const checksum = sha256(nftAddress + chainId.toString(10))\n  return `did:op:${checksum.toString()}`\n}\n\nexport function getHash(data: any): string {\n  return sha256(data).toString()\n}\n","import Web3 from 'web3'\n\nexport async function signHash(web3: Web3, message: string, address: string) {\n  let signedMessage = await web3.eth.sign(message, address)\n  signedMessage = signedMessage.substr(2) // remove 0x\n  const r = '0x' + signedMessage.slice(0, 64)\n  const s = '0x' + signedMessage.slice(64, 128)\n  let v = '0x' + signedMessage.slice(128, 130)\n  // make sure we obey 27 and 28 standards\n  if (v === '0x00') v = '0x1b'\n  if (v === '0x01') v = '0x1c'\n  return { v, r, s }\n}\n"],"names":["ZERO_ADDRESS","GASLIMIT_DEFAULT","FEE_HISTORY_NOT_SUPPORTED","sendTx","from","estGas","web3","gasFeeMultiplier","functionToSend","sendTxValue","gas","Promise","resolve","eth","getChainId","then","networkId","_temp7","apply","slice","call","_arguments4","send","_temp6","getFeeHistory","feeHistory","_temp5","_feeHistory$baseFeePe","_feeHistory$reward","_feeHistory$reward$","baseFeePerGas","reward","getFairGasPrice","_getFairGasPrice","gasPrice","_feeHistory$reward2","_feeHistory$reward2$","_feeHistory$baseFeePe2","aggressiveFee","BigNumber","multipliedBy","maxPriorityFeePerGas","integerValue","ROUND_DOWN","toString","maxFeePerGas","plus","MUMBAI_NETWORK_ID","POLYGON_NETWORK_ID","lte","MIN_GAS_FEE_POLYGON","_catch","err","message","LoggerInstance","log","_getFairGasPrice2","e","reject","calculateEstimatedGas","functionToEstimateGas","estimateGas","amountToUnits","token","amount","tokenDecimals","decimals","config","EXPONENTIAL_AT","times","exponentiatedBy","toFixed","tokenContract","Contract","minAbi","_temp4","methods","unitsToAmount","amountFormatted","div","_temp2","getGasPrice","_web3$eth$getGasPrice","x","setContractDefaults","contract","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","generateDtName","wordList","list","wordListDefault","random1","Math","floor","random","adjectives","length","random2","nouns","indexNumber","adjective","replace","c","toUpperCase","noun","name","symbol","substring","LogLevel","sleep","ms","setTimeout","Logger","logLevel","Error","this","_proto","prototype","setLevel","bypass","dispatch","Infinity","concat","arguments","debug","Verbose","Log","warn","Warn","error","verb","level","_console","console","constant","inputs","outputs","type","payable","stateMutability","anonymous","indexed","allowanceWei","tokenAddress","account","spender","allowance","trxReceipt","configHelperNetworksBase","chainId","network","metadataCacheUri","nodeUri","providerUri","subgraphUri","explorerUri","oceanTokenAddress","oceanTokenSymbol","fixedRateExchangeAddress","dispenserAddress","startBlock","configHelperNetworks","_extends","ConfigHelper","getAddressesFromEnv","customAddresses","configAddresses","_customAddresses$netw","nftFactoryAddress","ERC721Factory","opfCommunityFeeCollector","OPFCommunityFeeCollector","FixedPrice","Dispenser","Ocean","veAllocate","veOCEAN","veDelegation","veFeeDistributor","veDelegationProxy","DFRewards","DFStrategyV1","veFeeEstimate","process","env","AQUARIUS_URI","DefaultContractsAddresses","_DefaultContractsAddr","getConfig","infuraProjectId","filterBy","find","_config","SmartContract","abi","getDefaultAbi","_this6$config","getContract","address","SmartContractWithAddress","_SmartContract","_this","_inheritsLoose","_SmartContractWithAdd","DispenserAbi","status","dtAdress","_this2","maxTokens","utils","fromWei","maxBalance","balance","create","dtAddress","allowedSwapper","_this4","toWei","_this4$config","activate","_this6","deactivate","_this8","_this8$config","setAllowedSwapper","newAllowedSwapper","_this10","_this10$config","dispense","destination","_this12","_this12$config","ownerWithdraw","_this14","_this14$config","isDispensable","datatoken","active","_datatoken$balance","Decimal","greaterThanOrEqualTo","String","greaterThan","isMinter","FixedRateExchange","FixedRateExchangeAbi","generateExchangeId","baseToken","buyDatatokens","exchangeId","datatokenAmount","maxBaseTokenAmount","consumeMarketAddress","consumeMarketFee","getExchange","exchange","consumeMarketFeeFormatted","dtDecimals","dtAmountFormatted","btDecimals","maxBtFormatted","buyDT","sellDatatokens","minBaseTokenAmount","minBtFormatted","sellDT","getNumberOfExchanges","setRate","newRate","toggleExchangeState","_this16","_this16$config","getRate","_this18","weiRate","getDatatokenSupply","_this20","getDTSupply","dtSupply","getBasetokenSupply","_this22","getBTSupply","btSupply","getAllowedSwapper","calcBaseInGivenDatatokensOut","_this26","fixedRateExchange","_this25$contract$meth","_calcBaseInGivenOutDT","calcBaseInGivenOutDT","_this25$amountToUnits","outDT","baseTokenAmount","_this25$unitsToAmount","marketFeeAmount","_this25$unitsToAmount2","oceanFeeAmount","_this25$unitsToAmount3","consumeMarketFeeAmount","_this25$unitsToAmount4","getAmountBasetokensOut","_this28","_this27$contract$meth","_calcBaseOutGivenInDT","calcBaseOutGivenInDT","_this27$amountToUnits","_this30","dtBalance","_this29$unitsToAmount","btBalance","_this29$unitsToAmount2","_this29$unitsToAmount3","_this29$unitsToAmount4","fixedRate","getFeesInfo","_this32","feesInfo","opcFee","marketFee","marketFeeAvailable","_this31$unitsToAmount","oceanFeeAvailable","_this31$unitsToAmount2","getExchanges","isActive","activateMint","_this38","withMint","toggleMintState","_this38$config","deactivateMint","_this40","_this40$config","collectBasetokens","_this42","fixedrate","amountWei","collectBT","_this42$config","collectDatatokens","_this44","collectDT","_this44$config","collectMarketFee","_this46","_this46$config","collectOceanFee","_this48","_this48$config","getOPCCollector","opcCollector","getRouter","router","getExchangeOwner","_this53$getExchange","exchangeOwner","updateMarketFee","newMarketFee","_this56","_this56$config","updateMarketFeeCollector","newMarketFeeCollector","_this58","_this58$config","Router","FactoryRouter","buyDatatokenBatch","operations","buyDTBatch","_this2$config","isApprovedToken","isFixedPrice","isFixedRateContract","getOwner","routerOwner","getNFTFactory","factory","addApprovedToken","_this11$getOwner","removeApprovedToken","_this13$getOwner","addFixedRateContract","_this15$getOwner","removeFixedRateContract","_this17$getOwner","_this18$config","addDispenserContract","_this19$getOwner","_this20$config","removeDispenserContract","_this21$getOwner","_this22$config","getOPCFee","getCurrentOPCFee","swapOceanFee","updateOPCFee","newSwapOceanFee","newSwapNonOceanFee","newConsumeFee","newProviderFee","_this27$getOwner","_this28$config","Nft","ERC721Template","createDatatoken","nftAddress","minter","paymentCollector","mpFeeAddress","feeToken","feeAmount","cap","templateIndex","getNftPermissions","_this$getNftPermissio","deployERC20","_generateDtName","nftContract","createERC20","_trxReceipt$events","_trxReceipt$events$To","_trxReceipt$events$To2","events","TokenCreated","returnValues","addManager","manager","getNftOwner","_this3$getNftOwner","removeManager","_this5$getNftOwner","addDatatokenDeployer","datatokenDeployer","_this7$getNftPermissi","addToCreateERC20List","removeDatatokenDeployer","_this9$getNftPermissi","_this9$getNftPermissi2","_temp","removeFromCreateERC20List","addMetadataUpdater","metadataUpdater","_this11$getNftPermiss","addToMetadataList","removeMetadataUpdater","_this13$getNftPermiss","_this13$getNftPermiss2","_temp3","updateMetadata","removeFromMetadataList","addStoreUpdater","storeUpdater","_this15$getNftPermiss","addTo725StoreList","removeStoreUpdater","_this17$getNftPermiss","_this17$getNftPermiss2","store","removeFrom725StoreList","cleanPermissions","_this19$getNftOwner","transferNft","nftOwner","nftReceiver","tokenId","_this21$getNftOwner","tokenIdentifier","transferFrom","safeTransferNft","_this24","_this23$getNftOwner","safeTransferFrom","_this24$config","setMetadata","metadataState","metadataDecryptorUrl","metadataDecryptorAddress","flags","data","metadataHash","metadataProofs","_this25$getNftPermiss","setMetaData","_this26$config","setMetadataAndTokenURI","metadataAndTokenURI","_this27$getNftPermiss","sanitizedMetadataAndTokenURI","setMetaDataAndTokenURI","setMetadataState","_this29$getNftPermiss","setMetaDataState","_this30$config","setTokenURI","_this32$config","ownerOf","getPermissions","getMetadata","getMetaData","isDatatokenDeployer","isERC20Deployer","setData","key","value","_this41$getNftPermiss","keyHash","keccak256","valueHex","asciiToHex","setNewData","getData","hexToAscii","getTokenURI","id","tokenURI","Datatoken","abiEnterprise","nft","ERC20TemplateEnterprise","ERC20Template","approve","dtContract","_this3","_this3$config","createFixedRate","fixedRateParams","_this5","_this4$isDatatokenDep","allowedConsumer","fixedRateAddress","baseTokenAddress","owner","marketFeeCollector","baseTokenDecimals","datatokenDecimals","_this5$config","createDispenser","dispenserParams","_this7","_this6$isDatatokenDep","_this7$config","mint","toAddress","_this9","_this8$getPermissions","getCap","capAvailble","gte","_this9$config","addMinter","_this11","_this10$isDatatokenDe","_this11$config","removeMinter","_this13","_this12$isDatatokenDe","_this13$config","addPaymentManager","paymentManager","_this15","_this14$isDatatokenDe","_this15$config","removePaymentManager","_this17","_this16$isDatatokenDe","_this17$config","setPaymentCollector","_this19","_this18$getPermission","_this18$nft$getNftOwn","nftPermissions","isPaymentManager","isNftOwner","_this19$config","getNFTAddress","getPaymentCollector","transfer","weiAmount","transferWei","_this25","_this25$config","startOrder","consumer","serviceIndex","providerFees","_this27","consumeMarketFeeAddress","consumeMarketFeeToken","_this27$config","reuseOrder","orderTxId","_this29","_this29$config","buyFromFreAndOrder","orderParams","freParams","_this31","getFreOrderParams","freContractParams","_this31$config","buyFromDispenserAndOrder","dispenserContract","_this33","_this33$config","_this35","_this34$isDatatokenDe","_this35$config","_this36$nft2","_this37","_getNftOwner2","_this36$getNFTAddress","_this36$nft$getNftOwn","_this37$config","permissions","_this41","getDecimals","getSymbol","getName","getERC721Address","datatokenAddress","_this53","balanceOf","setPublishingMarketFee","publishMarketFeeAddress","publishMarketFeeToken","publishMarketFeeAmount","_this55","getPublishingMarketFee","_dtContract$methods$g","_this55$config","publishingMarketFee","_freParams$exchangeId2","_freParams$exchangeCo2","exchangeContract","_this59","_amountToUnits","swapMarketFee","_amountToUnits2","marketFeeAddress","NftFactory","createNFT","nftData","_nftData$templateInde2","getCurrentNFTTemplateCount","_this$getCurrentNFTTe","getNFTTemplate","_this$getNFTTemplate","deployERC721Contract","transferable","_trxReceipt$events$NF","_trxReceipt$events$NF2","NFTCreated","getCurrentNFTCount","getCurrentTokenCount","getCurrentTokenTemplateCount","getCurrentTemplateCount","index","_this13$getCurrentNFT","getTokenTemplate","checkDatatoken","erc20List","checkNFT","erc721List","addNFTTemplate","templateAddress","add721TokenTemplate","disableNFTTemplate","_this23$getOwner","_this23$getCurrentNFT","disable721TokenTemplate","reactivateNFTTemplate","_this25$getOwner","_this25$getCurrentNFT","reactivate721TokenTemplate","addTokenTemplate","disableTokenTemplate","_this29$getOwner","_this29$getCurrentTok","_this29$getTokenTempl","reactivateTokenTemplate","_this31$getOwner","_this31$getCurrentTok","_this31$getTokenTempl","startMultipleTokenOrder","orders","_this34","_this34$config","createNftWithDatatoken","nftCreateData","dtParams","ercCreateData","_this36","getErcCreationParams","createNftWithErc20","_this36$config","createNftWithDatatokenWithFixedRate","fixedData","getFreCreationParams","createNftWithErc20WithFixedRate","createNftWithDatatokenWithDispenser","Web3","createNftWithErc20WithDispenser","_generateDtName2","strings","addresses","uints","bytess","fixedPriceAddress","VeOcean","veOceanABI","lockTokens","userAddress","unlockTime","getToken","_this$getToken","create_lock","depositFor","fromUserAddress","_amountToUnits4","_this3$getToken","deposit_for","increaseAmount","_amountToUnits6","_this5$getToken","increase_amount","increaseUnlockTime","increase_unlock_time","withdraw","getVotingPower","getLockedAmount","locked","_unitsToAmount","_this13$getToken","lockEnd","locked__end","totalSupply","_unitsToAmount3","_this17$getToken","_this17$contract$meth","VeFeeDistributor","veFeeABI","claim","claimMany","claim_many","VeFeeEstimate","estimateClaim","voting_escrow","_this$contract$method","veOcean","_veOcean$getToken","VeAllocate","veAllocateABI","setAllocation","setBatchAllocation","getTotalAllocation","getVeAllocation","getveAllocation","v","_settle","pact","state","bind","DfRewards","dfRewardsABI","getAvailableRewards","claimable","rewards","claimRewards","claimFor","allocateRewards","userAddresses","amounts","allocate","i","_this5$amountToUnits","DfStrategyV1","dfStrategyV1ABI","getMultipleAvailableRewards","tokenAddresses","claimables","rewardsFormated","_push","push","_this$unitsToAmount","claimMultipleRewards","claimMultiple","o","result","Aquarius","aquariusURL","did","signal","path","fetch","method","headers","response","ok","json","waitForAqua","txid","tries","_do","_result","_exit2","ddo","event","_result3","validate","jsonResponse","valid","body","JSON","stringify","_response$json","hash","proof","validatorAddress","publicKey","r","s","errors","getAssetMetadata","statusText","querySearch","query","Provider","getEndpoints","endpoints","getEndpointURL","servicesEndpoints","serviceName","getServiceEndpoints","providerEndpoint","serviceEndpoints","urlPath","getNonce","consumerAddress","providerEndpoints","nonce","_this3$getServiceEndp","_this3$getEndpoints","signProviderRequest","accountId","password","consumerMessage","soliditySha3","t","utf8ToHex","currentProvider","isMetaMask","personal","sign","encrypt","text","checkDidFiles","serviceId","withChecksum","args","checksum","files","results","_step","_iterator","_createForOfIteratorHelperLoose","done","getFileInfo","file","_step2","_iterator2","getComputeEnvironments","_this12$getEndpointUR","initialize","fileIndex","userCustomParameters","computeEnv","validUntil","initializeUrl","encodeURI","initializeCompute","assets","algorithm","providerData","datasets","compute","getDownloadUrl","transferTxId","downloadUrl","Date","now","signature","consumeUrl","computeStart","dataset","additionalDatasets","output","computeStartUrl","signatureMessage","documentId","payload","Object","environment","_exit","_temp8","_error","_response$statusText","_response$status","_response$json2","params","computeStop","jobId","computeStopUrl","noZeroX","_temp10","_result2","_temp9","computeStatus","computeStatusUrl","url","_exit3","_temp12","_temp11","getComputeResultUrl","computeResultUrl","resultUrl","computeDelete","computeDeleteUrl","_exit4","_temp14","_result4","_temp13","isValidProvider","_exit5","_temp15","providerAddress","providerAddresses","_result5","input","zeroXTransformer","zeroOutput","_this$inputMatch","inputMatch","regexp","conversorName","match","ProviderInstance","web3Provider","datatokensABI","fixedRateExchangeAddressABI","dispenserABI","sideStakingAddress","verbose","authMessage","authTokenExpiration","parityUri","threshold","force","currentAllowence","_Decimal$toNumber2","toNumber","_sendTx","gt","_Decimal$toNumber4","filename","get","_unused","split","pop","_unused2","arrayBuffer","_response$arrayBuffer","headResponse","contentHeader","fileName","xhr","XMLHttpRequest","responseType","open","onload","blobURL","window","URL","createObjectURL","a","document","createElement","href","setAttribute","appendChild","click","remove","revokeObjectURL","toChecksumAddress","sha256","signedMessage","substr","recipient"],"mappings":"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"}